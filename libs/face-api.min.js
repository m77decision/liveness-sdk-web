"use strict";var faceapi=(()=>{var e,t=Object.defineProperty,n=Object.getOwnPropertyDescriptor,r=Object.getOwnPropertyNames,a=Object.prototype.hasOwnProperty,s=(e=function(e){if("undefined"!=typeof require)return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')},"undefined"!=typeof require?require:"undefined"!=typeof Proxy?new Proxy(e,{get:(e,t)=>("undefined"!=typeof require?require:e)[t]}):e),i=(e,n)=>{for(var r in n)t(e,r,{get:n[r],enumerable:!0})},o={};i(o,{AgeGenderNet:()=>a0,BoundingBox:()=>fJ,Box:()=>cJ,ComposableTask:()=>Q0,ComputeAllFaceDescriptorsTask:()=>O1,ComputeFaceDescriptorsTaskBase:()=>M1,ComputeSingleFaceDescriptorTask:()=>L1,DetectAllFaceLandmarksTask:()=>P1,DetectAllFacesTask:()=>V1,DetectFaceLandmarksTaskBase:()=>z1,DetectFacesTaskBase:()=>W1,DetectSingleFaceLandmarksTask:()=>B1,DetectSingleFaceTask:()=>U1,Dimensions:()=>ZZ,FACE_EXPRESSION_LABELS:()=>BQ,FaceDetection:()=>gJ,FaceDetectionNet:()=>O0,FaceExpressionNet:()=>VQ,FaceExpressions:()=>WQ,FaceLandmark68Net:()=>i0,FaceLandmark68TinyNet:()=>l0,FaceLandmarkNet:()=>u0,FaceLandmarks:()=>_J,FaceLandmarks5:()=>CJ,FaceLandmarks68:()=>EJ,FaceMatch:()=>$J,FaceMatcher:()=>Y1,FaceRecognitionNet:()=>y0,Gender:()=>r0,LabeledBox:()=>AJ,LabeledFaceDescriptors:()=>FJ,NetInput:()=>lQ,NeuralNetwork:()=>wQ,ObjectDetection:()=>mJ,Point:()=>hJ,PredictedBox:()=>RJ,Rect:()=>TJ,SsdMobilenetv1:()=>R0,SsdMobilenetv1Options:()=>F0,TinyFaceDetector:()=>a1,TinyFaceDetectorOptions:()=>J0,TinyYolov2:()=>Y0,TinyYolov2Options:()=>q0,allFaces:()=>K1,allFacesSsdMobilenetv1:()=>j1,allFacesTinyYolov2:()=>q1,awaitMediaLoaded:()=>eQ,bufferToImage:()=>tQ,computeFaceDescriptor:()=>d1,createCanvas:()=>rQ,createCanvasFromMedia:()=>aQ,createFaceDetectionNet:()=>M0,createFaceRecognitionNet:()=>b0,createSsdMobilenetv1:()=>D0,createTinyFaceDetector:()=>Z1,createTinyYolov2:()=>Z0,detectAllFaces:()=>H1,detectFaceLandmarks:()=>u1,detectFaceLandmarksTiny:()=>p1,detectLandmarks:()=>S1,detectSingleFace:()=>G1,draw:()=>KZ,env:()=>UJ,euclideanDistance:()=>X1,extendWithAge:()=>v0,extendWithFaceDescriptor:()=>x0,extendWithFaceDetection:()=>MJ,extendWithFaceExpressions:()=>GQ,extendWithFaceLandmarks:()=>qQ,extendWithGender:()=>I0,extractFaceTensors:()=>dQ,extractFaces:()=>pQ,fetchImage:()=>cQ,fetchJson:()=>fQ,fetchNetWeights:()=>mQ,fetchOrThrow:()=>hQ,fetchVideo:()=>gQ,getContext2dOrThrow:()=>HJ,getMediaDimensions:()=>nQ,imageTensorToCanvas:()=>sQ,imageToSquare:()=>oQ,inverseSigmoid:()=>SJ,iou:()=>yJ,isMediaElement:()=>iQ,isMediaLoaded:()=>QJ,isWithAge:()=>w0,isWithFaceDetection:()=>DJ,isWithFaceExpressions:()=>UQ,isWithFaceLandmarks:()=>jQ,isWithGender:()=>k0,loadAgeGenderModel:()=>v1,loadFaceDetectionModel:()=>k1,loadFaceExpressionModel:()=>w1,loadFaceLandmarkModel:()=>y1,loadFaceLandmarkTinyModel:()=>b1,loadFaceRecognitionModel:()=>x1,loadSsdMobilenetv1Model:()=>f1,loadTinyFaceDetectorModel:()=>m1,loadTinyYolov2Model:()=>g1,loadWeightMap:()=>bQ,locateFaces:()=>I1,matchDimensions:()=>xQ,minBbox:()=>bJ,nets:()=>s1,nonMaxSuppression:()=>xJ,normalize:()=>wJ,padToSquare:()=>vJ,predictAgeAndGender:()=>c1,recognizeFaceExpressions:()=>h1,resizeResults:()=>J1,resolveInput:()=>GJ,shuffleArray:()=>kJ,sigmoid:()=>IJ,ssdMobilenetv1:()=>i1,tf:()=>l,tinyFaceDetector:()=>o1,tinyYolov2:()=>l1,toNetInput:()=>uQ,utils:()=>YZ,validateConfig:()=>W0,version:()=>Q1});var l={};i(l,{Abs:()=>Ge,Acos:()=>He,Acosh:()=>je,AdadeltaOptimizer:()=>Oc,AdagradOptimizer:()=>Lc,AdamOptimizer:()=>zc,AdamaxOptimizer:()=>Pc,Add:()=>qe,AddN:()=>Ke,All:()=>Xe,Any:()=>Ye,ArgMax:()=>Ze,ArgMin:()=>Je,Asin:()=>Qe,Asinh:()=>et,Atan:()=>tt,Atan2:()=>rt,Atanh:()=>nt,AvgPool:()=>at,AvgPool3D:()=>it,AvgPool3DGrad:()=>ot,AvgPoolGrad:()=>st,BackendWasm:()=>$Z,BatchMatMul:()=>lt,BatchToSpaceND:()=>ut,Bincount:()=>pt,BitwiseAnd:()=>dt,BroadcastArgs:()=>ct,BroadcastTo:()=>ht,Callback:()=>yT,CallbackList:()=>Jw,Cast:()=>ft,Ceil:()=>mt,ClipByValue:()=>gt,Complex:()=>yt,ComplexAbs:()=>bt,Concat:()=>xt,Conv2D:()=>wt,Conv2DBackpropFilter:()=>vt,Conv2DBackpropInput:()=>kt,Conv3D:()=>It,Conv3DBackpropFilterV2:()=>St,Conv3DBackpropInputV2:()=>Nt,Cos:()=>Tt,Cosh:()=>_t,CropAndResize:()=>$t,Cumprod:()=>Ct,Cumsum:()=>Et,CustomCallback:()=>tv,DataStorage:()=>P,DenseBincount:()=>At,DepthToSpace:()=>Ft,DepthwiseConv2dNative:()=>Rt,DepthwiseConv2dNativeBackpropFilter:()=>Dt,DepthwiseConv2dNativeBackpropInput:()=>Mt,Diag:()=>Ot,Dilation2D:()=>Lt,Dilation2DBackpropFilter:()=>Pt,Dilation2DBackpropInput:()=>zt,Draw:()=>Bt,ENV:()=>We,EarlyStopping:()=>wT,Einsum:()=>Vt,Elu:()=>Ut,EluGrad:()=>Gt,Environment:()=>Le,Equal:()=>jt,Erf:()=>Ht,Exp:()=>qt,ExpandDims:()=>Kt,Expm1:()=>Xt,FFT:()=>Yt,Fill:()=>Zt,FlipLeftRight:()=>Jt,Floor:()=>Qt,FloorDiv:()=>en,FromPixels:()=>aa,FusedBatchNorm:()=>tn,FusedConv2D:()=>oa,FusedDepthwiseConv2D:()=>la,GPGPUContext:()=>xz,GatherNd:()=>rn,GatherV2:()=>nn,GraphModel:()=>lC,Greater:()=>an,GreaterEqual:()=>sn,History:()=>ev,IFFT:()=>ln,Identity:()=>on,Imag:()=>un,InputSpec:()=>ew,IsFinite:()=>pn,IsInf:()=>dn,IsNan:()=>hn,KernelBackend:()=>B,LRN:()=>Nn,LRNGrad:()=>Tn,LayerVariable:()=>Zx,LayersModel:()=>nk,LeakyRelu:()=>cn,Less:()=>fn,LessEqual:()=>mn,LinSpace:()=>gn,Log:()=>yn,Log1p:()=>bn,LogSoftmax:()=>In,LogicalAnd:()=>xn,LogicalNot:()=>wn,LogicalOr:()=>vn,LogicalXor:()=>kn,LowerBound:()=>Sn,MathBackendCPU:()=>_E,MathBackendWebGL:()=>VP,MatrixBandPart:()=>_n,Max:()=>Cn,MaxPool:()=>$n,MaxPool3D:()=>Fn,MaxPool3DGrad:()=>Rn,MaxPoolGrad:()=>An,MaxPoolWithArgmax:()=>Dn,Maximum:()=>En,Mean:()=>Mn,Min:()=>On,Minimum:()=>Ln,MirrorPad:()=>zn,Mod:()=>Pn,MomentumOptimizer:()=>Wc,Multinomial:()=>Bn,Multiply:()=>Wn,Neg:()=>Vn,NonMaxSuppressionV3:()=>Gn,NonMaxSuppressionV4:()=>Hn,NonMaxSuppressionV5:()=>jn,NotEqual:()=>Un,OP_SCOPE_SUFFIX:()=>Vs,OneHot:()=>Kn,OnesLike:()=>qn,Optimizer:()=>Mc,OptimizerConstructors:()=>qf,Pack:()=>Xn,PadV2:()=>Yn,Pool:()=>Zn,Pow:()=>Jn,Prelu:()=>Qn,Prod:()=>er,RMSPropOptimizer:()=>Vc,RNN:()=>pI,RaggedGather:()=>tr,RaggedRange:()=>nr,RaggedTensorToTensor:()=>rr,Range:()=>ar,Rank:()=>us,Real:()=>sr,RealDiv:()=>Wt,Reciprocal:()=>ir,Reduction:()=>nc,Relu:()=>or,Relu6:()=>cr,Reshape:()=>lr,ResizeBilinear:()=>dr,ResizeBilinearGrad:()=>hr,ResizeNearestNeighbor:()=>ur,ResizeNearestNeighborGrad:()=>pr,Reverse:()=>fr,RotateWithOffset:()=>sa,Round:()=>mr,Rsqrt:()=>gr,SGDOptimizer:()=>Bc,ScatterNd:()=>yr,SearchSorted:()=>xr,Select:()=>wr,Selu:()=>vr,Sequential:()=>ik,Sigmoid:()=>Tr,Sign:()=>Nr,Sin:()=>Ir,Sinh:()=>Sr,Slice:()=>kr,Softmax:()=>Fr,Softplus:()=>_r,SpaceToBatchND:()=>$r,SparseFillEmptyRows:()=>Rr,SparseReshape:()=>Dr,SparseSegmentMean:()=>Mr,SparseSegmentSum:()=>Or,SparseToDense:()=>Lr,SplitV:()=>Ar,Sqrt:()=>Cr,Square:()=>Pr,SquaredDifference:()=>zr,StaticRegexReplace:()=>Br,Step:()=>ra,StridedSlice:()=>Wr,StringNGrams:()=>Vr,StringSplit:()=>Ur,StringToHashBucketFast:()=>Gr,Sub:()=>Hr,Sum:()=>Er,SymbolicTensor:()=>tw,Tan:()=>jr,Tanh:()=>qr,Tensor:()=>is,TensorBuffer:()=>rs,TensorScatterUpdate:()=>br,Tile:()=>Kr,TopK:()=>Xr,Transform:()=>Yr,Transpose:()=>Zr,Unique:()=>Jr,Unpack:()=>Qr,UnsortedSegmentSum:()=>ea,UpperBound:()=>ta,Variable:()=>ls,ZerosLike:()=>na,_FusedMatMul:()=>ia,abs:()=>Io,acos:()=>So,acosh:()=>No,add:()=>xo,addN:()=>To,all:()=>_o,any:()=>Co,argMax:()=>Eo,argMin:()=>$o,asin:()=>Ao,asinh:()=>Fo,atan:()=>Ro,atan2:()=>Do,atanh:()=>Mo,avgPool:()=>Jo,avgPool3d:()=>Qo,backend:()=>fi,backend_util:()=>Jf,basicLSTMCell:()=>sl,batchNorm:()=>ll,batchNorm2d:()=>ul,batchNorm3d:()=>pl,batchNorm4d:()=>dl,batchToSpaceND:()=>il,bincount:()=>hl,bitwiseAnd:()=>cl,booleanMaskAsync:()=>rh,broadcastArgs:()=>fl,broadcastTo:()=>ml,broadcast_util:()=>Pl,browser:()=>ff,buffer:()=>mo,callbacks:()=>IT,cast:()=>go,ceil:()=>gl,clipByValue:()=>bl,clone:()=>yo,complex:()=>Gs,concat:()=>el,concat1d:()=>xl,concat2d:()=>wl,concat3d:()=>vl,concat4d:()=>kl,constraints:()=>gw,conv1d:()=>Sl,conv2d:()=>Il,conv2dTranspose:()=>Tl,conv3d:()=>_l,conv3dTranspose:()=>El,copyRegisteredKernels:()=>wa,cos:()=>$l,cosh:()=>Al,cosineWindow:()=>dh,cumprod:()=>Fl,cumsum:()=>Rl,customGrad:()=>Wu,data:()=>hC,denseBincount:()=>Dl,deprecationWarn:()=>Js,depthToSpace:()=>Ml,depthwiseConv2d:()=>Ol,deregisterOp:()=>_T,device_util:()=>Fs,diag:()=>Ll,dilation2d:()=>zl,disableDeprecationWarnings:()=>Zs,dispose:()=>ai,disposeVariables:()=>Qs,div:()=>vo,divNoNan:()=>jl,dot:()=>ql,dropout:()=>uh,einsum:()=>Kl,elu:()=>Xl,enableDebugMode:()=>Ys,enableProdMode:()=>Xs,enclosingPowerOfTwo:()=>ph,engine:()=>ei,ensureShape:()=>Yl,env:()=>Pe,equal:()=>Ul,erf:()=>Zl,euclideanNorm:()=>mu,exp:()=>gu,expandDims:()=>yu,expm1:()=>bu,eye:()=>wu,fft:()=>Td,fill:()=>yl,findBackend:()=>di,findBackendFactory:()=>hi,floor:()=>vu,floorDiv:()=>wo,forceHalfFloat:()=>GP,fused:()=>ch,gather:()=>ku,gatherND:()=>lh,gather_util:()=>Sf,getBackend:()=>ui,getGradient:()=>fa,getKernel:()=>ca,getKernelsForBackend:()=>ma,getThreadsCount:()=>GZ,gpgpu_util:()=>YL,grad:()=>Ou,grads:()=>Lu,greater:()=>Iu,greaterEqual:()=>Su,ifft:()=>_d,imag:()=>Nu,image:()=>Ic,inTopKAsync:()=>hh,initializers:()=>Aw,input:()=>uk,io:()=>Gc,irfft:()=>Cd,isFinite:()=>Tu,isInf:()=>_u,isNaN:()=>Cu,keep:()=>si,kernel_impls:()=>ag,layers:()=>Kw,leakyRelu:()=>Eu,less:()=>$u,lessEqual:()=>Au,linalg:()=>Sc,linspace:()=>Fu,loadGraphModel:()=>uC,loadGraphModelSync:()=>pC,loadLayersModel:()=>sk,localResponseNormalization:()=>Ru,log:()=>Du,log1p:()=>Mu,logSigmoid:()=>Hu,logSoftmax:()=>qu,logSumExp:()=>Ku,logicalAnd:()=>Xu,logicalNot:()=>Yu,logicalOr:()=>Zu,logicalXor:()=>Ju,losses:()=>Nc,lowerBound:()=>tp,matMul:()=>tl,math:()=>hf,max:()=>iu,maxPool:()=>np,maxPool3d:()=>rp,maxPoolWithArgmax:()=>ap,maximum:()=>sp,mean:()=>ip,memory:()=>ti,meshgrid:()=>up,metrics:()=>XN,min:()=>ou,minimum:()=>pp,mirrorPad:()=>dp,mod:()=>hp,model:()=>ok,models:()=>hT,moments:()=>cp,movingAverage:()=>sh,mul:()=>ko,multiRNNCell:()=>fp,multinomial:()=>mp,neg:()=>Uu,nextFrame:()=>Yf,norm:()=>fu,notEqual:()=>gp,oneHot:()=>yp,ones:()=>lp,onesLike:()=>bp,op:()=>Us,outerProduct:()=>xp,pad:()=>wp,pad1d:()=>vp,pad2d:()=>kp,pad3d:()=>Ip,pad4d:()=>Sp,pool:()=>Tp,pow:()=>lu,prelu:()=>_p,print:()=>bo,prod:()=>Cp,profile:()=>ni,raggedGather:()=>Ep,raggedRange:()=>$p,raggedTensorToTensor:()=>Ap,rand:()=>Fp,randomGamma:()=>Jp,randomNormal:()=>Qp,randomStandardNormal:()=>ed,randomUniform:()=>td,randomUniformInt:()=>nd,range:()=>rd,ready:()=>li,real:()=>ad,reciprocal:()=>sd,registerBackend:()=>ci,registerCallbackConstructor:()=>pk,registerGradient:()=>ya,registerKernel:()=>ga,registerOp:()=>NT,regularizers:()=>cT,relu:()=>id,relu6:()=>od,removeBackend:()=>pi,reshape:()=>Zo,reverse:()=>ld,reverse1d:()=>ud,reverse2d:()=>pd,reverse3d:()=>dd,reverse4d:()=>hd,rfft:()=>$d,round:()=>cd,rsqrt:()=>fd,scalar:()=>uu,scatterND:()=>ih,scatter_util:()=>Ud,searchSorted:()=>ep,selu:()=>md,separableConv2d:()=>gd,sequential:()=>lk,serialization:()=>Cc,setBackend:()=>oi,setPlatform:()=>mi,setThreadsCount:()=>UZ,setWasmPath:()=>PZ,setWasmPaths:()=>BZ,setWebGLContext:()=>fO,setdiff1dAsync:()=>yd,shared:()=>CE,sigmoid:()=>nl,sign:()=>bd,signal:()=>kc,sin:()=>xd,sinh:()=>wd,slice:()=>rl,slice1d:()=>vd,slice2d:()=>kd,slice3d:()=>Id,slice4d:()=>Sd,slice_util:()=>Tf,softmax:()=>Nd,softplus:()=>Gu,spaceToBatchND:()=>Np,sparse:()=>Tc,sparseToDense:()=>oh,spectral:()=>vc,split:()=>Ed,sqrt:()=>pu,square:()=>du,squaredDifference:()=>Ad,squeeze:()=>Fd,stack:()=>Rd,step:()=>Dd,stridedSlice:()=>Md,string:()=>_c,sub:()=>ju,sum:()=>hu,sumOutType:()=>ys,tan:()=>Od,tanh:()=>al,tensor:()=>js,tensor1d:()=>Ld,tensor2d:()=>zd,tensor3d:()=>Pd,tensor4d:()=>Bd,tensor5d:()=>Wd,tensor6d:()=>Vd,tensorScatterUpdate:()=>qd,tensor_util:()=>fs,test_util:()=>Dp,tidy:()=>ri,tile:()=>xu,time:()=>ii,topk:()=>Kd,train:()=>Kf,transpose:()=>ah,truncatedNormal:()=>Xd,unique:()=>Yd,unregisterGradient:()=>xa,unregisterKernel:()=>ba,unsortedSegmentSum:()=>Zd,unstack:()=>Jd,upcastType:()=>gs,upperBound:()=>Qd,util:()=>ka,valueAndGrad:()=>zu,valueAndGrads:()=>Pu,variable:()=>eh,variableGrads:()=>Bu,version:()=>qZ,version_converter:()=>dC,version_core:()=>jf,version_cpu:()=>tF,version_layers:()=>Lv,version_wasm:()=>HZ,version_webgl:()=>UP,webgl:()=>HP,webgl_util:()=>lO,where:()=>Gl,whereAsync:()=>nh,zeros:()=>op,zerosLike:()=>Hl});var u=Object.create,p=Object.defineProperty,d=Object.getOwnPropertyDescriptor,h=Object.getOwnPropertyNames,c=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty,m=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),g=(e,t)=>{for(var n in t)p(e,n,{get:t[n],enumerable:!0})},y=(e,t,n)=>(n=null!=e?u(c(e)):{},((e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let a of h(t))!f.call(e,a)&&a!==n&&p(e,a,{get:()=>t[a],enumerable:!(r=d(t,a))||r.enumerable});return e})(!t&&e&&e.__esModule?n:p(n,"default",{value:e,enumerable:!0}),e)),b=m(((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function r(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e.__isLong__)}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0}),r.isLong=a;var s={},i={};function o(e,t){var n,r,a;return t?(a=0<=(e>>>=0)&&e<256)&&(r=i[e])?r:(n=u(e,(0|e)<0?-1:0,!0),a&&(i[e]=n),n):(a=-128<=(e|=0)&&e<128)&&(r=s[e])?r:(n=u(e,e<0?-1:0,!1),a&&(s[e]=n),n)}function l(e,t){if(isNaN(e))return t?b:y;if(t){if(e<0)return b;if(e>=f)return I}else{if(e<=-m)return S;if(e+1>=m)return k}return e<0?l(-e,t).neg():u(e%c|0,e/c|0,t)}function u(e,t,n){return new r(e,t,n)}r.fromInt=o,r.fromNumber=l,r.fromBits=u;var p=Math.pow;function d(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return y;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return d(e.substring(1),t,n).neg();for(var a=l(p(n,8)),s=y,i=0;i<e.length;i+=8){var o=Math.min(8,e.length-i),u=parseInt(e.substring(i,i+o),n);if(o<8){var h=l(p(n,o));s=s.mul(h).add(l(u))}else s=(s=s.mul(a)).add(l(u))}return s.unsigned=t,s}function h(e,t){return"number"==typeof e?l(e,t):"string"==typeof e?d(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}r.fromString=d,r.fromValue=h;var c=4294967296,f=c*c,m=f/2,g=o(1<<24),y=o(0);r.ZERO=y;var b=o(0,!0);r.UZERO=b;var x=o(1);r.ONE=x;var w=o(1,!0);r.UONE=w;var v=o(-1);r.NEG_ONE=v;var k=u(-1,2147483647,!1);r.MAX_VALUE=k;var I=u(-1,-1,!0);r.MAX_UNSIGNED_VALUE=I;var S=u(0,-2147483648,!1);r.MIN_VALUE=S;var N=r.prototype;N.toInt=function(){return this.unsigned?this.low>>>0:this.low},N.toNumber=function(){return this.unsigned?(this.high>>>0)*c+(this.low>>>0):this.high*c+(this.low>>>0)},N.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=l(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var a=l(p(e,6),this.unsigned),s=this,i="";;){var o=s.div(a),u=(s.sub(o.mul(a)).toInt()>>>0).toString(e);if((s=o).isZero())return u+i;for(;u.length<6;)u="0"+u;i=""+u+i}},N.getHighBits=function(){return this.high},N.getHighBitsUnsigned=function(){return this.high>>>0},N.getLowBits=function(){return this.low},N.getLowBitsUnsigned=function(){return this.low>>>0},N.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return 0!=this.high?t+33:t+1},N.isZero=function(){return 0===this.high&&0===this.low},N.eqz=N.isZero,N.isNegative=function(){return!this.unsigned&&this.high<0},N.isPositive=function(){return this.unsigned||this.high>=0},N.isOdd=function(){return 1==(1&this.low)},N.isEven=function(){return 0==(1&this.low)},N.equals=function(e){return a(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&(this.high===e.high&&this.low===e.low)},N.eq=N.equals,N.notEquals=function(e){return!this.eq(e)},N.neq=N.notEquals,N.ne=N.notEquals,N.lessThan=function(e){return this.comp(e)<0},N.lt=N.lessThan,N.lessThanOrEqual=function(e){return this.comp(e)<=0},N.lte=N.lessThanOrEqual,N.le=N.lessThanOrEqual,N.greaterThan=function(e){return this.comp(e)>0},N.gt=N.greaterThan,N.greaterThanOrEqual=function(e){return this.comp(e)>=0},N.gte=N.greaterThanOrEqual,N.ge=N.greaterThanOrEqual,N.compare=function(e){if(a(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},N.comp=N.compare,N.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(x)},N.neg=N.negate,N.add=function(e){a(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,s=65535&this.low,i=e.high>>>16,o=65535&e.high,l=e.low>>>16,p=0,d=0,c=0,f=0;return c+=(f+=s+(65535&e.low))>>>16,d+=(c+=r+l)>>>16,p+=(d+=n+o)>>>16,p+=t+i,u((c&=65535)<<16|(f&=65535),(p&=65535)<<16|(d&=65535),this.unsigned)},N.subtract=function(e){return a(e)||(e=h(e)),this.add(e.neg())},N.sub=N.subtract,N.multiply=function(e){if(this.isZero())return y;if(a(e)||(e=h(e)),n)return u(n.mul(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned);if(e.isZero())return y;if(this.eq(S))return e.isOdd()?S:y;if(e.eq(S))return this.isOdd()?S:y;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(g)&&e.lt(g))return l(this.toNumber()*e.toNumber(),this.unsigned);var t=this.high>>>16,r=65535&this.high,s=this.low>>>16,i=65535&this.low,o=e.high>>>16,p=65535&e.high,d=e.low>>>16,c=65535&e.low,f=0,m=0,b=0,x=0;return b+=(x+=i*c)>>>16,m+=(b+=s*c)>>>16,b&=65535,m+=(b+=i*d)>>>16,f+=(m+=r*c)>>>16,m&=65535,f+=(m+=s*d)>>>16,m&=65535,f+=(m+=i*p)>>>16,f+=t*c+r*d+s*p+i*o,u((b&=65535)<<16|(x&=65535),(f&=65535)<<16|(m&=65535),this.unsigned)},N.mul=N.multiply,N.divide=function(e){if(a(e)||(e=h(e)),e.isZero())throw Error("division by zero");var t,r,s;if(n)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?u((this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:y;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return w;s=b}else{if(this.eq(S))return e.eq(x)||e.eq(v)?S:e.eq(S)?x:(t=this.shr(1).div(e).shl(1)).eq(y)?e.isNegative()?x:v:(r=this.sub(e.mul(t)),s=t.add(r.div(e)));if(e.eq(S))return this.unsigned?b:y;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=y}for(r=this;r.gte(e);){t=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(t)/Math.LN2),o=i<=48?1:p(2,i-48),d=l(t),c=d.mul(e);c.isNegative()||c.gt(r);)c=(d=l(t-=o,this.unsigned)).mul(e);d.isZero()&&(d=x),s=s.add(d),r=r.sub(c)}return s},N.div=N.divide,N.modulo=function(e){return a(e)||(e=h(e)),n?u((this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},N.mod=N.modulo,N.rem=N.modulo,N.not=function(){return u(~this.low,~this.high,this.unsigned)},N.and=function(e){return a(e)||(e=h(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},N.or=function(e){return a(e)||(e=h(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},N.xor=function(e){return a(e)||(e=h(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},N.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},N.shl=N.shiftLeft,N.shiftRight=function(e){return a(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},N.shr=N.shiftRight,N.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?u(this.low>>>e|t<<32-e,t>>>e,this.unsigned):u(32===e?t:t>>>e-32,0,this.unsigned)},N.shru=N.shiftRightUnsigned,N.shr_u=N.shiftRightUnsigned,N.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},N.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},N.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},N.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},N.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},r.fromBytes=function(e,t,n){return n?r.fromBytesLE(e,t):r.fromBytesBE(e,t)},r.fromBytesLE=function(e,t){return new r(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},r.fromBytesBE=function(e,t){return new r(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}})),x=m((()=>{})),w=m((()=>{})),v=m(((e,t)=>{!function(e,t,n){function r(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function a(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new r(e),s=t&&t.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.alea=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),k=m(((e,t)=>{!function(e,t,n){function r(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor128=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),I=m(((e,t)=>{!function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorwow=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),S=m(((e,t)=>{!function(e,t,n){function r(e){var t=this;t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],n=(e^=e>>>7)^e<<24,n^=(e=r[a+1&7])^e>>>10,n^=(e=r[a+3&7])^e>>>3,n^=(e=r[a+4&7])^e<<7,e=r[a+7&7],n^=(e^=e<<13)^e<<9,r[a]=n,t.i=a+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function a(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&(s.x&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorshift7=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),N=m(((e,t)=>{!function(e,t,n){function r(e){var t=this;t.next=function(){var e,n,r=t.w,a=t.X,s=t.i;return t.w=r=r+1640531527|0,n=a[s+34&127],e=a[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[s]=n^e,t.i=s,n+(r^r>>>16)|0},function(e,t){var n,r,a,s,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),a=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(i=i+1640531527|0,a=0==(n=o[127&s]^=r+i)?a+1:0);for(a>=128&&(o[127&(t&&t.length||0)]=-1),a=127,s=512;s>0;--s)r=o[a+34&127],n=o[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[a]=r^n;e.w=i,e.X=o,e.i=a}(t,e)}function a(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&(s.X&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor4096=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),T=m(((e,t)=>{!function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.tychei=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),_=m((()=>{})),C=m(((e,t)=>{!function(e,n,r){var a,s=256,i="random",o=r.pow(s,6),l=r.pow(2,52),u=2*l,p=s-1;function d(t,p,d){var y=[],b=m(f((p=1==p?{entropy:!0}:p||{}).entropy?[t,g(n)]:null==t?function(){try{var t;return a&&(t=a.randomBytes)?t=t(s):(t=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues(t)),g(t)}catch(t){var r=e.navigator,i=r&&r.plugins;return[+new Date,e,i,e.screen,g(n)]}}():t,3),y),x=new h(y),w=function(){for(var e=x.g(6),t=o,n=0;e<l;)e=(e+n)*s,t*=s,n=x.g(1);for(;e>=u;)e/=2,t/=2,n>>>=1;return(e+n)/t};return w.int32=function(){return 0|x.g(4)},w.quick=function(){return x.g(4)/4294967296},w.double=w,m(g(x.S),n),(p.pass||d||function(e,t,n,a){return a&&(a.S&&c(a,x),e.state=function(){return c(x,{})}),n?(r[i]=e,t):e})(w,b,"global"in p?p.global:this==r,p.state)}function h(e){var t,n=e.length,r=this,a=0,i=r.i=r.j=0,o=r.S=[];for(n||(e=[n++]);a<s;)o[a]=a++;for(a=0;a<s;a++)o[a]=o[i=p&i+e[a%n]+(t=o[a])],o[i]=t;(r.g=function(e){for(var t,n=0,a=r.i,i=r.j,o=r.S;e--;)t=o[a=p&a+1],n=n*s+o[p&(o[a]=o[i=p&i+t])+(o[i]=t)];return r.i=a,r.j=i,n})(s)}function c(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function f(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(f(e[n],t-1))}catch(e){}return r.length?r:"string"==a?e:e+"\0"}function m(e,t){for(var n,r=e+"",a=0;a<r.length;)t[p&a]=p&(n^=19*t[p&a])+r.charCodeAt(a++);return g(t)}function g(e){return String.fromCharCode.apply(0,e)}if(m(r.random(),n),"object"==typeof t&&t.exports){t.exports=d;try{a=_()}catch(e){}}else"function"==typeof define&&define.amd?define((function(){return d})):r["seed"+i]=d}("undefined"!=typeof self?self:e,[],Math)})),E=m(((e,t)=>{var n=v(),r=k(),a=I(),s=S(),i=N(),o=T(),l=C();l.alea=n,l.xor128=r,l.xorwow=a,l.xorshift7=s,l.xor4096=i,l.tychei=o,t.exports=l})),$=m((()=>{})),A=m((()=>{})),F=m((()=>{})),R=m((()=>{})),D=m((()=>{})),M=m((()=>{})),O=m(((e,t)=>{var n,r=(n="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(n=n||__filename),function(e){function t(){return $.buffer!=z&&K($.buffer),B}function r(){return $.buffer!=z&&K($.buffer),W}function a(){return $.buffer!=z&&K($.buffer),V}function s(){return $.buffer!=z&&K($.buffer),U}var i,o,l,u=void 0!==(e=e||{})?e:{};u.ready=new Promise((function(e,t){i=e,o=t})),"undefined"!=typeof process&&process.listeners&&(l={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var p,d,h,c=Object.assign({},u),f=[],m=(e,t)=>{throw t},g="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,x=u.ENVIRONMENT_IS_PTHREAD||!1,w="";function v(e){return u.locateFile?u.locateFile(e,w):w+e}if(b){var k=A(),I=F();let e;w=y?I.dirname(w)+"/":__dirname+"/",p=(e,t)=>(e=ue(e)?new URL(e):I.normalize(e),k.readFileSync(e,t?void 0:"utf8")),h=e=>{var t=p(e,!0);return t.buffer||(t=new Uint8Array(t)),t},d=(e,t,n)=>{e=ue(e)?new URL(e):I.normalize(e),k.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),f=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof he))throw e})),process.on("unhandledRejection",(function(e){throw e})),m=(e,t)=>{if(ee())throw process.exitCode=e,t;(function(e){e instanceof he||C("exiting due to exception: "+e)})(t),process.exit(e)},u.inspect=function(){return"[Emscripten Module object]"};try{e=R()}catch(e){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),e}global.Worker=e.Worker}else(g||y)&&(y?w=self.location.href:"undefined"!=typeof document&&document.currentScript&&(w=document.currentScript.src),void 0!==n&&n&&(w=n),w=0!==w.indexOf("blob:")?w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):"",b||(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},y&&(h=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),d=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));b&&"undefined"==typeof performance&&(global.performance=D().performance);var S=console.log.bind(console),N=console.warn.bind(console);b&&(S=e=>k.writeSync(1,e+"\n"),N=e=>k.writeSync(2,e+"\n"));var T,_=u.print||S,C=u.printErr||N;Object.assign(u,c),c=null,u.arguments&&(f=u.arguments),u.thisProgram&&u.thisProgram,u.quit&&(m=u.quit),Atomics.load,Atomics.store,Atomics.compareExchange,u.wasmBinary&&(T=u.wasmBinary);var E=u.noExitRuntime||!0;"object"!=typeof WebAssembly&&se("no native wasm support detected");var $,O,L,z,P,B,W,V,U,G=!1,H="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function j(e,t,n){for(var r=(t>>>=0)+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.buffer&&H)return H.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,a):e.subarray(t,a));for(var s="";t<a;){var i=e[t++];if(128&i){var o=63&e[t++];if(192!=(224&i)){var l=63&e[t++];if((i=224==(240&i)?(15&i)<<12|o<<6|l:(7&i)<<18|o<<12|l<<6|63&e[t++])<65536)s+=String.fromCharCode(i);else{var u=i-65536;s+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else s+=String.fromCharCode((31&i)<<6|o)}else s+=String.fromCharCode(i)}return s}function q(e,n){return(e>>>=0)?j(t(),e,n):""}function K(e){z=e,u.HEAP8=P=new Int8Array(e),u.HEAP16=new Int16Array(e),u.HEAP32=W=new Int32Array(e),u.HEAPU8=B=new Uint8Array(e),u.HEAPU16=new Uint16Array(e),u.HEAPU32=V=new Uint32Array(e),u.HEAPF32=new Float32Array(e),u.HEAPF64=U=new Float64Array(e)}x&&(z=u.buffer);var X=u.INITIAL_MEMORY||16777216;if(x)$=u.wasmMemory,z=u.buffer;else if(u.wasmMemory)$=u.wasmMemory;else if(!(($=new WebAssembly.Memory({initial:X/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw C("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),b&&C("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");$&&(z=$.buffer),X=z.byteLength,K(z);var Y,Z=[],J=[],Q=[];function ee(){return E}function te(){!x&&be(J)}var ne=0,re=null,ae=null;function se(e){u.onAbort&&u.onAbort(e),C(e="Aborted("+e+")"),G=!0,L=1,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw o(t),t}var ie,oe="data:application/octet-stream;base64,";function le(e){return e.startsWith(oe)}function ue(e){return e.startsWith("file://")}function pe(e){try{if(e==ie&&T)return new Uint8Array(T);if(h)return h(e);throw"both async and sync fetching of the wasm failed"}catch(e){se(e)}}le(ie="tfjs-backend-wasm-threaded-simd.wasm")||(ie=v(ie));var de={};function he(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function ce(e){var t=ye.pthreads[e];(function(e,t){e||se(t)})(t),ye.returnWorkerToPool(t)}function fe(e){var t=ye.getNewWorker();if(!t)return 6;ye.runningWorkers.push(t),ye.pthreads[e.pthread_ptr]=t,t.pthread_ptr=e.pthread_ptr;var n={cmd:"run",start_routine:e.startRoutine,arg:e.arg,pthread_ptr:e.pthread_ptr};return t.runPthread=()=>{b&&t.ref(),t.postMessage(n,e.transferList),delete t.runPthread},t.loaded&&t.runPthread(),0}function me(e){if(x)return Te(1,1,e);L=e,ee()||(ye.terminateAllThreads(),u.onExit&&u.onExit(e),G=!0),m(e,new he(e))}var ge=function(e,t){if(L=e,!t&&x)throw xe(e),"unwind";me(e)},ye={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){x?ye.initWorker():ye.initMainThread()},initMainThread:function(){for(var e=8;e--;)ye.allocateUnusedWorker()},initWorker:function(){E=!1},setExitStatus:function(e){L=e},terminateAllThreads:function(){for(var e of Object.values(ye.pthreads))ye.returnWorkerToPool(e);for(var e of ye.unusedWorkers)e.terminate();ye.unusedWorkers=[]},returnWorkerToPool:function(e){var t=e.pthread_ptr;delete ye.pthreads[t],ye.unusedWorkers.push(e),ye.runningWorkers.splice(ye.runningWorkers.indexOf(e),1),e.pthread_ptr=0,b&&e.unref(),je(t)},receiveObjectTransfer:function(e){},threadInitTLS:function(){ye.tlsInitFunctions.forEach((e=>e()))},loadWasmModuleToWorker:function(e,t){e.onmessage=n=>{var r=n.data,a=r.cmd;if(e.pthread_ptr&&(ye.currentProxiedOperationCallerThread=e.pthread_ptr),r.targetThread&&r.targetThread!=Ve()){var s=ye.pthreads[r.targetThread];return s?s.postMessage(r,r.transferList):C('Internal error! Worker sent a message "'+a+'" to target pthread '+r.targetThread+", but that thread no longer exists!"),void(ye.currentProxiedOperationCallerThread=void 0)}"processProxyingQueue"===a?Se(r.queue):"spawnThread"===a?fe(r):"cleanupThread"===a?ce(r.thread):"killThread"===a?function(e){var t=ye.pthreads[e];delete ye.pthreads[e],t.terminate(),je(e),ye.runningWorkers.splice(ye.runningWorkers.indexOf(t),1),t.pthread_ptr=0}(r.thread):"cancelThread"===a?function(e){ye.pthreads[e].postMessage({cmd:"cancel"})}(r.thread):"loaded"===a?(e.loaded=!0,b&&e.unref(),t&&t(e),e.runPthread&&e.runPthread()):"print"===a?_("Thread "+r.threadId+": "+r.text):"printErr"===a?C("Thread "+r.threadId+": "+r.text):"alert"===a?alert("Thread "+r.threadId+": "+r.text):"setimmediate"===r.target?e.postMessage(r):"callHandler"===a?u[r.handler](...r.args):a&&C("worker sent an unknown command "+a),ye.currentProxiedOperationCallerThread=void 0},e.onerror=e=>{throw C("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},b&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){})));var r=[];for(var a of["onExit","onAbort","print","printErr"])u.hasOwnProperty(a)&&r.push(a);e.postMessage({cmd:"load",handlers:r,urlOrBlob:u.mainScriptUrlOrBlob||n,wasmMemory:$,wasmModule:O})},allocateUnusedWorker:function(){var e,t=v("tfjs-backend-wasm-threaded-simd.worker.js");e=new Worker(t),ye.unusedWorkers.push(e)},getNewWorker:function(){return 0==ye.unusedWorkers.length&&(ye.allocateUnusedWorker(),ye.loadWasmModuleToWorker(ye.unusedWorkers[0])),ye.unusedWorkers.pop()}};function be(e){for(;e.length>0;)e.shift()(u)}function xe(e){if(x)return Te(2,0,e);try{ge(e)}catch(e){!function(e){if(e instanceof he||"unwind"==e)return L;m(1,e)}(e)}}u.PThread=ye,u.establishStackSpace=function(){var e=Ve(),t=r()[e+52>>>2],n=r()[e+56>>>2];Ke(t,t-n),Ye(t)};var we,ve=[];function ke(e,t,n,r){return x?Te(3,1,e,t,n,r):Ie(e,t,n,r)}function Ie(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return C("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];if(x&&0===a.length)return ke(e,t,n,r);var s={startRoutine:n,pthread_ptr:e,arg:r,transferList:a};return x?(s.cmd="spawnThread",postMessage(s,a),0):fe(s)}function Se(e){Atomics.store(r(),e>>2,1),Ve()&&He(e),Atomics.compareExchange(r(),e>>2,1,0)}function Ne(e){Ne.shown||(Ne.shown={}),Ne.shown[e]||(Ne.shown[e]=1,b&&(e="warning: "+e),C(e))}function Te(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=Xe(),n=e();return Ye(t),n}((()=>{for(var a=n,i=Ze(8*a),o=i>>3,l=0;l<n;l++){var u=r[2+l];s()[o+l>>>0]=u}return Ge(e,a,i,t)}))}u.invokeEntryPoint=function(e,t){var n=function(e){var t=ve[e];return t||(e>=ve.length&&(ve.length=e+1),ve[e]=t=Y.get(e)),t}(e)(t);ee()?ye.setExitStatus(n):qe(n)},u.executeNotifiedProxyingQueue=Se,we=b?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.timeOrigin+performance.now();var _e=[];function Ce(e){try{return $.grow(e-z.byteLength+65535>>>16),K($.buffer),1}catch(e){}}function Ee(e){return x?Te(4,1,e):52}function $e(e,t,n,r,a){return x?Te(5,1,e,t,n,r,a):70}var Ae=[null,[],[]];function Fe(e,t){var n=Ae[e];0===t||10===t?((1===e?_:C)(j(n,0)),n.length=0):n.push(t)}function Re(e,n,r,s){if(x)return Te(6,1,e,n,r,s);for(var i=0,o=0;o<r;o++){var l=a()[n>>>2],u=a()[n+4>>>2];n+=8;for(var p=0;p<u;p++)Fe(e,t()[l+p>>>0]);i+=u}return a()[s>>>2]=i,0}function De(e){return u["_"+e]}function Me(e,t){($.buffer!=z&&K($.buffer),P).set(e,t>>>0)}function Oe(e,n,r,a,s){var i={string:e=>{var n=0;if(null!=e&&0!==e){var r=1+(e.length<<2);!function(e,n,r){!function(e,t,n,r){if(!(r>0))return 0;n>>>=0;for(var a=n+r-1,s=0;s<e.length;++s){var i=e.charCodeAt(s);if(i>=55296&&i<=57343&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++s)),i<=127){if(n>=a)break;t[n++>>>0]=i}else if(i<=2047){if(n+1>=a)break;t[n++>>>0]=192|i>>6,t[n++>>>0]=128|63&i}else if(i<=65535){if(n+2>=a)break;t[n++>>>0]=224|i>>12,t[n++>>>0]=128|i>>6&63,t[n++>>>0]=128|63&i}else{if(n+3>=a)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63,t[n++>>>0]=128|i>>6&63,t[n++>>>0]=128|63&i}}t[n>>>0]=0}(e,t(),n,r)}(e,n=Ze(r),r)}return n},array:e=>{var t=Ze(e.length);return Me(e,t),t}},o=De(e),l=[],u=0;if(a)for(var p=0;p<a.length;p++){var d=i[r[p]];d?(0===u&&(u=Xe()),l[p]=d(a[p])):l[p]=a[p]}var h,c=o.apply(null,l);return h=c,0!==u&&Ye(u),c=function(e){return"string"===n?q(e):"boolean"===n?!!e:e}(h),c}ye.init();var Le,ze,Pe,Be=[null,me,xe,ke,Ee,$e,Re],We={__emscripten_init_main_thread_js:function(e){Ue(e,!y,1,!g),ye.threadInitTLS()},__emscripten_thread_cleanup:function(e){x?postMessage({cmd:"cleanupThread",thread:e}):ce(e)},__pthread_create_js:Ie,_emscripten_default_pthread_stack_size:function(){return 65536},_emscripten_get_now_is_monotonic:function(){return!0},_emscripten_notify_task_queue:function(e,t,n,r){if(e==t)setTimeout((()=>Se(r)));else if(x)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{var a=ye.pthreads[e];if(!a)return;a.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},_emscripten_set_offscreencanvas_size:function(e,t,n){return-1},abort:function(){se("")},emscripten_check_blocking_allowed:function(){b||y||Ne("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")},emscripten_date_now:function(){return Date.now()},emscripten_get_heap_max:function(){return 4294901760},emscripten_get_now:we,emscripten_memcpy_big:function(e,n,r){t().copyWithin(e>>>0,n>>>0,n+r>>>0)},emscripten_num_logical_cores:function(){return b?M().cpus().length:navigator.hardwareConcurrency},emscripten_receive_on_main_thread_js:function(e,t,n){_e.length=t;for(var r=n>>3,a=0;a<t;a++)_e[a]=s()[r+a>>>0];return(e<0?de[-e-1]:Be[e]).apply(null,_e)},emscripten_resize_heap:function(e){var n=t().length;if((e>>>=0)<=n)return!1;var r,a,s=4294901760;if(e>s)return!1;for(var i=1;i<=4;i*=2){var o=n*(1+.2/i);if(o=Math.min(o,e+100663296),Ce(Math.min(s,(r=Math.max(e,o))+((a=65536)-r%a)%a)))return!0}return!1},emscripten_unwind_to_js_event_loop:function(){throw"unwind"},exit:ge,fd_close:Ee,fd_seek:$e,fd_write:Re,memory:$||u.wasmMemory},Ve=(function(){var e={env:We,wasi_snapshot_preview1:We};function t(e,t){var n=e.exports;if(u.asm=n,function(e){ye.tlsInitFunctions.push(e)}(u.asm._emscripten_tls_init),Y=u.asm.__indirect_function_table,function(e){J.unshift(e)}(u.asm.__wasm_call_ctors),O=t,!x){var r=ye.unusedWorkers.length;ye.unusedWorkers.forEach((function(e){ye.loadWasmModuleToWorker(e,(function(){--r||function(e){if(ne--,u.monitorRunDependencies&&u.monitorRunDependencies(ne),0==ne&&(null!==re&&(clearInterval(re),re=null),ae)){var t=ae;ae=null,t()}}()}))}))}}function n(e){t(e.instance,e.module)}function r(t){return function(){if(!T&&(g||y)){if("function"==typeof fetch&&!ue(ie))return fetch(ie,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+ie+"'";return e.arrayBuffer()})).catch((function(){return pe(ie)}));if(d)return new Promise((function(e,t){d(ie,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return pe(ie)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){C("failed to asynchronously prepare wasm: "+e),se(e)}))}if(x||(ne++,u.monitorRunDependencies&&u.monitorRunDependencies(ne)),u.instantiateWasm)try{return u.instantiateWasm(e,t)}catch(e){C("Module.instantiateWasm callback failed with error: "+e),o(e)}(T||"function"!=typeof WebAssembly.instantiateStreaming||le(ie)||ue(ie)||b||"function"!=typeof fetch?r(n):fetch(ie,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return C("wasm streaming compile failed: "+e),C("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(o)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.__wasm_call_ctors).apply(null,arguments)},u._init=function(){return(u._init=u.asm.init).apply(null,arguments)},u._init_with_threads_count=function(){return(u._init_with_threads_count=u.asm.init_with_threads_count).apply(null,arguments)},u._get_threads_count=function(){return(u._get_threads_count=u.asm.get_threads_count).apply(null,arguments)},u._register_tensor=function(){return(u._register_tensor=u.asm.register_tensor).apply(null,arguments)},u._dispose_data=function(){return(u._dispose_data=u.asm.dispose_data).apply(null,arguments)},u._dispose=function(){return(u._dispose=u.asm.dispose).apply(null,arguments)},u._Abs=function(){return(u._Abs=u.asm.Abs).apply(null,arguments)},u._Acos=function(){return(u._Acos=u.asm.Acos).apply(null,arguments)},u._Acosh=function(){return(u._Acosh=u.asm.Acosh).apply(null,arguments)},u._Add=function(){return(u._Add=u.asm.Add).apply(null,arguments)},u._AddN=function(){return(u._AddN=u.asm.AddN).apply(null,arguments)},u._All=function(){return(u._All=u.asm.All).apply(null,arguments)},u._Any=function(){return(u._Any=u.asm.Any).apply(null,arguments)},u._ArgMax=function(){return(u._ArgMax=u.asm.ArgMax).apply(null,arguments)},u._ArgMin=function(){return(u._ArgMin=u.asm.ArgMin).apply(null,arguments)},u._Asin=function(){return(u._Asin=u.asm.Asin).apply(null,arguments)},u._Asinh=function(){return(u._Asinh=u.asm.Asinh).apply(null,arguments)},u._Atan=function(){return(u._Atan=u.asm.Atan).apply(null,arguments)},u._Atan2=function(){return(u._Atan2=u.asm.Atan2).apply(null,arguments)},u._Atanh=function(){return(u._Atanh=u.asm.Atanh).apply(null,arguments)},u._AvgPool=function(){return(u._AvgPool=u.asm.AvgPool).apply(null,arguments)},u._AvgPool3D=function(){return(u._AvgPool3D=u.asm.AvgPool3D).apply(null,arguments)},u._AvgPool3DGrad=function(){return(u._AvgPool3DGrad=u.asm.AvgPool3DGrad).apply(null,arguments)},u._AvgPoolGrad=function(){return(u._AvgPoolGrad=u.asm.AvgPoolGrad).apply(null,arguments)},u._BatchMatMul=function(){return(u._BatchMatMul=u.asm.BatchMatMul).apply(null,arguments)},u._Bincount=function(){return(u._Bincount=u.asm.Bincount).apply(null,arguments)},u._BitwiseAnd=function(){return(u._BitwiseAnd=u.asm.BitwiseAnd).apply(null,arguments)},u._Ceil=function(){return(u._Ceil=u.asm.Ceil).apply(null,arguments)},u._ClipByValue=function(){return(u._ClipByValue=u.asm.ClipByValue).apply(null,arguments)},u._Conv2D=function(){return(u._Conv2D=u.asm.Conv2D).apply(null,arguments)},u._Conv2DBackpropInput=function(){return(u._Conv2DBackpropInput=u.asm.Conv2DBackpropInput).apply(null,arguments)},u._Conv3D=function(){return(u._Conv3D=u.asm.Conv3D).apply(null,arguments)},u._Conv3DBackpropFilterV2=function(){return(u._Conv3DBackpropFilterV2=u.asm.Conv3DBackpropFilterV2).apply(null,arguments)},u._Conv3DBackpropInputV2=function(){return(u._Conv3DBackpropInputV2=u.asm.Conv3DBackpropInputV2).apply(null,arguments)},u._Cos=function(){return(u._Cos=u.asm.Cos).apply(null,arguments)},u._Cosh=function(){return(u._Cosh=u.asm.Cosh).apply(null,arguments)},u._CropAndResize=function(){return(u._CropAndResize=u.asm.CropAndResize).apply(null,arguments)},u._Cumprod=function(){return(u._Cumprod=u.asm.Cumprod).apply(null,arguments)},u._Cumsum=function(){return(u._Cumsum=u.asm.Cumsum).apply(null,arguments)},u._DenseBincount=function(){return(u._DenseBincount=u.asm.DenseBincount).apply(null,arguments)},u._DepthToSpace=function(){return(u._DepthToSpace=u.asm.DepthToSpace).apply(null,arguments)},u._DepthwiseConv2dNative=function(){return(u._DepthwiseConv2dNative=u.asm.DepthwiseConv2dNative).apply(null,arguments)},u._Diag=function(){return(u._Diag=u.asm.Diag).apply(null,arguments)},u._Dilation2D=function(){return(u._Dilation2D=u.asm.Dilation2D).apply(null,arguments)},u._Dilation2DBackpropFilter=function(){return(u._Dilation2DBackpropFilter=u.asm.Dilation2DBackpropFilter).apply(null,arguments)},u._Dilation2DBackpropInput=function(){return(u._Dilation2DBackpropInput=u.asm.Dilation2DBackpropInput).apply(null,arguments)},u._Elu=function(){return(u._Elu=u.asm.Elu).apply(null,arguments)},u._EluGrad=function(){return(u._EluGrad=u.asm.EluGrad).apply(null,arguments)},u._Equal=function(){return(u._Equal=u.asm.Equal).apply(null,arguments)},u._Erf=function(){return(u._Erf=u.asm.Erf).apply(null,arguments)},u._Exp=function(){return(u._Exp=u.asm.Exp).apply(null,arguments)},u._Expm1=function(){return(u._Expm1=u.asm.Expm1).apply(null,arguments)},u._FlipLeftRight=function(){return(u._FlipLeftRight=u.asm.FlipLeftRight).apply(null,arguments)},u._Floor=function(){return(u._Floor=u.asm.Floor).apply(null,arguments)},u._FloorDiv=function(){return(u._FloorDiv=u.asm.FloorDiv).apply(null,arguments)},u._FusedBatchNorm=function(){return(u._FusedBatchNorm=u.asm.FusedBatchNorm).apply(null,arguments)},u._FusedConv2D=function(){return(u._FusedConv2D=u.asm.FusedConv2D).apply(null,arguments)},u._FusedDepthwiseConv2D=function(){return(u._FusedDepthwiseConv2D=u.asm.FusedDepthwiseConv2D).apply(null,arguments)},u._Gather=function(){return(u._Gather=u.asm.Gather).apply(null,arguments)},u._GatherNd=function(){return(u._GatherNd=u.asm.GatherNd).apply(null,arguments)},u._Greater=function(){return(u._Greater=u.asm.Greater).apply(null,arguments)},u._GreaterEqual=function(){return(u._GreaterEqual=u.asm.GreaterEqual).apply(null,arguments)},u._IsFinite=function(){return(u._IsFinite=u.asm.IsFinite).apply(null,arguments)},u._IsInf=function(){return(u._IsInf=u.asm.IsInf).apply(null,arguments)},u._IsNan=function(){return(u._IsNan=u.asm.IsNan).apply(null,arguments)},u._LRN=function(){return(u._LRN=u.asm.LRN).apply(null,arguments)},u._LRNGrad=function(){return(u._LRNGrad=u.asm.LRNGrad).apply(null,arguments)},u._LeakyRelu=function(){return(u._LeakyRelu=u.asm.LeakyRelu).apply(null,arguments)},u._Less=function(){return(u._Less=u.asm.Less).apply(null,arguments)},u._LessEqual=function(){return(u._LessEqual=u.asm.LessEqual).apply(null,arguments)},u._LinSpace=function(){return(u._LinSpace=u.asm.LinSpace).apply(null,arguments)},u._Log=function(){return(u._Log=u.asm.Log).apply(null,arguments)},u._Log1p=function(){return(u._Log1p=u.asm.Log1p).apply(null,arguments)},u._LogicalAnd=function(){return(u._LogicalAnd=u.asm.LogicalAnd).apply(null,arguments)},u._LogicalNot=function(){return(u._LogicalNot=u.asm.LogicalNot).apply(null,arguments)},u._LogicalOr=function(){return(u._LogicalOr=u.asm.LogicalOr).apply(null,arguments)},u._LogicalXor=function(){return(u._LogicalXor=u.asm.LogicalXor).apply(null,arguments)},u._Max=function(){return(u._Max=u.asm.Max).apply(null,arguments)},u._MaxPool=function(){return(u._MaxPool=u.asm.MaxPool).apply(null,arguments)},u._MaxPool3D=function(){return(u._MaxPool3D=u.asm.MaxPool3D).apply(null,arguments)},u._MaxPool3DGrad=function(){return(u._MaxPool3DGrad=u.asm.MaxPool3DGrad).apply(null,arguments)},u._MaxPoolGrad=function(){return(u._MaxPoolGrad=u.asm.MaxPoolGrad).apply(null,arguments)},u._MaxPoolWithArgmax=function(){return(u._MaxPoolWithArgmax=u.asm.MaxPoolWithArgmax).apply(null,arguments)},u._Maximum=function(){return(u._Maximum=u.asm.Maximum).apply(null,arguments)},u._Mean=function(){return(u._Mean=u.asm.Mean).apply(null,arguments)},u._Min=function(){return(u._Min=u.asm.Min).apply(null,arguments)},u._Minimum=function(){return(u._Minimum=u.asm.Minimum).apply(null,arguments)},u._MirrorPad=function(){return(u._MirrorPad=u.asm.MirrorPad).apply(null,arguments)},u._Mod=function(){return(u._Mod=u.asm.Mod).apply(null,arguments)},u._Multinomial=function(){return(u._Multinomial=u.asm.Multinomial).apply(null,arguments)},u._Multiply=function(){return(u._Multiply=u.asm.Multiply).apply(null,arguments)},u._Neg=function(){return(u._Neg=u.asm.Neg).apply(null,arguments)},u._NonMaxSuppressionV3=function(){return(u._NonMaxSuppressionV3=u.asm.NonMaxSuppressionV3).apply(null,arguments)},u._NonMaxSuppressionV4=function(){return(u._NonMaxSuppressionV4=u.asm.NonMaxSuppressionV4).apply(null,arguments)},u._NonMaxSuppressionV5=function(){return(u._NonMaxSuppressionV5=u.asm.NonMaxSuppressionV5).apply(null,arguments)},u._NotEqual=function(){return(u._NotEqual=u.asm.NotEqual).apply(null,arguments)},u._OneHot=function(){return(u._OneHot=u.asm.OneHot).apply(null,arguments)},u._PadV2=function(){return(u._PadV2=u.asm.PadV2).apply(null,arguments)},u._Pow=function(){return(u._Pow=u.asm.Pow).apply(null,arguments)},u._Prelu=function(){return(u._Prelu=u.asm.Prelu).apply(null,arguments)},u._Prod=function(){return(u._Prod=u.asm.Prod).apply(null,arguments)},u._RealDiv=function(){return(u._RealDiv=u.asm.RealDiv).apply(null,arguments)},u._Reciprocal=function(){return(u._Reciprocal=u.asm.Reciprocal).apply(null,arguments)},u._Relu=function(){return(u._Relu=u.asm.Relu).apply(null,arguments)},u._Relu6=function(){return(u._Relu6=u.asm.Relu6).apply(null,arguments)},u._ResizeBilinear=function(){return(u._ResizeBilinear=u.asm.ResizeBilinear).apply(null,arguments)},u._ResizeBilinearGrad=function(){return(u._ResizeBilinearGrad=u.asm.ResizeBilinearGrad).apply(null,arguments)},u._ResizeNearestNeighbor=function(){return(u._ResizeNearestNeighbor=u.asm.ResizeNearestNeighbor).apply(null,arguments)},u._ResizeNearestNeighborGrad=function(){return(u._ResizeNearestNeighborGrad=u.asm.ResizeNearestNeighborGrad).apply(null,arguments)},u._Reverse=function(){return(u._Reverse=u.asm.Reverse).apply(null,arguments)},u._RotateWithOffset=function(){return(u._RotateWithOffset=u.asm.RotateWithOffset).apply(null,arguments)},u._Round=function(){return(u._Round=u.asm.Round).apply(null,arguments)},u._Rsqrt=function(){return(u._Rsqrt=u.asm.Rsqrt).apply(null,arguments)},u._ScatterNd=function(){return(u._ScatterNd=u.asm.ScatterNd).apply(null,arguments)},u._SearchSorted=function(){return(u._SearchSorted=u.asm.SearchSorted).apply(null,arguments)},u._SelectV2=function(){return(u._SelectV2=u.asm.SelectV2).apply(null,arguments)},u._Selu=function(){return(u._Selu=u.asm.Selu).apply(null,arguments)},u._Sigmoid=function(){return(u._Sigmoid=u.asm.Sigmoid).apply(null,arguments)},u._Sign=function(){return(u._Sign=u.asm.Sign).apply(null,arguments)},u._Sin=function(){return(u._Sin=u.asm.Sin).apply(null,arguments)},u._Sinh=function(){return(u._Sinh=u.asm.Sinh).apply(null,arguments)},u._Softmax=function(){return(u._Softmax=u.asm.Softmax).apply(null,arguments)},u._Softplus=function(){return(u._Softplus=u.asm.Softplus).apply(null,arguments)},u._SparseFillEmptyRows=function(){return(u._SparseFillEmptyRows=u.asm.SparseFillEmptyRows).apply(null,arguments)},u._SparseReshape=function(){return(u._SparseReshape=u.asm.SparseReshape).apply(null,arguments)},u._SparseSegmentReduction=function(){return(u._SparseSegmentReduction=u.asm.SparseSegmentReduction).apply(null,arguments)},u._SparseToDense=function(){return(u._SparseToDense=u.asm.SparseToDense).apply(null,arguments)},u._Sqrt=function(){return(u._Sqrt=u.asm.Sqrt).apply(null,arguments)},u._Square=function(){return(u._Square=u.asm.Square).apply(null,arguments)},u._SquaredDifference=function(){return(u._SquaredDifference=u.asm.SquaredDifference).apply(null,arguments)},u._Step=function(){return(u._Step=u.asm.Step).apply(null,arguments)},u._StridedSlice=function(){return(u._StridedSlice=u.asm.StridedSlice).apply(null,arguments)},u._Sub=function(){return(u._Sub=u.asm.Sub).apply(null,arguments)},u._Sum=function(){return(u._Sum=u.asm.Sum).apply(null,arguments)},u._Tan=function(){return(u._Tan=u.asm.Tan).apply(null,arguments)},u._Tanh=function(){return(u._Tanh=u.asm.Tanh).apply(null,arguments)},u._TensorScatterUpdate=function(){return(u._TensorScatterUpdate=u.asm.TensorScatterUpdate).apply(null,arguments)},u._Tile=function(){return(u._Tile=u.asm.Tile).apply(null,arguments)},u._TopK=function(){return(u._TopK=u.asm.TopK).apply(null,arguments)},u._Transform=function(){return(u._Transform=u.asm.Transform).apply(null,arguments)},u._Transpose=function(){return(u._Transpose=u.asm.Transpose).apply(null,arguments)},u.__FusedMatMul=function(){return(u.__FusedMatMul=u.asm._FusedMatMul).apply(null,arguments)},u._malloc=function(){return(u._malloc=u.asm.malloc).apply(null,arguments)},u._free=function(){return(u._free=u.asm.free).apply(null,arguments)},u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm._emscripten_tls_init).apply(null,arguments)},u._pthread_self=function(){return(Ve=u._pthread_self=u.asm.pthread_self).apply(null,arguments)}),Ue=(u.___errno_location=function(){return(u.___errno_location=u.asm.__errno_location).apply(null,arguments)},u.__emscripten_thread_init=function(){return(Ue=u.__emscripten_thread_init=u.asm._emscripten_thread_init).apply(null,arguments)}),Ge=(u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm._emscripten_thread_crashed).apply(null,arguments)},u._emscripten_main_thread_process_queued_calls=function(){return(u._emscripten_main_thread_process_queued_calls=u.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},u._emscripten_main_browser_thread_id=function(){return(u._emscripten_main_browser_thread_id=u.asm.emscripten_main_browser_thread_id).apply(null,arguments)},u._emscripten_run_in_main_runtime_thread_js=function(){return(Ge=u._emscripten_run_in_main_runtime_thread_js=u.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)}),He=(u._emscripten_dispatch_to_thread_=function(){return(u._emscripten_dispatch_to_thread_=u.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},u.__emscripten_proxy_execute_task_queue=function(){return(He=u.__emscripten_proxy_execute_task_queue=u.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)}),je=u.__emscripten_thread_free_data=function(){return(je=u.__emscripten_thread_free_data=u.asm._emscripten_thread_free_data).apply(null,arguments)},qe=u.__emscripten_thread_exit=function(){return(qe=u.__emscripten_thread_exit=u.asm._emscripten_thread_exit).apply(null,arguments)},Ke=u._emscripten_stack_set_limits=function(){return(Ke=u._emscripten_stack_set_limits=u.asm.emscripten_stack_set_limits).apply(null,arguments)},Xe=u.stackSave=function(){return(Xe=u.stackSave=u.asm.stackSave).apply(null,arguments)},Ye=u.stackRestore=function(){return(Ye=u.stackRestore=u.asm.stackRestore).apply(null,arguments)},Ze=u.stackAlloc=function(){return(Ze=u.stackAlloc=u.asm.stackAlloc).apply(null,arguments)};function Je(e){if(e=e||f,!(ne>0)){if(x)return i(u),te(),void startWorker(u);(function(){if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)e=u.preRun.shift(),Z.unshift(e);var e;be(Z)})(),ne>0||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}function t(){Le||(Le=!0,u.calledRun=!0,!G&&(te(),i(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),function(){if(!x){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;)e=u.postRun.shift(),Q.unshift(e);be(Q)}var e}()))}}if(u.dynCall_iijjiiii=function(){return(u.dynCall_iijjiiii=u.asm.dynCall_iijjiiii).apply(null,arguments)},u.dynCall_jiji=function(){return(u.dynCall_jiji=u.asm.dynCall_jiji).apply(null,arguments)},u.keepRuntimeAlive=ee,u.wasmMemory=$,u.cwrap=function(e,t,n,r){var a=(n=n||[]).every((e=>"number"===e||"boolean"===e));return"string"!==t&&a&&!r?De(e):function(){return Oe(e,t,n,arguments)}},u.ExitStatus=he,u.PThread=ye,ae=function e(){Le||Je(),Le||(ae=e)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);u.preInit.length>0;)u.preInit.pop()();if(Je(),l&&(ze={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!l.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!l.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof WasmBackendModule)Pe=WasmBackendModule;else{if(void 0===e)throw new Error("Could not find wasm module in post.js");Pe=e}if(ze){var Qe=Pe._dispose;Pe._dispose=function(){Qe(),ze.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),ze.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return e.ready});"object"==typeof e&&"object"==typeof t?t.exports=r:"function"==typeof define&&define.amd?define([],(function(){return r})):"object"==typeof e&&(e.WasmBackendModuleThreadedSimd=r)})),L=m(((e,t)=>{t.exports.wasmWorkerContents='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};'})),z=m(((e,t)=>{var n,r=(n="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(n=n||__filename),function(e){var t,r,a,s=void 0!==(e=e||{})?e:{};s.ready=new Promise((function(e,n){t=e,r=n})),"undefined"!=typeof process&&process.listeners&&(a={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var i,o,l,u=Object.assign({},s),p=[],d="object"==typeof window,h="function"==typeof importScripts,c="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,f="";if(c){var m=A(),g=F();f=h?g.dirname(f)+"/":__dirname+"/",i=(e,t)=>(e=U(e)?new URL(e):g.normalize(e),m.readFileSync(e,t?void 0:"utf8")),l=e=>{var t=i(e,!0);return t.buffer||(t=new Uint8Array(t)),t},o=(e,t,n)=>{e=U(e)?new URL(e):g.normalize(e),m.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),p=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof H))throw e})),process.on("unhandledRejection",(function(e){throw e})),s.inspect=function(){return"[Emscripten Module object]"}}else(d||h)&&(h?f=self.location.href:"undefined"!=typeof document&&document.currentScript&&(f=document.currentScript.src),n&&(f=n),f=0!==f.indexOf("blob:")?f.substr(0,f.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},h&&(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),o=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var y,b=s.print||console.log.bind(console),x=s.printErr||console.warn.bind(console);Object.assign(s,u),u=null,s.arguments&&(p=s.arguments),s.thisProgram&&s.thisProgram,s.quit&&s.quit,s.wasmBinary&&(y=s.wasmBinary);s.noExitRuntime;"object"!=typeof WebAssembly&&z("no native wasm support detected");var w,v,k,I,S,N=!1,T="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function _(e,t,n){for(var r=(t>>>=0)+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.buffer&&T)return T.decode(e.subarray(t,a));for(var s="";t<a;){var i=e[t++];if(128&i){var o=63&e[t++];if(192!=(224&i)){var l=63&e[t++];if((i=224==(240&i)?(15&i)<<12|o<<6|l:(7&i)<<18|o<<12|l<<6|63&e[t++])<65536)s+=String.fromCharCode(i);else{var u=i-65536;s+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else s+=String.fromCharCode((31&i)<<6|o)}else s+=String.fromCharCode(i)}return s}function C(e,t){return(e>>>=0)?_(I,e,t):""}function E(e){v=e,s.HEAP8=k=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=new Int32Array(e),s.HEAPU8=I=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=S=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=new Float64Array(e)}s.INITIAL_MEMORY;var $=[],R=[],D=[],M=0,O=null,L=null;function z(e){s.onAbort&&s.onAbort(e),x(e="Aborted("+e+")"),N=!0,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw r(t),t}var P,B,W="data:application/octet-stream;base64,";function V(e){return e.startsWith(W)}function U(e){return e.startsWith("file://")}function G(e){try{if(e==P&&y)return new Uint8Array(y);if(l)return l(e);throw"both async and sync fetching of the wasm failed"}catch(e){z(e)}}function H(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function j(e){for(;e.length>0;)e.shift()(s)}function q(e){try{return w.grow(e-v.byteLength+65535>>>16),E(w.buffer),1}catch(e){}}V(P="tfjs-backend-wasm.wasm")||(B=P,P=s.locateFile?s.locateFile(B,f):f+B);var K=[null,[],[]];function X(e,t){var n=K[e];0===t||10===t?((1===e?b:x)(_(n,0)),n.length=0):n.push(t)}function Y(e){return s["_"+e]}function Z(e,t,n,r,a){var s={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);!function(e,t,n){!function(e,t,n,r){if(!(r>0))return 0;n>>>=0;for(var a=n+r-1,s=0;s<e.length;++s){var i=e.charCodeAt(s);if(i>=55296&&i<=57343&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++s)),i<=127){if(n>=a)break;t[n++>>>0]=i}else if(i<=2047){if(n+1>=a)break;t[n++>>>0]=192|i>>6,t[n++>>>0]=128|63&i}else if(i<=65535){if(n+2>=a)break;t[n++>>>0]=224|i>>12,t[n++>>>0]=128|i>>6&63,t[n++>>>0]=128|63&i}else{if(n+3>=a)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63,t[n++>>>0]=128|i>>6&63,t[n++>>>0]=128|63&i}}t[n>>>0]=0}(e,I,t,n)}(e,t=ae(n),n)}return t},array:e=>{var t=ae(e.length);return function(e,t){k.set(e,t>>>0)}(e,t),t}},i=Y(e),o=[],l=0;if(r)for(var u=0;u<r.length;u++){var p=s[n[u]];p?(0===l&&(l=ne()),o[u]=p(r[u])):o[u]=r[u]}var d,h=i.apply(null,o);return d=h,0!==l&&re(l),h=function(e){return"string"===t?C(e):"boolean"===t?!!e:e}(d),h}var J,Q,ee,te={abort:function(){z("")},emscripten_get_heap_max:function(){return 4294901760},emscripten_memcpy_big:function(e,t,n){I.copyWithin(e>>>0,t>>>0,t+n>>>0)},emscripten_resize_heap:function(e){var t,n,r=I.length,a=4294901760;if((e>>>=0)>a)return!1;for(var s=1;s<=4;s*=2){var i=r*(1+.2/s);if(i=Math.min(i,e+100663296),q(Math.min(a,(t=Math.max(e,i))+((n=65536)-t%n)%n)))return!0}return!1},fd_close:function(e){return 52},fd_seek:function(e,t,n,r,a){return 70},fd_write:function(e,t,n,r){for(var a=0,s=0;s<n;s++){var i=S[t>>>2],o=S[t+4>>>2];t+=8;for(var l=0;l<o;l++)X(e,I[i+l>>>0]);a+=o}return S[r>>>2]=a,0}},ne=(function(){var e={env:te,wasi_snapshot_preview1:te};function t(e,t){var n=e.exports;s.asm=n,E((w=s.asm.memory).buffer),s.asm.__indirect_function_table,function(e){R.unshift(e)}(s.asm.__wasm_call_ctors),function(e){if(M--,s.monitorRunDependencies&&s.monitorRunDependencies(M),0==M&&(null!==O&&(clearInterval(O),O=null),L)){var t=L;L=null,t()}}()}function n(e){t(e.instance)}function a(t){return function(){if(!y&&(d||h)){if("function"==typeof fetch&&!U(P))return fetch(P,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+P+"'";return e.arrayBuffer()})).catch((function(){return G(P)}));if(o)return new Promise((function(e,t){o(P,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return G(P)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){x("failed to asynchronously prepare wasm: "+e),z(e)}))}if(M++,s.monitorRunDependencies&&s.monitorRunDependencies(M),s.instantiateWasm)try{return s.instantiateWasm(e,t)}catch(e){x("Module.instantiateWasm callback failed with error: "+e),r(e)}(y||"function"!=typeof WebAssembly.instantiateStreaming||V(P)||U(P)||c||"function"!=typeof fetch?a(n):fetch(P,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return x("wasm streaming compile failed: "+e),x("falling back to ArrayBuffer instantiation"),a(n)}))}))).catch(r)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},s._init=function(){return(s._init=s.asm.init).apply(null,arguments)},s._init_with_threads_count=function(){return(s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},s._get_threads_count=function(){return(s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},s._register_tensor=function(){return(s._register_tensor=s.asm.register_tensor).apply(null,arguments)},s._dispose_data=function(){return(s._dispose_data=s.asm.dispose_data).apply(null,arguments)},s._dispose=function(){return(s._dispose=s.asm.dispose).apply(null,arguments)},s._Abs=function(){return(s._Abs=s.asm.Abs).apply(null,arguments)},s._Acos=function(){return(s._Acos=s.asm.Acos).apply(null,arguments)},s._Acosh=function(){return(s._Acosh=s.asm.Acosh).apply(null,arguments)},s._Add=function(){return(s._Add=s.asm.Add).apply(null,arguments)},s._AddN=function(){return(s._AddN=s.asm.AddN).apply(null,arguments)},s._All=function(){return(s._All=s.asm.All).apply(null,arguments)},s._Any=function(){return(s._Any=s.asm.Any).apply(null,arguments)},s._ArgMax=function(){return(s._ArgMax=s.asm.ArgMax).apply(null,arguments)},s._ArgMin=function(){return(s._ArgMin=s.asm.ArgMin).apply(null,arguments)},s._Asin=function(){return(s._Asin=s.asm.Asin).apply(null,arguments)},s._Asinh=function(){return(s._Asinh=s.asm.Asinh).apply(null,arguments)},s._Atan=function(){return(s._Atan=s.asm.Atan).apply(null,arguments)},s._Atan2=function(){return(s._Atan2=s.asm.Atan2).apply(null,arguments)},s._Atanh=function(){return(s._Atanh=s.asm.Atanh).apply(null,arguments)},s._AvgPool=function(){return(s._AvgPool=s.asm.AvgPool).apply(null,arguments)},s._AvgPool3D=function(){return(s._AvgPool3D=s.asm.AvgPool3D).apply(null,arguments)},s._AvgPool3DGrad=function(){return(s._AvgPool3DGrad=s.asm.AvgPool3DGrad).apply(null,arguments)},s._AvgPoolGrad=function(){return(s._AvgPoolGrad=s.asm.AvgPoolGrad).apply(null,arguments)},s._BatchMatMul=function(){return(s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},s._Bincount=function(){return(s._Bincount=s.asm.Bincount).apply(null,arguments)},s._BitwiseAnd=function(){return(s._BitwiseAnd=s.asm.BitwiseAnd).apply(null,arguments)},s._Ceil=function(){return(s._Ceil=s.asm.Ceil).apply(null,arguments)},s._ClipByValue=function(){return(s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},s._Conv2D=function(){return(s._Conv2D=s.asm.Conv2D).apply(null,arguments)},s._Conv2DBackpropInput=function(){return(s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},s._Conv3D=function(){return(s._Conv3D=s.asm.Conv3D).apply(null,arguments)},s._Conv3DBackpropFilterV2=function(){return(s._Conv3DBackpropFilterV2=s.asm.Conv3DBackpropFilterV2).apply(null,arguments)},s._Conv3DBackpropInputV2=function(){return(s._Conv3DBackpropInputV2=s.asm.Conv3DBackpropInputV2).apply(null,arguments)},s._Cos=function(){return(s._Cos=s.asm.Cos).apply(null,arguments)},s._Cosh=function(){return(s._Cosh=s.asm.Cosh).apply(null,arguments)},s._CropAndResize=function(){return(s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},s._Cumprod=function(){return(s._Cumprod=s.asm.Cumprod).apply(null,arguments)},s._Cumsum=function(){return(s._Cumsum=s.asm.Cumsum).apply(null,arguments)},s._DenseBincount=function(){return(s._DenseBincount=s.asm.DenseBincount).apply(null,arguments)},s._DepthToSpace=function(){return(s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},s._DepthwiseConv2dNative=function(){return(s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},s._Diag=function(){return(s._Diag=s.asm.Diag).apply(null,arguments)},s._Dilation2D=function(){return(s._Dilation2D=s.asm.Dilation2D).apply(null,arguments)},s._Dilation2DBackpropFilter=function(){return(s._Dilation2DBackpropFilter=s.asm.Dilation2DBackpropFilter).apply(null,arguments)},s._Dilation2DBackpropInput=function(){return(s._Dilation2DBackpropInput=s.asm.Dilation2DBackpropInput).apply(null,arguments)},s._Elu=function(){return(s._Elu=s.asm.Elu).apply(null,arguments)},s._EluGrad=function(){return(s._EluGrad=s.asm.EluGrad).apply(null,arguments)},s._Equal=function(){return(s._Equal=s.asm.Equal).apply(null,arguments)},s._Erf=function(){return(s._Erf=s.asm.Erf).apply(null,arguments)},s._Exp=function(){return(s._Exp=s.asm.Exp).apply(null,arguments)},s._Expm1=function(){return(s._Expm1=s.asm.Expm1).apply(null,arguments)},s._FlipLeftRight=function(){return(s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},s._Floor=function(){return(s._Floor=s.asm.Floor).apply(null,arguments)},s._FloorDiv=function(){return(s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},s._FusedBatchNorm=function(){return(s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},s._FusedConv2D=function(){return(s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},s._FusedDepthwiseConv2D=function(){return(s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},s._Gather=function(){return(s._Gather=s.asm.Gather).apply(null,arguments)},s._GatherNd=function(){return(s._GatherNd=s.asm.GatherNd).apply(null,arguments)},s._Greater=function(){return(s._Greater=s.asm.Greater).apply(null,arguments)},s._GreaterEqual=function(){return(s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},s._IsFinite=function(){return(s._IsFinite=s.asm.IsFinite).apply(null,arguments)},s._IsInf=function(){return(s._IsInf=s.asm.IsInf).apply(null,arguments)},s._IsNan=function(){return(s._IsNan=s.asm.IsNan).apply(null,arguments)},s._LRN=function(){return(s._LRN=s.asm.LRN).apply(null,arguments)},s._LRNGrad=function(){return(s._LRNGrad=s.asm.LRNGrad).apply(null,arguments)},s._LeakyRelu=function(){return(s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},s._Less=function(){return(s._Less=s.asm.Less).apply(null,arguments)},s._LessEqual=function(){return(s._LessEqual=s.asm.LessEqual).apply(null,arguments)},s._LinSpace=function(){return(s._LinSpace=s.asm.LinSpace).apply(null,arguments)},s._Log=function(){return(s._Log=s.asm.Log).apply(null,arguments)},s._Log1p=function(){return(s._Log1p=s.asm.Log1p).apply(null,arguments)},s._LogicalAnd=function(){return(s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},s._LogicalNot=function(){return(s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},s._LogicalOr=function(){return(s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},s._LogicalXor=function(){return(s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},s._Max=function(){return(s._Max=s.asm.Max).apply(null,arguments)},s._MaxPool=function(){return(s._MaxPool=s.asm.MaxPool).apply(null,arguments)},s._MaxPool3D=function(){return(s._MaxPool3D=s.asm.MaxPool3D).apply(null,arguments)},s._MaxPool3DGrad=function(){return(s._MaxPool3DGrad=s.asm.MaxPool3DGrad).apply(null,arguments)},s._MaxPoolGrad=function(){return(s._MaxPoolGrad=s.asm.MaxPoolGrad).apply(null,arguments)},s._MaxPoolWithArgmax=function(){return(s._MaxPoolWithArgmax=s.asm.MaxPoolWithArgmax).apply(null,arguments)},s._Maximum=function(){return(s._Maximum=s.asm.Maximum).apply(null,arguments)},s._Mean=function(){return(s._Mean=s.asm.Mean).apply(null,arguments)},s._Min=function(){return(s._Min=s.asm.Min).apply(null,arguments)},s._Minimum=function(){return(s._Minimum=s.asm.Minimum).apply(null,arguments)},s._MirrorPad=function(){return(s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},s._Mod=function(){return(s._Mod=s.asm.Mod).apply(null,arguments)},s._Multinomial=function(){return(s._Multinomial=s.asm.Multinomial).apply(null,arguments)},s._Multiply=function(){return(s._Multiply=s.asm.Multiply).apply(null,arguments)},s._Neg=function(){return(s._Neg=s.asm.Neg).apply(null,arguments)},s._NonMaxSuppressionV3=function(){return(s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},s._NonMaxSuppressionV4=function(){return(s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},s._NonMaxSuppressionV5=function(){return(s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},s._NotEqual=function(){return(s._NotEqual=s.asm.NotEqual).apply(null,arguments)},s._OneHot=function(){return(s._OneHot=s.asm.OneHot).apply(null,arguments)},s._PadV2=function(){return(s._PadV2=s.asm.PadV2).apply(null,arguments)},s._Pow=function(){return(s._Pow=s.asm.Pow).apply(null,arguments)},s._Prelu=function(){return(s._Prelu=s.asm.Prelu).apply(null,arguments)},s._Prod=function(){return(s._Prod=s.asm.Prod).apply(null,arguments)},s._RealDiv=function(){return(s._RealDiv=s.asm.RealDiv).apply(null,arguments)},s._Reciprocal=function(){return(s._Reciprocal=s.asm.Reciprocal).apply(null,arguments)},s._Relu=function(){return(s._Relu=s.asm.Relu).apply(null,arguments)},s._Relu6=function(){return(s._Relu6=s.asm.Relu6).apply(null,arguments)},s._ResizeBilinear=function(){return(s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},s._ResizeBilinearGrad=function(){return(s._ResizeBilinearGrad=s.asm.ResizeBilinearGrad).apply(null,arguments)},s._ResizeNearestNeighbor=function(){return(s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},s._ResizeNearestNeighborGrad=function(){return(s._ResizeNearestNeighborGrad=s.asm.ResizeNearestNeighborGrad).apply(null,arguments)},s._Reverse=function(){return(s._Reverse=s.asm.Reverse).apply(null,arguments)},s._RotateWithOffset=function(){return(s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},s._Round=function(){return(s._Round=s.asm.Round).apply(null,arguments)},s._Rsqrt=function(){return(s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},s._ScatterNd=function(){return(s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},s._SearchSorted=function(){return(s._SearchSorted=s.asm.SearchSorted).apply(null,arguments)},s._SelectV2=function(){return(s._SelectV2=s.asm.SelectV2).apply(null,arguments)},s._Selu=function(){return(s._Selu=s.asm.Selu).apply(null,arguments)},s._Sigmoid=function(){return(s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},s._Sign=function(){return(s._Sign=s.asm.Sign).apply(null,arguments)},s._Sin=function(){return(s._Sin=s.asm.Sin).apply(null,arguments)},s._Sinh=function(){return(s._Sinh=s.asm.Sinh).apply(null,arguments)},s._Softmax=function(){return(s._Softmax=s.asm.Softmax).apply(null,arguments)},s._Softplus=function(){return(s._Softplus=s.asm.Softplus).apply(null,arguments)},s._SparseFillEmptyRows=function(){return(s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},s._SparseReshape=function(){return(s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},s._SparseSegmentReduction=function(){return(s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},s._SparseToDense=function(){return(s._SparseToDense=s.asm.SparseToDense).apply(null,arguments)},s._Sqrt=function(){return(s._Sqrt=s.asm.Sqrt).apply(null,arguments)},s._Square=function(){return(s._Square=s.asm.Square).apply(null,arguments)},s._SquaredDifference=function(){return(s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},s._Step=function(){return(s._Step=s.asm.Step).apply(null,arguments)},s._StridedSlice=function(){return(s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},s._Sub=function(){return(s._Sub=s.asm.Sub).apply(null,arguments)},s._Sum=function(){return(s._Sum=s.asm.Sum).apply(null,arguments)},s._Tan=function(){return(s._Tan=s.asm.Tan).apply(null,arguments)},s._Tanh=function(){return(s._Tanh=s.asm.Tanh).apply(null,arguments)},s._TensorScatterUpdate=function(){return(s._TensorScatterUpdate=s.asm.TensorScatterUpdate).apply(null,arguments)},s._Tile=function(){return(s._Tile=s.asm.Tile).apply(null,arguments)},s._TopK=function(){return(s._TopK=s.asm.TopK).apply(null,arguments)},s._Transform=function(){return(s._Transform=s.asm.Transform).apply(null,arguments)},s._Transpose=function(){return(s._Transpose=s.asm.Transpose).apply(null,arguments)},s.__FusedMatMul=function(){return(s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},s._malloc=function(){return(s._malloc=s.asm.malloc).apply(null,arguments)},s._free=function(){return(s._free=s.asm.free).apply(null,arguments)},s.___errno_location=function(){return(s.___errno_location=s.asm.__errno_location).apply(null,arguments)},s.stackSave=function(){return(ne=s.stackSave=s.asm.stackSave).apply(null,arguments)}),re=s.stackRestore=function(){return(re=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},ae=s.stackAlloc=function(){return(ae=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)};function se(e){function n(){J||(J=!0,s.calledRun=!0,!N&&(j(R),t(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),function(){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;)e=s.postRun.shift(),D.unshift(e);var e;j(D)}()))}e=e||p,M>0||(function(){if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)e=s.preRun.shift(),$.unshift(e);var e;j($)}(),M>0)||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),n()}),1)):n())}if(s.dynCall_iijjiiii=function(){return(s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},s.dynCall_jiji=function(){return(s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)},s.cwrap=function(e,t,n,r){var a=(n=n||[]).every((e=>"number"===e||"boolean"===e));return"string"!==t&&a&&!r?Y(e):function(){return Z(e,t,n,arguments)}},L=function e(){J||se(),J||(L=e)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();if(se(),a&&(Q={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!a.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!a.unhandledRejection.indexOf(e)>-1}))}),void 0!==e)ee=e;else{if("undefined"==typeof WasmBackendModuleThreadedSimd)throw new Error("Could not find wasm module in post.js");ee=WasmBackendModuleThreadedSimd}if(Q){var ie=ee._dispose;ee._dispose=function(){ie(),Q.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),Q.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return e.ready});"object"==typeof e&&"object"==typeof t?t.exports=r:"function"==typeof define&&define.amd?define([],(function(){return r})):"object"==typeof e&&(e.WasmBackendModule=r)})),P=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},B=class{refCount(e){return W("refCount")}incRef(e){return W("incRef")}timerAvailable(){return!0}time(e){return W("time")}read(e){return W("read")}readSync(e){return W("readSync")}readToGPU(e,t){return W("readToGPU")}numDataIds(){return W("numDataIds")}disposeData(e,t){return W("disposeData")}write(e,t,n){return W("write")}move(e,t,n,r,a){return W("move")}createTensorFromGPUData(e,t,n){return W("createTensorFromGPUData")}memory(){return W("memory")}floatPrecision(){return W("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return W("dispose")}};function W(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function V(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,j(e,t,n)}function U(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,j(e,n,r),j(t,n,r)}function G(e,t,n){return Math.max(e,Math.min(t,n))}function H(e){return e%2==0?e:e+1}function j(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function q(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function K(e,t){let n=Math.random();return t*n+(1-n)*e}function X(e,t){let n=0;for(let r=0;r<e.length;r++){let a=Number(e[r])-Number(t[r]);n+=a*a}return n}function Y(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function Z(e,t,n=""){Y(ne(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function J(e){Y(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function Q(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function ee(e){return 0===e.length}function te(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}function ne(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function re(e){return e%1==0}function ae(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function se(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function ie(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return V(t),t}function oe(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function le(e,t=(e=>0),n,r){return new Promise(((a,s)=>{let i=0,o=()=>{if(e())return void a();i++;let l=t(i);null!=n&&i>=n?s():null!=r?r(o,l):setTimeout(o,l)};o()}))}function ue(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let a=e.slice();return a[r]=t/n,a}function pe(e,t){let n=t.length;return Y((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),Y(e.every((e=>re(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function de(e,t){let n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||a?null:pe(t,e).sort(),i=0;for(let t=0;t<e.length;++t){if(null!=s){if(s[i]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==s[i]||s[i]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),s[i]<=t&&i++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function he(e,t){return ce(e,t)}function ce(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function fe(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function me(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function ge(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function ye(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function be(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function xe(e){return"string"==typeof e||e instanceof String}function we(e){return"boolean"==typeof e}function ve(e){return"number"==typeof e}function ke(e){return Array.isArray(e)?ke(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":ve(e)?"float32":xe(e)?"string":we(e)?"bool":"float32"}function Ie(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Se(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function Ne(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function Te(e,t,n,r=!1){let a=new Array;if(1===t.length){let s=t[0]*(r?2:1);for(let t=0;t<s;t++)a[t]=n[e+t]}else{let s=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<s;t++)a[t]=Te(e+t*o,i,n,r)}return a}function _e(e,t,n=!1){if(0===e.length)return t[0];let r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Te(0,e,t,n)}function Ce(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function Ee(e,t){let n=$e(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function $e(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Ae(e,t){let n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return _e(e,new Float32Array(n));if("int32"===t)return _e(e,new Int32Array(n));if("bool"===t)return _e(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Fe(e){e.forEach((t=>{Y(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function Re(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function De(e,t,n){if(0===t)return[];if(1===t)return[e];let r=new Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}function Me(e){return e&&e.then&&"function"==typeof e.then}var Oe="tfjsflags",Le=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=ze,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(Pe().getBool("IS_TEST")||Pe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){let t=this.urlFlags[e];Pe().getBool("IS_TEST")||Pe().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(Me(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;let e=this.getQueryParams(this.global.location.search);Oe in e&&e[Oe].split(",").forEach((e=>{let[t,n]=e.split(":");this.urlFlags[t]=function(e,t){let n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}};function ze(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("=")))),t}function Pe(){return We}var Be,We=null;function Ve(){if(null==Be){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof global)e=global;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}Be=e}return Be}function Ue(e,t){let n=function(){let e=Ve();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var Ge="Abs",He="Acos",je="Acosh",qe="Add",Ke="AddN",Xe="All",Ye="Any",Ze="ArgMax",Je="ArgMin",Qe="Asin",et="Asinh",tt="Atan",nt="Atanh",rt="Atan2",at="AvgPool",st="AvgPoolGrad",it="AvgPool3D",ot="AvgPool3DGrad",lt="BatchMatMul",ut="BatchToSpaceND",pt="Bincount",dt="BitwiseAnd",ht="BroadcastTo",ct="BroadcastArgs",ft="Cast",mt="Ceil",gt="ClipByValue",yt="Complex",bt="ComplexAbs",xt="Concat",wt="Conv2D",vt="Conv2DBackpropFilter",kt="Conv2DBackpropInput",It="Conv3D",St="Conv3DBackpropFilterV2",Nt="Conv3DBackpropInputV2",Tt="Cos",_t="Cosh",Ct="Cumprod",Et="Cumsum",$t="CropAndResize",At="DenseBincount",Ft="DepthToSpace",Rt="DepthwiseConv2dNative",Dt="DepthwiseConv2dNativeBackpropFilter",Mt="DepthwiseConv2dNativeBackpropInput",Ot="Diag",Lt="Dilation2D",zt="Dilation2DBackpropInput",Pt="Dilation2DBackpropFilter",Bt="Draw",Wt="RealDiv",Vt="Einsum",Ut="Elu",Gt="EluGrad",Ht="Erf",jt="Equal",qt="Exp",Kt="ExpandDims",Xt="Expm1",Yt="FFT",Zt="Fill",Jt="FlipLeftRight",Qt="Floor",en="FloorDiv",tn="FusedBatchNorm",nn="GatherV2",rn="GatherNd",an="Greater",sn="GreaterEqual",on="Identity",ln="IFFT",un="Imag",pn="IsFinite",dn="IsInf",hn="IsNan",cn="LeakyRelu",fn="Less",mn="LessEqual",gn="LinSpace",yn="Log",bn="Log1p",xn="LogicalAnd",wn="LogicalNot",vn="LogicalOr",kn="LogicalXor",In="LogSoftmax",Sn="LowerBound",Nn="LRN",Tn="LRNGrad",_n="MatrixBandPart",Cn="Max",En="Maximum",$n="MaxPool",An="MaxPoolGrad",Fn="MaxPool3D",Rn="MaxPool3DGrad",Dn="MaxPoolWithArgmax",Mn="Mean",On="Min",Ln="Minimum",zn="MirrorPad",Pn="Mod",Bn="Multinomial",Wn="Multiply",Vn="Neg",Un="NotEqual",Gn="NonMaxSuppressionV3",Hn="NonMaxSuppressionV4",jn="NonMaxSuppressionV5",qn="OnesLike",Kn="OneHot",Xn="Pack",Yn="PadV2",Zn="Pool",Jn="Pow",Qn="Prelu",er="Prod",tr="RaggedGather",nr="RaggedRange",rr="RaggedTensorToTensor",ar="Range",sr="Real",ir="Reciprocal",or="Relu",lr="Reshape",ur="ResizeNearestNeighbor",pr="ResizeNearestNeighborGrad",dr="ResizeBilinear",hr="ResizeBilinearGrad",cr="Relu6",fr="Reverse",mr="Round",gr="Rsqrt",yr="ScatterNd",br="TensorScatterUpdate",xr="SearchSorted",wr="Select",vr="Selu",kr="Slice",Ir="Sin",Sr="Sinh",Nr="Sign",Tr="Sigmoid",_r="Softplus",Cr="Sqrt",Er="Sum",$r="SpaceToBatchND",Ar="SplitV",Fr="Softmax",Rr="SparseFillEmptyRows",Dr="SparseReshape",Mr="SparseSegmentMean",Or="SparseSegmentSum",Lr="SparseToDense",zr="SquaredDifference",Pr="Square",Br="StaticRegexReplace",Wr="StridedSlice",Vr="StringNGrams",Ur="StringSplit",Gr="StringToHashBucketFast",Hr="Sub",jr="Tan",qr="Tanh",Kr="Tile",Xr="TopK",Yr="Transform",Zr="Transpose",Jr="Unique",Qr="Unpack",ea="UnsortedSegmentSum",ta="UpperBound",na="ZerosLike",ra="Step",aa="FromPixels",sa="RotateWithOffset",ia="_FusedMatMul",oa="FusedConv2D",la="FusedDepthwiseConv2D";function ua(...e){Pe().getBool("IS_TEST")||Pe().getBool("PROD")||console.warn(...e)}function pa(...e){Pe().getBool("IS_TEST")||Pe().getBool("PROD")||console.log(...e)}var da=Ue("kernelRegistry",(()=>new Map)),ha=Ue("gradRegistry",(()=>new Map));function ca(e,t){let n=va(e,t);return da.get(n)}function fa(e){return ha.get(e)}function ma(e){let t=da.entries(),n=[];for(;;){let{done:r,value:a}=t.next();if(r)break;let[s,i]=a,[o]=s.split("_");o===e&&n.push(i)}return n}function ga(e){let{kernelName:t,backendName:n}=e,r=va(t,n);da.has(r)&&ua(`The kernel '${t}' for backend '${n}' is already registered`),da.set(r,e)}function ya(e){let{kernelName:t}=e;ha.has(t)&&Pe().getBool("DEBUG")&&ua(`Overriding the gradient for '${t}'`),ha.set(t,e)}function ba(e,t){let n=va(e,t);if(!da.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);da.delete(n)}function xa(e){if(!ha.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);ha.delete(e)}function wa(e,t){ma(e).forEach((e=>{ga(Object.assign({},e,{backendName:t}))}))}function va(e,t){return`${t}_${e}`}var ka={};function Ia(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}g(ka,{arraysEqual:()=>ne,arraysEqualWithNull:()=>te,assert:()=>Y,assertNonNegativeIntegerDimensions:()=>Fe,assertNonNull:()=>J,assertShapesMatch:()=>Z,bytesFromStringArray:()=>be,bytesPerElement:()=>ye,checkConversionForErrors:()=>fe,clamp:()=>G,computeStrides:()=>Ne,convertBackendValuesAndArrayBuffer:()=>Ce,createScalarValue:()=>za,createShuffledIndices:()=>ie,decodeString:()=>Ua,distSquared:()=>X,encodeString:()=>Va,fetch:()=>Wa,fingerPrint64:()=>La,flatten:()=>Ha,getArrayFromDType:()=>ce,getTypedArrayFromDType:()=>he,hasEncodingLoss:()=>ge,hexToLong:()=>Ta,indexToLoc:()=>De,inferDtype:()=>ke,inferFromImplicitShape:()=>ue,isBoolean:()=>we,isFunction:()=>Ie,isInt:()=>re,isNumber:()=>ve,isPromise:()=>Me,isScalarShape:()=>ee,isString:()=>xe,isTypedArray:()=>Ga,isValidDtype:()=>me,locToIndex:()=>Re,makeOnesTypedArray:()=>Ee,makeZerosNestedTypedArray:()=>Ae,makeZerosTypedArray:()=>$e,nearestDivisor:()=>Se,nearestLargerEven:()=>H,now:()=>Ba,parseAxisParam:()=>pe,randUniform:()=>K,repeatedTry:()=>le,rightPad:()=>oe,shuffle:()=>V,shuffleCombo:()=>U,sizeFromShape:()=>Q,sizeToSquarishShape:()=>se,squeezeShape:()=>de,sum:()=>q,swap:()=>j,tanh:()=>ae,toNestedArray:()=>_e,toTypedArray:()=>Pa});var Sa=y(b()),Na=Sa.default||Sa;function Ta(e){return Na.fromString(e,!0,16)}var _a=Ta("c3a5c85c97cb3127"),Ca=Ta("b492b66fbe98f273"),Ea=Ta("9ae16a3b2f90404f");function $a(e){return e.xor(e.shru(47))}function Aa(e,t,n){let r=e.slice(t,t+n);return Na.fromBytes(Array.from(r),!0,!0)}function Fa(e,t){return Aa(e,t,8)}function Ra(e,t){return Aa(e,t,4)}function Da(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Ma(e,t,n=Ta("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function Oa(e,t,n,r){return function(e,t,n,r,a,s){a=a.add(e),s=Da(s.add(a).add(r),21);let i=a;return a=(a=a.add(t)).add(n),s=s.add(Da(a,44)),[a.add(r),s.add(i)]}(Fa(e,t),Fa(e,t+8),Fa(e,t+16),Fa(e,t+24),n,r)}function La(e,t=e.length){let n=Na.fromNumber(81,!0);if(t<=32)return t<=16?function(e,t=e.length){if(t>=8){let n=Ea.add(2*t),r=Fa(e,0).add(Ea),a=Fa(e,t-8);return Ma(Da(a,37).mul(n).add(r),Da(r,25).add(a).mul(n),n)}if(t>=4){let n=Ea.add(2*t);return Ma(Ra(e,0).shl(3).add(t),Ra(e,t-4),n)}if(t>0){let n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return $a(Ea.mul(n).xor(_a.mul(r))).mul(Ea)}return Ea}(e,t):function(e,t=e.length){let n=Ea.add(2*t),r=Fa(e,0).mul(Ca),a=Fa(e,8),s=Fa(e,t-8).mul(n),i=Fa(e,t-16).mul(Ea);return Ma(Da(r.add(a),43).add(Da(s,30)).add(i),r.add(Da(a.add(Ea),18)).add(s),n)}(e,t);if(t<=64)return function(e,t=e.length){let n=Ea.add(2*t),r=Fa(e,0).mul(Ea),a=Fa(e,8),s=Fa(e,t-8).mul(n),i=Fa(e,t-16).mul(Ea),o=Da(r.add(a),43).add(Da(s,30)).add(i),l=Ma(o,r.add(Da(a.add(Ea),18)).add(s),n),u=Fa(e,16).mul(n),p=Fa(e,24),d=o.add(Fa(e,t-32)).mul(n),h=l.add(Fa(e,t-24)).mul(n);return Ma(Da(u.add(p),43).add(Da(d,30)).add(h),u.add(Da(p.add(r),18)).add(d),n)}(e,t);let r=n,a=n.mul(Ca).add(113),s=$a(a.mul(Ea).add(113)).mul(Ea),i=[Na.UZERO,Na.UZERO],o=[Na.UZERO,Na.UZERO];r=r.mul(Ea).add(Fa(e,0));let l=0,u=64*(t-1>>6),p=u+(t-1&63)-63;do{r=Da(r.add(a).add(i[0]).add(Fa(e,l+8)),37).mul(Ca),a=Da(a.add(i[1]).add(Fa(e,l+48)),42).mul(Ca),r=r.xor(o[1]),a=a.add(i[0]).add(Fa(e,l+40)),s=Da(s.add(o[0]),33).mul(Ca),i=Oa(e,l,i[1].mul(Ca),r.add(o[0])),o=Oa(e,l+32,s.add(o[1]),a.add(Fa(e,l+16))),[s,r]=[r,s],l+=64}while(l!==u);let d=Ca.add(s.and(255).shl(1));return l=p,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=Da(r.add(a).add(i[0]).add(Fa(e,l+8)),37).mul(d),a=Da(a.add(i[1]).add(Fa(e,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),a=a.add(i[0].mul(9).add(Fa(e,l+40))),s=Da(s.add(o[0]),33).mul(d),i=Oa(e,l,i[1].mul(d),r.add(o[0])),o=Oa(e,l+32,s.add(o[1]),a.add(Fa(e,l+16))),[s,r]=[r,s],Ma(Ma(i[0],o[0],d).add($a(a).mul(_a)).add(s),Ma(i[1],o[1],d).add(r),d)}function za(e,t){return"string"===t?Va(e):Pa([e],t)}function Pa(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Ha(e)),Pe().getBool("DEBUG")&&fe(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){let t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function Ba(){return Pe().platform.now()}function Wa(e,t){return Pe().platform.fetch(e,t)}function Va(e,t="utf-8"){return t=t||"utf-8",Pe().platform.encode(e,t)}function Ua(e,t="utf-8"){return t=t||"utf-8",Pe().platform.decode(e,t)}function Ga(e){return null!=Pe().platform.isTypedArray?Pe().platform.isTypedArray(e):Ia(e)}function Ha(e,t=[],n=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||Me(e)||null==e||Ga(e)&&n)t.push(e);else if(Array.isArray(e)||Ga(e))for(let r=0;r<e.length;++r)Ha(e[r],t,n);else{let r=-1;for(let t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let a=0;a<=r;a++)Ha(e[a],t,n)}return t}var ja=class{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new Ka)}profileKernel(e,t,n){let r,a,s=()=>{r=n()},i=Ba();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let e of r)e.dataSync();a=Promise.resolve({kernelMs:Ba()-i})}if(Pe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<r.length;t++){let n=r[t];n.data().then((t=>{qa(t,n.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),r,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}};function qa(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){let r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}var Ka=class{logKernelProfile(e,t,n,r,a,s){let i="number"==typeof r?oe(`${r}ms`,9):r.error,o=oe(e,25),l=t.rank,u=t.size,p=oe(t.shape.toString(),14),d="";for(let e in a){let n=a[e];if(null!=n){let r=n.shape||t.shape,a=r.length;d+=`${e}: ${a}D ${a>0?r:""} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${p}\t%c${u}\t%c${d}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};var Xa=20,Ya=3,Za=7;function Ja(e,t,n,r){let a=Ne(t),s=function(e,t,n,r){let a=Q(t),s=r[r.length-1],i=new Array(s).fill(0),o=t.length,l="complex64"===n?ns(e):e;if(o>1)for(let e=0;e<a/s;e++){let t=e*s;for(let e=0;e<s;e++)i[e]=Math.max(i[e],Qa(l[t+e],0,n).length)}return i}(e,t,n,a),i=t.length,o=ts(e,t,n,a,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map((e=>"    "+e)).join("\n")),l.join("\n")}function Qa(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(Za))} + ${parseFloat(e[1].toFixed(Za))}j`:xe(e)?`'${e}'`:"bool"===n?es(e):parseFloat(e.toFixed(Za)).toString(),oe(r,t)}function es(e){return 0===e?"false":"true"}function ts(e,t,n,r,a,s=!0){let i="complex64"===n?2:1,o=t[0],l=t.length;if(0===l){if("complex64"===n){return[Qa(ns(e)[0],0,n)]}return"bool"===n?[es(e[0])]:[e[0].toString()]}if(1===l){if(o>Xa){let t=Ya*i,r=Array.from(e.slice(0,t)),s=Array.from(e.slice((o-Ya)*i,o*i));return"complex64"===n&&(r=ns(r),s=ns(s)),["["+r.map(((e,t)=>Qa(e,a[t],n))).join(", ")+", ..., "+s.map(((e,t)=>Qa(e,a[o-Ya+t],n))).join(", ")+"]"]}return["["+("complex64"===n?ns(e):Array.from(e)).map(((e,t)=>Qa(e,a[t],n))).join(", ")+"]"]}let u=t.slice(1),p=r.slice(1),d=r[0]*i,h=[];if(o>Xa){for(let t=0;t<Ya;t++){let r=t*d,s=r+d;h.push(...ts(e.slice(r,s),u,n,p,a,!1))}h.push("...");for(let t=o-Ya;t<o;t++){let r=t*d,s=r+d;h.push(...ts(e.slice(r,s),u,n,p,a,t===o-1))}}else for(let t=0;t<o;t++){let r=t*d,s=r+d;h.push(...ts(e.slice(r,s),u,n,p,a,t===o-1))}let c=2===l?",":"";h[0]="["+(o>0?h[0]+c:"");for(let e=1;e<h.length-1;e++)h[e]=" "+h[e]+c;let f=",\n";for(let e=2;e<l;e++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(s?"":f),h}function ns(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var rs=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Q(e),null!=n){let e=n.length;Y(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||ce(t,this.size),this.strides=Ne(e)}set(e,...t){0===t.length&&(t=[0]),Y(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));let n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(let n of e){if(n<0||n>=this.shape[t]){let t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return as().makeTensor(this.values,this.shape,this.dtype)}},as=null,ss=null;var is=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Q(e),this.strides=Ne(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return ss.buffer(this.shape,this.dtype,e)}bufferSync(){return ss.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return _e(this.shape,e,"complex64"===this.dtype)}arraySync(){return _e(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();let e=as().read(this.dataId);if("string"===this.dtype){let t=await e;try{return t.map((e=>Ua(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),as().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=as().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>Ua(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await as().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),as().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return ss.print(this,e)}clone(){return this.throwIfDisposed(),ss.clone(this)}toString(e=!1){return Ja(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),ss.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),as().makeVariable(this,e,t,n)}};function os(){return Ue("Tensor",(()=>is))}Object.defineProperty(is,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),os();var ls=class extends is{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!ne(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);as().disposeTensor(this),this.dataId=e.dataId,as().incRef(this,null)}dispose(){as().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(ls,Symbol.hasInstance,{value:e=>e instanceof is&&null!=e.assign&&e.assign instanceof Function});var us,ps,ds,hs,cs,fs={};g(fs,{assertTypesMatch:()=>vs,getTensorsInContainer:()=>Is,isTensorInList:()=>ks,makeTypesMatch:()=>ws}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(us||(us={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(ps||(ps={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(ds||(ds={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(hs||(hs={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(cs||(cs={}));var ms={float32:hs,int32:ps,bool:ds,complex64:cs};function gs(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return ms[e][t]}function ys(e){return gs(e,"int32")}function bs(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function xs(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function ws(e,t){if(e.dtype===t.dtype)return[e,t];let n=gs(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function vs(e,t){Y(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function ks(e,t){return t.some((t=>t.id===e.id))}function Is(e){let t=[];return Ss(e,t,new Set),t}function Ss(e,t,n){if(null==e)return;if(e instanceof is)return void t.push(e);if(!function(e){return Array.isArray(e)||"object"==typeof e}(e))return;let r=e;for(let e in r){let a=r[e];n.has(a)||(n.add(a),Ss(a,t,n))}}function Ns(e){return null!=e.kernelName}var Ts=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},_s=class e{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ts}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{let{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(ua(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new ja(this.backendInstance),!0}setupRegisteredKernels(){ma(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){ma(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){let t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(!n||n instanceof B||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{let t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,ua(`Initialization of backend ${e} failed`),ua(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(t){return ua(`Initialization of backend ${e} failed`),ua(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),s=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{let e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return e.nextTensorId++}nextVariableId(){return e.nextVariableId++}clone(e){let t=Es.runKernel(on,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{let t={x:e},n={dtype:"float32"};return Es.runKernel(ft,t,n)}})),[],{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==ca(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let r=this.backend.numDataIds(),a=0;n.forEach((e=>{a+="complex64"===e.dtype?3:1}));let s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-a-s;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n,r=[],a=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;let o,l=Ns(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Ns(e)){let{kernelName:t,inputs:s,attrs:i}=e;null==this.backendName&&this.backend;let l=ca(t,this.backendName);Y(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),n=()=>{let e=this.backend.numDataIds();o=l.kernelFunc({inputs:s,attrs:i,backend:this.backend});let n=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,n);let u=n.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(a){let e=this.getTensorsForGradient(t,s,u);r=this.saveTensorsForBackwardMode(e)}return u}}else{let{forwardFunc:t}=e,s=e=>{a&&(r=e.map((e=>this.keep(this.clone(e)))))};n=()=>{let e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,s)));let n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}let u,{inputs:p,attrs:d}=e,h=Ns(e)?null:e.backwardsFunc;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(u=this.profiler.profileKernel(l,p,(()=>n())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(u),t=u.outputs):t=n()})),a&&this.addTapeNode(l,p,t,h,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map((e=>null!=p[e]?p[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:u.timeMs,extraInfo:u.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){let r=fa(e);if(null!=r){let e,a=r.inputsToSave||[],s=r.outputsToSave||[];r.saveAllInputs?(Y(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),e=Object.keys(t).map((e=>t[e]))):e=a.map((e=>t[e]));let i=n.filter(((e,t)=>s[t]));return e.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&xe(e[0])&&(a=e.map((e=>Va(e))));let s=r.write(a,t,n),i=new is(t,n,s,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){let e=this.state.tensorInfo.get(s),t=be(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){let a={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){let{dataId:n,shape:r,dtype:a}=e,s=new is(r,a,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));let a=new ls(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*ye(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof ls||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){let t=e.size*ye(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,s){let i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},o=fa(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){let e=n[t],r=$e(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],a,s))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=Is(e),n=new Set(t.map((e=>e.id)));for(let e=0;e<this.state.activeScope.track.length;e++){let t=this.state.activeScope.track[e];!t.kept&&!n.has(t.id)&&t.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{!e.kept&&e.scopeId===r.id&&this.track(e)}))}gradients(e,t,n,r=!1){if(Y(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));Y(a instanceof is,(()=>"The result y returned by f() must be a tensor."));let s=function(e,t,n){let r={},a={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){let s=e[n],i=s.inputs;for(let e in i){let n=i[e],o=!1;for(let e=0;e<t.length;e++)if(r[n.id]){s.outputs.forEach((e=>r[e.id]=!0)),o=!0,a[s.id]=!0;break}if(o)break}}let s={};s[n.id]=!0;let i={};for(let t=e.length-1;t>=0;t--){let n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(s[n.outputs[e].id]){for(let e in r)s[r[e].id]=!0,i[n.id]=!0;break}}let o=[];for(let t=0;t<e.length;t++){let n=e[t];if(a[n.id]&&i[n.id]){let e={};for(let t in n.inputs){let a=n.inputs[t];r[a.id]&&(e[t]=a)}let t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,o.push(t)}}return o}(this.state.activeTape,t,a);if(!r&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{let e={};e[a.id]=null==n?function(e){let t=Ee(Q(e),"float32");return Es.makeTensor(t,e,"float32")}(a.shape):n,function(e,t,n,r){for(let a=t.length-1;a>=0;a--){let s=t[a],i=[];if(s.outputs.forEach((t=>{let n=e[t.id];null!=n?i.push(n):i.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let t in s.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);let a=n((()=>o[t]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);let i=s.inputs[t];if(!ne(a.shape,i.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=a;else{let t=e[i.id];e[i.id]=r(t,a),t.dispose()}}}}(e,s,(e=>this.tidy(e)),$s);let r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(let t of e.saved)t.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(e){return Y(Ie(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{Y(t.every((e=>e instanceof is)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));let n,r={};t.forEach(((e,t)=>{r[t]=e}));return this.runKernelFunc({forwardFunc:(r,a)=>(n=e(...t,a),Y(n.value instanceof is,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Y(Ie(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(e,r)=>{let a=n.gradFunc(e,r),s=Array.isArray(a)?a:[a];Y(s.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Y(s.every((e=>e instanceof is)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));let i={};return s.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=Ba(),n=await this.backend.time(e);return n.wallMs=Ba()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ts;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};function Cs(){let e=Ve();if(null==e._tfengine){let t=new Le(e);e._tfengine=new _s(t)}return function(e){We=e}(e._tfengine.ENV),function(e){as=e}((()=>e._tfengine)),e._tfengine}_s.nextTensorId=0,_s.nextVariableId=0;var Es=Cs();function $s(e,t){let n={a:e,b:t};return Es.runKernel(qe,n)}var As,Fs={};function Rs(e){As=e}function Ds(e){if(void 0!==As)return As;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;let t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){let t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Ms(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}g(Fs,{isBrowser:()=>Ms,isMobile:()=>Ds,mockIsMobile:()=>Rs});var Os=Pe();function Ls(e,t){let n=e;if(Ga(e))return"string"===t?[]:[e.length];if(bs(e)){let t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(xs(e))return[e.buffer.size/(null==t?4:ye(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||Ga(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&Pe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&zs(e,r,[]),r}function zs(e,t,n){if(n=n||[],!Array.isArray(e)&&!Ga(e))return void Y(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));Y(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),Y(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));let r=t.slice(1);for(let t=0;t<e.length;++t)zs(e[t],r,n.concat(t))}function Ps(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function Bs(e,t,n,r="numeric"){if(e instanceof os())return Ps(r,e.dtype,t,n),e;let a=ke(e);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),Ps(r,a,t,n),null==e||!Ga(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){let r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}let s=Ls(e,a);!Ga(e)&&!Array.isArray(e)&&(e=[e]);let i="string"!==a?Pa(e,a):Ha(e,[],!0);return Es.makeTensor(i,s,a)}function Ws(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,a)=>Bs(e,`${t}[${a}]`,n,r)))}Os.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Os.registerFlag("IS_BROWSER",(()=>Ms())),Os.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),Os.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Os.registerFlag("IS_SAFARI",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),Os.registerFlag("PROD",(()=>!1)),Os.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Os.getBool("DEBUG"))),Os.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Os.registerFlag("IS_TEST",(()=>!1)),Os.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>Os.getBool("DEBUG"))),Os.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Os.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Os.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));var Vs="__op";function Us(e){let t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=Vs;let a=(...e)=>{Es.startScope(n);try{let t=r(...e);return Me(t)&&console.error("Cannot return a Promise inside of tidy."),Es.endScope(t),t}catch(e){throw Es.endScope(null),e}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}var Gs=Us({complex_:function(e,t){let n=Bs(e,"real","complex"),r=Bs(t,"imag","complex");Z(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let a={real:n,imag:r};return Es.runKernel(yt,a)}});function Hs(e,t,n,r){if(null==r)r=ke(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(xs(e)||bs(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return Es.backend.createTensorFromGPUData(e,t||n,r)}if(!Ga(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Fe(t);let e=Q(t),r=Q(n);Y(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let e=0;e<n.length;++e){let r=n[e],a=e!==n.length-1||r!==Q(t.slice(e));Y(n[e]===t[e]||!a,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return!Ga(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e="string"!==r?Pa(e,r):Ha(e,[],!0),Es.makeTensor(e,t,r)}function js(e,t,n){return Hs(e,t,Ls(e,n),n)}var qs={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Ks=class e{static join(t){return new e(t).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e||(e instanceof Array||(e=[e]),0===(e=e.map((e=>Ga(e)?e.buffer:e))).length))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){let r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let a=t+r.byteLength;this.shards.push({buffer:r,start:t,end:a}),t=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),(t=Math.min(this.byteLength,t))<=e)return new ArrayBuffer(0);let n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);let r=new ArrayBuffer(t-e),a=new Uint8Array(r),s=0;for(let r=n;r<this.shards.length;r++){let n=this.shards[r],i=e+s-n.start,o=s,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,i,l-i);if(a.set(u,o),s+=u.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;let n=function(e,t){let n=0,r=e.length;for(;n<=r;){let a=Math.floor((r-n)/2)+n,s=t(e[a]);if(0===s)return a;s<0?r=a:n=a+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}};function Xs(){Pe().set("PROD",!0)}function Ys(){Pe().set("DEBUG",!0)}function Zs(){Pe().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Js(e){Pe().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Qs(){Es.disposeVariables()}function ei(){return Es}function ti(){return Es.memory()}function ni(e){return Es.profile(e)}function ri(e,t){return Es.tidy(e,t)}function ai(e){Is(e).forEach((e=>e.dispose()))}function si(e){return Es.keep(e)}function ii(e){return Es.time(e)}function oi(e){return Es.setBackend(e)}function li(){return Es.ready()}function ui(){return Es.backendName}function pi(e){Es.removeBackend(e)}function di(e){return Es.findBackend(e)}function hi(e){return Es.findBackendFactory(e)}function ci(e,t,n=1){return Es.registerBackend(e,t,n)}function fi(){return Es.backend}function mi(e,t){Pe().setPlatform(e,t)}!function(e){e}(Js);var gi=4;async function yi(e,t){let n=[],r=[],a=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let s=0;s<a.length;++s){let i=a[s],o=Array.isArray(e)?e[s].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);let l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){let e=new Promise((async e=>{let t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+gi*t.length,r=new Uint8Array(n),a=0;for(let e=0;e<t.length;e++){let n=t[e],s=new Uint8Array(new Uint32Array([n.length]).buffer);r.set(s,a),a+=gi,r.set(n,a),a+=n.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:Si(await Promise.all(r)),specs:n}}function bi(e,t){let n=new Ks(e),r={},a=0;for(let e of t){let t=xi(e,((e,t)=>n.slice(a+e,a+t)));r[e.name]=vi(e,n.slice(a,a+t)),a+=t}return r}function xi(e,t){let n,r=Q(e.shape);if("quantization"in e){let t=e.quantization;n=qs[t.dtype]}else{if("string"===e.dtype){let e=0;for(let n=0;n<r;n++)e+=gi+new Uint32Array(t(e,e+gi))[0];return e}n=qs[e.dtype]}return r*n}async function wi(e,t){let n,r=Q(e.shape);if("quantization"in e){let t=e.quantization;n=qs[t.dtype]}else{if("string"===e.dtype){let e=0;for(let n=0;n<r;n++)e+=gi+new Uint32Array(await t(e,e+gi))[0];return e}n=qs[e.dtype]}return r*n}function vi(e,t){let n,r=e.name,a=e.dtype,s=e.shape,i=Q(s),o=0;if("quantization"in e){let s=e.quantization;if("uint8"===s.dtype||"uint16"===s.dtype){if(!("min"in s)||!("scale"in s))throw new Error(`Weight ${e.name} with quantization ${s.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==s.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${s.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${e.name} is quantized with ${s.dtype} which only supports weights of type float32 not ${a}.`)}let l=qs[s.dtype],u="uint8"===s.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===a)if("uint8"===s.dtype||"uint16"===s.dtype){n=new Float32Array(u.length);for(let e=0;e<u.length;e++){let t=u[e];n[e]=t*s.scale+s.min}}else{if("float16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type float32.`);n=function(){let e=function(){let e=e=>{let t=e<<13,n=0;for(;!(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{let a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let a=0;a<r.length;a++){let i=r[a],o=e[n[i>>10]+(1023&i)]+t[i>>10];s[a]=o}return new Float32Array(a)}}()(u)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${r}': ${a}`);if("uint8"!==s.dtype&&"uint16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type int32.`);n=new Int32Array(u.length);for(let e=0;e<u.length;e++){let t=u[e];n[e]=Math.round(t*s.scale+s.min)}}o+=i*l}else if("string"===a){let r=Q(e.shape);n=[];for(let e=0;e<r;e++){let e=new Uint32Array(t.slice(o,o+gi))[0];o+=gi;let r=new Uint8Array(t.slice(o,o+e));n.push(r),o+=e}}else{let e=qs[a];if("float32"===a)n=new Float32Array(t);else if("int32"===a)n=new Int32Array(t);else{if("bool"!==a){if("complex64"===a){n=new Float32Array(t);let e=new Float32Array(n.length/2),r=new Float32Array(n.length/2);for(let t=0;t<e.length;t++)e[t]=n[2*t],r[t]=n[2*t+1];let a=js(e,s,"float32"),i=js(r,s,"float32"),o=Gs(a,i);return a.dispose(),i.dispose(),o}throw new Error(`Unsupported dtype in weight '${r}': ${a}`)}n=new Uint8Array(t)}o+=i*e}return js(n,s,a)}async function ki(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){let{done:t,value:a}=await e.read();if(t&&null==a){let e=n-r.byteLength;throw new Error(`Reader is done but ${e} bytes are still expected`)}let s=new Uint8Array(r.length+a.byteLength);s.set(r,0),s.set(new Uint8Array(a),r.length),r=s}return r.buffer}async function Ii(e,t){let n={},r=e.getReader(),a=new ArrayBuffer(0);for(let e of t){let t=await wi(e,(async(e,t)=>(a=await ki(r,a,t),a.slice(e,t))));a=await ki(r,a,t);let s=a.slice(0,t);a=a.slice(t);let i=vi(e,s);if(n[e.name]=i,"webgpu"===ui()){let e=fi();"uploadToGPU"in e&&Q(i.shape)>=Pe().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(i.dataId)}}return n}function Si(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));let r=new Uint8Array(t),a=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),a),a+=e.byteLength})),r.buffer}var Ni="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function Ti(e){return Ni?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function _i(e){return Ks.join(e)}function Ci(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);let t=e.split("/");return t[t.length-1]}function Ei(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function $i(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function Ai(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),$i(e,n,r)}function Fi(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:Ti(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:Ti(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new Ks(e.weightData).byteLength}}function Ri(e){let t=[];for(let n of e)t.push(...n.weights);return t}var Di=class e{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==e.instance&&(e.instance=new e),e.instance}static registerSaveRouter(t){e.getInstance().saveRouters.push(t)}static registerLoadRouter(t){e.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return e.getHandlers(t,"save")}static getLoadHandlers(t,n){return e.getHandlers(t,"load",n)}static getHandlers(t,n,r){let a=[];return("load"===n?e.getInstance().loadRouters:e.getInstance().saveRouters).forEach((e=>{let n=e(t,r);null!==n&&a.push(n)})),a}},Mi=e=>Di.registerSaveRouter(e),Oi=e=>Di.registerLoadRouter(e),Li=e=>Di.getSaveHandlers(e),zi=(e,t)=>Di.getLoadHandlers(e,t),Pi="tensorflowjs",Bi="models_store",Wi="model_info_store";function Vi(){if(!Pe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Ui(e){let t=e.result;t.createObjectStore(Bi,{keyPath:"modelPath"}),t.createObjectStore(Wi,{keyPath:"modelPath"})}var Gi=class{constructor(e){if(this.indexedDB=Vi(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{let r=this.indexedDB.open(Pi,1);r.onupgradeneeded=()=>Ui(r),r.onsuccess=()=>{let a=r.result;if(null==t){let t=a.transaction(Bi,"readonly"),r=t.objectStore(Bi).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(a.close(),n(r.error)),t.oncomplete=()=>a.close()}else{t.weightData=Ks.join(t.weightData);let r,s,i=Fi(t),o=a.transaction(Wi,"readwrite"),l=o.objectStore(Wi);try{r=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(e){return n(e)}r.onsuccess=()=>{s=a.transaction(Bi,"readwrite");let r,u=s.objectStore(Bi);try{r=u.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(e){return n(e)}r.onsuccess=()=>e({modelArtifactsInfo:i}),r.onerror=e=>{l=o.objectStore(Wi);let t=l.delete(this.modelPath);t.onsuccess=()=>(a.close(),n(r.error)),t.onerror=e=>(a.close(),n(r.error))}},r.onerror=e=>(a.close(),n(r.error)),o.oncomplete=()=>{null==s?a.close():s.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)}))}};Gi.URL_SCHEME="indexeddb://";var Hi=e=>Pe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Gi.URL_SCHEME)?function(e){return new Gi(e)}(e.slice(Gi.URL_SCHEME.length)):null;Di.registerSaveRouter(Hi),Di.registerLoadRouter(Hi);var ji="/",qi="tensorflowjs_models",Ki="info",Xi="model_topology",Yi="weight_specs",Zi="weight_data",Ji="model_metadata";function Qi(e){return{info:[qi,e,Ki].join(ji),topology:[qi,e,Xi].join(ji),weightSpecs:[qi,e,Yi].join(ji),weightData:[qi,e,Zi].join(ji),modelMetadata:[qi,e,Ji].join(ji)}}function eo(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function to(e){let t=e.split(ji);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(ji)}var no=class{constructor(e){if(!Pe().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Qi(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=Fi(e),a=Ks.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(e){if(Ni)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let e=0,r=t.length;e<r;e++)n+=String.fromCharCode(t[e]);return btoa(n)}(a));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch(e){throw eo(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){let e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(Ni){let t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}(s),t}};no.URL_SCHEME="localstorage://";var ro=e=>Pe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(no.URL_SCHEME)?function(e){return new no(e)}(e.slice(no.URL_SCHEME.length)):null;Di.registerSaveRouter(ro),Di.registerLoadRouter(ro);var ao="://",so=class e{constructor(){this.managers={}}static getInstance(){return null==e.instance&&(e.instance=new e),e.instance}static registerManager(t,n){Y(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith(ao)&&(t=t.slice(0,t.indexOf(ao))),Y(t.length>0,(()=>"scheme must not be an empty string."));let r=e.getInstance();Y(null==r.managers[t],(()=>`A model store manager is already registered for scheme '${t}'.`)),r.managers[t]=n}static getManager(t){let n=e.getInstance().managers[t];if(null==n)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(e.getInstance().managers)}};function io(e){if(-1===e.indexOf(ao))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${so.getSchemes().join(",")}`);return{scheme:e.split(ao)[0],path:e.split(ao)[1]}}async function oo(e,t,n=!1){Y(e!==t,(()=>`Old path and new path are the same: '${e}'`));let r=Di.getLoadHandlers(e);Y(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),Y(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));let a=r[0],s=Di.getSaveHandlers(t);Y(s.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),Y(s.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));let i=s[0],o=io(e).scheme,l=io(e).path,u=o===io(e).scheme,p=await a.load();n&&u&&await so.getManager(o).removeModel(l);let d=await i.save(p);return n&&!u&&await so.getManager(o).removeModel(l),d.modelArtifactsInfo}async function lo(){let e=so.getSchemes(),t={};for(let n of e){let e=await so.getManager(n).listModels();for(let r in e){t[n+ao+r]=e[r]}}return t}async function uo(e){let t=io(e);return so.getManager(t.scheme).removeModel(t.path)}async function po(e,t){return oo(e,t,!1)}async function ho(e,t){return oo(e,t,!0)}if(Pe().get("IS_BROWSER")){Pe().setPlatform("browser",new class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&Pe().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))}),!0))):setTimeout(e,t)}isTypedArray(e){return Ia(e)}});try{so.registerManager(no.URL_SCHEME,new class{constructor(){Y(Pe().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Y("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){let e={},t=qi+ji,n=ji+Ki;for(let r=0;r<this.LS.length;++r){let a=this.LS.key(r);a.startsWith(t)&&a.endsWith(n)&&(e[to(a)]=JSON.parse(this.LS.getItem(a)))}return e}async removeModel(e){let t=Qi(e=function(e){return e.startsWith(no.URL_SCHEME)?e.slice(no.URL_SCHEME.length):e}(e));if(null==this.LS.getItem(t.info))throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return eo(t),n}})}catch(e){}try{so.registerManager(Gi.URL_SCHEME,new class{constructor(){this.indexedDB=Vi()}async listModels(){return new Promise(((e,t)=>{let n=this.indexedDB.open(Pi,1);n.onupgradeneeded=()=>Ui(n),n.onsuccess=()=>{let r=n.result,a=r.transaction(Wi,"readonly"),s=a.objectStore(Wi).getAll();s.onsuccess=()=>{let t={};for(let e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){return e=function(e){return e.startsWith(Gi.URL_SCHEME)?e.slice(Gi.URL_SCHEME.length):e}(e),new Promise(((t,n)=>{let r=this.indexedDB.open(Pi,1);r.onupgradeneeded=()=>Ui(r),r.onsuccess=()=>{let a,s=r.result,i=s.transaction(Wi,"readwrite"),o=i.objectStore(Wi),l=o.get(e);l.onsuccess=()=>{if(null==l.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let r=o.delete(e),i=()=>{a=s.transaction(Bi,"readwrite");let r=a.objectStore(Bi).delete(e);r.onsuccess=()=>t(l.result.modelArtifactsInfo),r.onerror=e=>n(l.error)};r.onsuccess=i,r.onerror=e=>(i(),s.close(),n(l.error))}},l.onerror=e=>(s.close(),n(l.error)),i.oncomplete=()=>{null==a?s.close():a.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}})}catch(e){}}var co,fo=()=>x();function mo(e,t="float32",n){return t=t||"float32",Fe(e),new rs(e,t,n)}Pe().get("IS_NODE")&&!Pe().get("IS_BROWSER")&&Pe().setPlatform("node",new class{constructor(){this.util=w(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=Pe().global.fetch?Pe().global.fetch(e,t):(null==co&&(co=fo()),co(e,t))}now(){let e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}});var go=Us({cast_:function(e,t){let n=Bs(e,"x","cast");if(!me(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");let r={x:n},a={dtype:t};return Es.runKernel(ft,r,a)}});var yo=Us({clone_:function(e){let t={x:Bs(e,"x","clone","string_or_numeric")};return Es.runKernel(on,t)}});function bo(e,t=!1){console.log(e.toString(t))}Cs(),function(e){ss=e}({buffer:mo,cast:go,clone:yo,print:bo});var xo=Us({add_:function(e,t){let n=Bs(e,"a","add"),r=Bs(t,"b","add");[n,r]=ws(n,r);let a={a:n,b:r};return Es.runKernel(qe,a)}});var wo=Us({floorDiv_:function(e,t){let n=Bs(e,"a","floorDiv"),r=Bs(t,"b","floorDiv");[n,r]=ws(n,r);let a={a:n,b:r};return Es.runKernel(en,a)}});var vo=Us({div_:function(e,t){let n=Bs(e,"a","div"),r=Bs(t,"b","div");if([n,r]=ws(n,r),"int32"===n.dtype&&"int32"===r.dtype)return wo(n,r);let a={a:n,b:r};return Es.runKernel(Wt,a,{})}});var ko=Us({mul_:function(e,t){let n=Bs(e,"a","mul"),r=Bs(t,"b","mul");[n,r]=ws(n,r);let a={a:n,b:r};return Es.runKernel(Wn,a)}});var Io=Us({abs_:function(e){let t=Bs(e,"x","abs");if("complex64"===t.dtype){let e={x:t};return Es.runKernel(bt,e)}{let e={x:t};return Es.runKernel(Ge,e)}}});var So=Us({acos_:function(e){let t={x:Bs(e,"x","acos")};return Es.runKernel(He,t)}});var No=Us({acosh_:function(e){let t={x:Bs(e,"x","acosh")};return Es.runKernel(je,t)}});var To=Us({addN_:function(e){Y(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),Y(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));let t=e.map(((e,t)=>Bs(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!ne(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));let r=t;return Es.runKernel(Ke,r)}});var _o=Us({all_:function(e,t=null,n=!1){let r={x:Bs(e,"x","all","bool")},a={axis:t,keepDims:n};return Es.runKernel(Xe,r,a)}});var Co=Us({any_:function(e,t=null,n=!1){let r={x:Bs(e,"x","any","bool")},a={axis:t,keepDims:n};return Es.runKernel(Ye,r,a)}});var Eo=Us({argMax_:function(e,t=0){let n={x:Bs(e,"x","argMax")},r={axis:t};return Es.runKernel(Ze,n,r)}});var $o=Us({argMin_:function(e,t=0){let n={x:Bs(e,"x","argMin")},r={axis:t};return Es.runKernel(Je,n,r)}});var Ao=Us({asin_:function(e){let t={x:Bs(e,"x","asin")};return Es.runKernel(Qe,t)}});var Fo=Us({asinh_:function(e){let t={x:Bs(e,"x","asinh")};return Es.runKernel(et,t)}});var Ro=Us({atan_:function(e){let t={x:Bs(e,"x","atan")};return Es.runKernel(tt,t)}});var Do=Us({atan2_:function(e,t){let n=Bs(e,"a","atan2"),r=Bs(t,"b","atan2");[n,r]=ws(n,r);let a={a:n,b:r};return Es.runKernel(rt,a)}});var Mo=Us({atanh_:function(e){let t={x:Bs(e,"x","atanh")};return Es.runKernel(nt,t)}});function Oo(e,t,n,r,a="NHWC",s){return Po(e,[...t,e[3]],n,s,r,null,null,Xo(a))}function Lo(e,t,n,r,a,s,i="channelsLast"){let o,[l,u]=Vo(t);if("channelsLast"===i)o=[l,u,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);o=[l,u,e[1],e[1]]}return Po(e,o,n,r,a,s,!1,i)}function zo(e,t,n,r,a,s,i="NDHWC"){let o,l,[u,p,d]=Uo(t);if("NDHWC"===i)l="channelsLast",o=[u,p,d,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);l="channelsFirst",o=[u,p,d,e[1],e[1]]}return Bo(e,o,n,r,a,!1,l,s)}function Po(e,t,n,r,a,s,i=!1,o="channelsLast"){let[l,u,p,d]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,p,d]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,d,u,p]=e}let h,[c,f,,m]=t,[g,y]=Vo(n),[b,x]=Vo(r),w=Go(c,b),v=Go(f,x),{padInfo:k,outHeight:I,outWidth:S}=function(e,t,n,r,a,s,i,o,l){let u,p,d;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};let a=function(e,t,n,r,a){null==r&&(r=Wo(e,t,n));let s=e[0],i=e[1],o=Ho((s-t+2*r)/n+1,a),l=Ho((i-t+2*r)/n+1,a);return[o,l]}([t,n],s,r,e,o);p=a[0],d=a[1]}else if("same"===e){p=Math.ceil(t/r),d=Math.ceil(n/a);let e=Math.max(0,(p-1)*r+s-t),o=Math.max(0,(d-1)*a+i-n),l=Math.floor(e/2),h=e-l,c=Math.floor(o/2);u={top:l,bottom:h,left:c,right:o-c,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},p=Math.ceil((t-s+1)/r),d=Math.ceil((n-i+1)/a);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{let h="channelsLast"===l?e[1][0]:e[2][0],c="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:h,bottom:c,left:f,right:m,type:0===h&&0===c&&0===f&&0===m?"VALID":"EXPLICIT"},p=Ho((t-s+h+c)/r+1,o),d=Ho((n-i+f+m)/a+1,o)}}return{padInfo:u,outHeight:p,outWidth:d}}(a,u,p,g,y,w,v,s,o),N=i?m*d:m;return"channelsFirst"===o?h=[l,N,I,S]:"channelsLast"===o&&(h=[l,I,S,N]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:p,inChannels:d,outHeight:I,outWidth:S,outChannels:N,padInfo:k,strideHeight:g,strideWidth:y,filterHeight:c,filterWidth:f,effectiveFilterHeight:w,effectiveFilterWidth:v,dilationHeight:b,dilationWidth:x,inShape:e,outShape:h,filterShape:t}}function Bo(e,t,n,r,a,s=!1,i="channelsLast",o){let[l,u,p,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,p,d,h]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,h,u,p,d]=e}let c,[f,m,g,,y]=t,[b,x,w]=Uo(n),[v,k,I]=Uo(r),S=Go(f,v),N=Go(m,k),T=Go(g,I),{padInfo:_,outDepth:C,outHeight:E,outWidth:$}=function(e,t,n,r,a,s,i,o,l,u,p){let d,h,c,f;if("valid"===e&&(e=0),"number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};let m=function(e,t,n,r,a,s){null==a&&(a=Wo(e,t[0],r[0]));let i=[0,0,0,n];for(let n=0;n<3;n++)e[n]+2*a>=t[n]&&(i[n]=Ho((e[n]-t[n]+2*a)/r[n]+1,s));return i}([t,n,r,1],[o,l,u],1,[a,s,i],e,p);h=m[0],c=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{h=Math.ceil(t/a),c=Math.ceil(n/s),f=Math.ceil(r/i);let e=(h-1)*a+o-t,p=(c-1)*s+l-n,m=(f-1)*i+u-r,g=Math.floor(e/2),y=e-g,b=Math.floor(p/2),x=p-b,w=Math.floor(m/2);d={top:b,bottom:x,left:w,right:m-w,front:g,back:y,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:c,outWidth:f}}(a,u,p,d,b,x,w,S,N,T,o),A=s?y*h:y;return"channelsFirst"===i?c=[l,A,C,E,$]:"channelsLast"===i&&(c=[l,C,E,$,A]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:p,inWidth:d,inChannels:h,outDepth:C,outHeight:E,outWidth:$,outChannels:A,padInfo:_,strideDepth:b,strideHeight:x,strideWidth:w,filterDepth:f,filterHeight:m,filterWidth:g,effectiveFilterDepth:S,effectiveFilterHeight:N,effectiveFilterWidth:T,dilationDepth:v,dilationHeight:k,dilationWidth:I,inShape:e,outShape:c,filterShape:t}}function Wo(e,t,n,r=1){let a=Go(t,r);return Math.floor((e[0]*(n-1)-n+a)/2)}function Vo(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Uo(e){return"number"==typeof e?[e,e,e]:e}function Go(e,t){return t<=1?e:e+(e-1)*(t-1)}function Ho(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function jo(e){let[t,n,r]=Vo(e);return 1===t&&1===n&&1===r}function qo(e,t){return jo(e)||jo(t)}function Ko(e){return Vo(e).every((e=>e>0))}function Xo(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Yo(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)Y(re(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{Y(re(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}var Zo=Us({reshape_:function(e,t){let n={x:Bs(e,"x","reshape","string_or_numeric")},r={shape:t};return Es.runKernel(lr,n,r)}});var Jo=Us({avgPool_:function(e,t,n,r,a){let s=Bs(e,"x","avgPool","float32");Y(qo(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let i=s,o=!1;3===s.rank&&(o=!0,i=Zo(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Y(4===i.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`)),Yo("avgPool",r,a);let l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},p=Es.runKernel(at,l,u);return p=go(p,s.dtype),o?Zo(p,[p.shape[1],p.shape[2],p.shape[3]]):p}});var Qo=Us({avgPool3d_:function(e,t,n,r,a,s="NDHWC"){let i=Bs(e,"x","avgPool3d","float32"),o=i,l=!1;4===i.rank&&(l=!0,o=Zo(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Y(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),Y("NDHWC"===s,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),Y("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),Yo("avgPool3d",r,a);let u={x:o},p={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},d=Es.runKernel(it,u,p);return d=go(d,o.dtype),l?Zo(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});var el=Us({concat_:function(e,t=0){Y(e.length>=1,(()=>"Pass at least one tensor to concat"));let n=Ws(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return yo(n[0]);let r=n,a={axis:t};return Es.runKernel(xt,r,a)}});var tl=Us({matMul_:function(e,t,n=!1,r=!1){let a=Bs(e,"a","matMul"),s=Bs(t,"b","matMul");[a,s]=ws(a,s);let i={a:a,b:s},o={transposeA:n,transposeB:r};return Es.runKernel(lt,i,o)}});var nl=Us({sigmoid_:function(e){let t={x:Bs(e,"x","sigmoid","float32")};return Es.runKernel(Tr,t)}});var rl=Us({slice_:function(e,t,n){let r=Bs(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");let a={x:r},s={begin:t,size:n};return Es.runKernel(kr,a,s)}});var al=Us({tanh_:function(e){let t={x:Bs(e,"x","tanh","float32")};return Es.runKernel(qr,t)}});var sl=Us({basicLSTMCell_:function(e,t,n,r,a,s){let i=Bs(e,"forgetBias","basicLSTMCell"),o=Bs(t,"lstmKernel","basicLSTMCell"),l=Bs(n,"lstmBias","basicLSTMCell"),u=Bs(r,"data","basicLSTMCell"),p=Bs(a,"c","basicLSTMCell"),d=Bs(s,"h","basicLSTMCell"),h=el([u,d],1),c=tl(h,o),f=xo(c,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=rl(f,[0,0],y),x=rl(f,[0,g],y),w=rl(f,[0,2*g],y),v=rl(f,[0,3*g],y),k=xo(ko(nl(b),al(x)),ko(p,nl(xo(i,w))));return[k,ko(al(k),nl(v))]}});var il=Us({batchToSpaceND_:function(e,t,n){let r=Bs(e,"x","batchToSpaceND"),a=t.reduce(((e,t)=>e*t));Y(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),Y(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),Y(r.shape[0]%a==0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`));let s={x:r},i={blockShape:t,crops:n};return Es.runKernel(ut,s,i)}});function ol(e){let t;return t=0===e.rank||1===e.rank?Zo(e,[1,1,1,e.size]):2===e.rank?Zo(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Zo(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}var ll=Us({batchNorm_:function(e,t,n,r,a,s){null==s&&(s=.001);let i,o,l=Bs(e,"x","batchNorm"),u=Bs(t,"mean","batchNorm"),p=Bs(n,"variance","batchNorm");null!=a&&(i=Bs(a,"scale","batchNorm")),null!=r&&(o=Bs(r,"offset","batchNorm")),Y(u.rank===p.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Y(null==o||u.rank===o.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Y(null==i||u.rank===i.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let d={x:ol(l),scale:i,offset:o,mean:u,variance:p},h={varianceEpsilon:s},c=Es.runKernel(tn,d,h);return Zo(c,l.shape)}});var ul=Us({batchNorm2d_:function(e,t,n,r,a,s){let i,o,l=Bs(e,"x","batchNorm"),u=Bs(t,"mean","batchNorm"),p=Bs(n,"variance","batchNorm");return null!=a&&(i=Bs(a,"scale","batchNorm")),null!=r&&(o=Bs(r,"offset","batchNorm")),Y(2===l.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${l.rank}.`)),Y(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${u.rank}.`)),Y(2===p.rank||1===p.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${p.rank}.`)),null!=i&&Y(2===i.rank||1===i.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${i.rank}.`)),null!=o&&Y(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${o.rank}.`)),ll(l,u,p,o,i,s)}});var pl=Us({batchNorm3d_:function(e,t,n,r,a,s){let i,o,l=Bs(e,"x","batchNorm"),u=Bs(t,"mean","batchNorm"),p=Bs(n,"variance","batchNorm");return null!=a&&(i=Bs(a,"scale","batchNorm")),null!=r&&(o=Bs(r,"offset","batchNorm")),Y(3===l.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${l.rank}.`)),Y(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${u.rank}.`)),Y(3===p.rank||1===p.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${p.rank}.`)),null!=i&&Y(3===i.rank||1===i.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${i.rank}.`)),null!=o&&Y(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${o.rank}.`)),ll(l,u,p,o,i,s)}});var dl=Us({batchNorm4d_:function(e,t,n,r,a,s){let i,o,l=Bs(e,"x","batchNorm"),u=Bs(t,"mean","batchNorm"),p=Bs(n,"variance","batchNorm");return null!=a&&(i=Bs(a,"scale","batchNorm")),null!=r&&(o=Bs(r,"offset","batchNorm")),Y(4===l.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${l.rank}.`)),Y(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${u.rank}.`)),Y(4===p.rank||1===p.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${p.rank}.`)),null!=i&&Y(4===i.rank||1===i.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${i.rank}.`)),null!=o&&Y(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${o.rank}.`)),ll(l,u,p,o,i,s)}});var hl=Us({bincount_:function(e,t,n){let r=Bs(e,"x","bincount"),a=Bs(t,"weights","bincount");Y("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),Y(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Y(a.size===r.size||0===a.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`));let s={x:r,weights:a},i={size:n};return Es.runKernel(pt,s,i)}});var cl=Us({bitwiseAnd_:function(e,t){let n=Bs(e,"x","bitwiseAnd"),r=Bs(t,"y","bitwiseAnd");if(!ne(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);let a={a:n,b:r};return Es.runKernel(dt,a)}});var fl=Us({broadcastArgs_:function(e,t){let n=Bs(e,"s0","broadcastArgs","int32"),r=Bs(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let a={s0:n,s1:r};return Es.runKernel(ct,a)}});var ml=Us({broadcastTo_:function(e,t){let n=Bs(e,"broadcastTo","x"),r=n.shape;if(Fe(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Zo(n,e)}let a=n.shape,s=Array.from(t);for(let e=t.length-1;e>=0;e--)if(a[e]===t[e])s[e]=1;else if(1!==n.shape[e])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===s.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return yo(n);let i={x:n},o={reps:s};return Es.runKernel(Kr,i,o)}});var gl=Us({ceil_:function(e){let t={x:Bs(e,"x","ceil","float32")};return Es.runKernel(mt,t)}});function yl(e,t,n){Fe(e);let r={shape:e,value:t,dtype:n=n||ke(t)};return Es.runKernel(Zt,{},r)}var bl=Us({clipByValue_:function(e,t,n){let r=Bs(e,"x","clipByValue");if(Y(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return yl(r.shape,t,r.dtype);let a={x:r},s={clipValueMin:t,clipValueMax:n};return Es.runKernel(gt,a,s)}});var xl=Us({concat1d_:function(e){return el(e,0)}});var wl=Us({concat2d_:function(e,t){return el(e,t)}});var vl=Us({concat3d_:function(e,t){return el(e,t)}});var kl=Us({concat4d_:function(e,t){return el(e,t)}});var Il=Us({conv2d_:function(e,t,n,r,a="NHWC",s=[1,1],i){let o=Bs(e,"x","conv2d","float32"),l=Bs(t,"filter","conv2d","float32"),u=o,p=!1;3===o.rank&&(p=!0,u=Zo(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Y(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),Y(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),Yo("conv2d",r,i);let d="NHWC"===a?u.shape[3]:u.shape[1];Y(d===l.shape[2],(()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`)),Y(qo(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),Y(Ko(s),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),Y(Ko(n),(()=>"Error in conv2D: Strides should be larger than 0."));let h={x:u,filter:l},c={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=Es.runKernel(wt,h,c);return p?Zo(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var Sl=Us({conv1d_:function(e,t,n,r,a="NWC",s=1,i){let o=Bs(e,"x","conv1d"),l=Bs(t,"filter","conv1d"),u=o,p=!1;2===o.rank&&(p=!0,u=Zo(o,[1,o.shape[0],o.shape[1]])),Y(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),Y(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),Yo("conv1d",r,i),Y(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),Y(qo(n,s),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`)),Y(Ko(s),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),Y(Ko(n),(()=>"Error in conv1D: Stride should be larger than 0.")),Y("NWC"===a,(()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`));let d=Zo(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=Zo(u,[u.shape[0],1,u.shape[1],u.shape[2]]),c=Il(h,d,[1,n],r,"NHWC",[1,s],i);return Zo(c,p?[c.shape[2],c.shape[3]]:[c.shape[0],c.shape[2],c.shape[3]])}});var Nl=Us({conv2DBackpropInput_:function(e,t,n,r,a,s="NHWC",i){Y(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=Zo(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),Y(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),Y(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),Y(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));let p="NHWC"===s?o[3]:o[1],d="NHWC"===s?l.shape[3]:l.shape[1];Y(p===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${p}) must match input depth for filter ${n.shape[2]}.`)),Y(d===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`)),Yo("conv2dDerInput",a,i);let h={dy:l,filter:n},c={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,inputShape:o},f=Es.runKernel(kt,h,c);return u?Zo(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var Tl=Us({conv2dTranspose_:function(e,t,n,r,a,s){let i=Bs(e,"x","conv2dTranspose"),o=Bs(t,"filter","conv2dTranspose");return Nl(n,i,o,r,a,"NHWC",s)}});var _l=Us({conv3d_:function(e,t,n,r,a="NDHWC",s=[1,1,1]){let i=Bs(e,"x","conv3d"),o=Bs(t,"filter","conv3d"),l=i,u=!1;4===i.rank&&(u=!0,l=Zo(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Y(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),Y(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),Y(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),Y(qo(n,s),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),Y("NDHWC"===a,(()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`)),Y(Ko(s),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),Y(Ko(n),(()=>"Error in conv3D: Strides should be larger than 0."));let p={x:l,filter:o},d={strides:n,pad:r,dataFormat:a,dilations:s},h=Es.runKernel(It,p,d);return u?Zo(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});var Cl=Us({conv3DBackpropInput_:function(e,t,n,r,a){Y(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let s=e,i=t,o=!1;4===t.rank&&(o=!0,i=Zo(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],u=i.shape[4];Y(5===s.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`)),Y(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),Y(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),Y(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),Y(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));let p={dy:i,filter:n},d={pad:a,strides:r,inputShape:s},h=Es.runKernel(Nt,p,d);return o?Zo(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});var El=Us({conv3dTranspose_:function(e,t,n,r,a){let s=Bs(e,"x","conv3dTranspose"),i=Bs(t,"filter","conv3dTranspose");return Cl(n,s,i,r,a)}});var $l=Us({cos_:function(e){let t={x:Bs(e,"x","cos","float32")};return Es.runKernel(Tt,t)}});var Al=Us({cosh_:function(e){let t={x:Bs(e,"x","cosh","float32")};return Es.runKernel(_t,t)}});var Fl=Us({cumprod_:function(e,t=0,n=!1,r=!1){let a={x:Bs(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:r};return Es.runKernel(Ct,a,s)}});var Rl=Us({cumsum_:function(e,t=0,n=!1,r=!1){let a={x:Bs(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:r};return Es.runKernel(Et,a,s)}});var Dl=Us({denseBincount_:function(e,t,n,r=!1){let a=Bs(e,"x","denseBincount"),s=Bs(t,"weights","denseBincount");Y("int32"===a.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`)),Y(a.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`)),Y(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Y(s.size===a.size||0===s.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`));let i={x:a,weights:s},o={size:n,binaryOutput:r};return Es.runKernel(At,i,o)}});var Ml=Us({depthToSpace_:function(e,t,n="NHWC"){let r=Bs(e,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];Y(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),Y(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),Y(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),Y(i%(t*t)==0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));let o={x:r},l={blockSize:t,dataFormat:n};return Es.runKernel(Ft,o,l)}});var Ol=Us({depthwiseConv2d_:function(e,t,n,r,a="NHWC",s=[1,1],i){let o=Bs(e,"x","depthwiseConv2d","float32"),l=Bs(t,"filter","depthwiseConv2d","float32"),u=o,p=!1;3===o.rank&&(p=!0,u=Zo(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Y(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),Y(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));let d="NHWC"===a?u.shape[3]:u.shape[1];Y(d===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`)),Yo("depthwiseConv2d",r,i);let h={x:u,filter:l},c={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=Es.runKernel(Rt,h,c);return p?Zo(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var Ll=Us({diag_:function(e){let t={x:Bs(e,"x","diag")};return Es.runKernel(Ot,t)}});var zl=Us({dilation2d_:function(e,t,n,r,a=[1,1],s="NHWC"){let i=Bs(e,"x","dilation2d"),o=Bs(t,"filter","dilation2d");Y(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),Y(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),Y("NHWC"===s,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`));let l=i,u=!1;3===i.rank&&(l=Zo(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),Y(l.shape[3]===o.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`));let p={x:l,filter:o},d={strides:n,pad:r,dilations:a},h=Es.runKernel(Lt,p,d);return u?Zo(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Pl={};function Bl(e,t){let n=e.length,r=[];for(let a=0;a<n;a++){let s=n-1-a,i=e[s]||1;(t[t.length-1-a]||1)>1&&1===i&&r.unshift(s)}return r}function Wl(e,t){let n=[];for(let r=0;r<t.length;r++){let a=e[e.length-r-1],s=t.length-r-1,i=t[s];(null==a||1===a&&i>1)&&n.unshift(s)}return n}function Vl(e,t){let n=Math.max(e.length,t.length),r=new Array(n);for(let a=0;a<n;a++){let s=e[e.length-a-1];null==s&&(s=1);let i=t[t.length-a-1];if(null==i&&(i=1),1===s)r[n-a-1]=i;else if(1===i)r[n-a-1]=s;else{if(s!==i){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}r[n-a-1]=s}}return r}g(Pl,{assertAndGetBroadcastShape:()=>Vl,getBroadcastDims:()=>Bl,getReductionAxes:()=>Wl});var Ul=Us({equal_:function(e,t){let n=Bs(e,"a","equal","string_or_numeric"),r=Bs(t,"b","equal","string_or_numeric");[n,r]=ws(n,r),Vl(n.shape,r.shape);let a={a:n,b:r};return Es.runKernel(jt,a)}});var Gl=Us({where_:function(e,t,n){let r=Bs(t,"a","where"),a=Bs(n,"b","where"),s=Bs(e,"condition","where","bool"),i=Vl(Vl(s.shape,r.shape),a.shape),o={condition:ml(s,i),t:ml(r,i),e:ml(a,i)};return Es.runKernel(wr,o)}});var Hl=Us({zerosLike_:function(e){let t={x:Bs(e,"x","zerosLike")};return Es.runKernel(na,t)}});var jl=Us({divNoNan_:function(e,t){let n=Bs(e,"a","div"),r=Bs(t,"b","div");[n,r]=ws(n,r);let a=vo(n,r),s=Hl(a),i=Ul(r,s);return Gl(i,s,a)}});var ql=Us({dot_:function(e,t){let n=Bs(e,"t1","dot"),r=Bs(t,"t2","dot");Y(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));let a=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(Y(a===s,(()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`)),1===n.rank&&1===r.rank){let e=Zo(n,[1,-1]),t=Zo(r,[-1,1]),a=tl(e,t);return Zo(a,[])}if(1===n.rank&&2===r.rank){let e=Zo(n,[1,-1]),t=Zo(r,[r.shape[0],r.shape[1]]),a=tl(e,t);return Zo(a,[a.size])}if(2===n.rank&&1===r.rank){let e=Zo(r,[-1,1]),t=tl(n,e);return Zo(t,[t.size])}{let e=Zo(r,[r.shape[0],r.shape[1]]);return tl(n,e)}}});var Kl=Us({einsum_:function(e,...t){let n=t.map(((e,t)=>Bs(e,`tensors${t}`,"einsum"))),r={equation:e};return Es.runKernel(Vt,n,r)}});var Xl=Us({elu_:function(e){let t={x:Bs(e,"x","elu","float32")};return Es.runKernel(Ut,t)}});var Yl=Us({ensureShape_:function(e,t){let n=Bs(e,"x","ensureShape","string_or_numeric");if(!te(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}});var Zl=Us({erf_:function(e){let t=Bs(e,"x","erf");Y("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=go(t,"float32"));let n={x:t};return Es.runKernel(Ht,n)}});function Jl(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Ql(e,t,n){let r=e.length+t.length,a=[],s=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?a.push(e[s++]):a.push(t[i++]);return a}function eu(e,t){let n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map((t=>e[t]))]}function tu(e,t){return Ql(e,t.map((e=>1)),t)}function nu(e,t,n){Y(Jl(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function ru(e,t){if(Jl(e,t))return null;let n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function au(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function su(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}var iu=Us({max_:function(e,t=null,n=!1){let r={x:Bs(e,"x","max")},a={reductionIndices:t,keepDims:n};return Es.runKernel(Cn,r,a)}});var ou=Us({min_:function(e,t=null,n=!1){let r={x:Bs(e,"x","min")},a={axis:t,keepDims:n};return Es.runKernel(On,r,a)}});var lu=Us({pow_:function(e,t){let n=Bs(e,"base","pow"),r=Bs(t,"exp","pow");[n,r]=ws(n,r);let a={a:n,b:r};return Es.runKernel(Jn,a)}});function uu(e,t){if((Ga(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Ga(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Hs(e,[],[],t)}var pu=Us({sqrt_:function(e){let t={x:Bs(e,"x","sqrt","float32")};return Es.runKernel(Cr,t)}});var du=Us({square_:function(e){let t=Bs(e,"x","square");return Es.runKernel("Square",{x:t},{})}});var hu=Us({sum_:function(e,t=null,n=!1){let r=Bs(e,"x","sum");"bool"===r.dtype&&(r=go(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return Es.runKernel(Er,a,s)}});function cu(e,t,n=null){if(0===e.rank)return Io(e);if(1!==e.rank&&null===n)return cu(Zo(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return hu(Io(e),n);if(t===1/0)return iu(Io(e),n);if(t===-1/0)return ou(Io(e),n);if("euclidean"===t||2===t)return pu(hu(lu(Io(e),uu(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return iu(hu(Io(e),n[0]),n[1]-1);if(t===1/0)return iu(hu(Io(e),n[1]),n[0]);if(t===-1/0)return ou(hu(Io(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return pu(hu(du(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var fu=Us({norm_:function(e,t="euclidean",n=null,r=!1){let a=cu(e=Bs(e,"x","norm"),t,n),s=a.shape;if(r){let t=pe(n,e.shape);s=tu(a.shape,t)}return Zo(a,s)}});var mu=Us({euclideanNorm_:function(e,t=null,n=!1){return fu(e,"euclidean",t,n)}});var gu=Us({exp_:function(e){let t={x:Bs(e,"x","exp")};return Es.runKernel(qt,t)}});var yu=Us({expandDims_:function(e,t=0){let n=Bs(e,"x","expandDims","string_or_numeric");Y(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));let r={input:n},a={dim:t};return Es.runKernel(Kt,r,a)}});var bu=Us({expm1_:function(e){let t={x:Bs(e,"x","expm1")};return Es.runKernel(Xt,t)}});var xu=Us({tile_:function(e,t){let n=Bs(e,"x","tile","string_or_numeric");Y(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));let r={x:n},a={reps:t};return Es.runKernel(Kr,r,a)}});var wu=Us({eye_:function(e,t,n,r="float32"){null==t&&(t=e);let a=mo([e,t],r),s=e<=t?e:t;for(let e=0;e<s;++e)a.set(1,e,e);let i=Zo(a.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return xu(yu(i,0),[n[0],1,1]);if(2===n.length)return xu(yu(yu(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return xu(yu(yu(yu(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});var vu=Us({floor_:function(e){let t={x:Bs(e,"x","floor","float32")};return Es.runKernel(Qt,t)}});var ku=Us({gather_:function(e,t,n=0,r=0){let a={x:Bs(e,"x","gather"),indices:Bs(t,"indices","gather","int32")},s={axis:n,batchDims:r};return Es.runKernel(nn,a,s)}});var Iu=Us({greater_:function(e,t){let n=Bs(e,"a","greater","string_or_numeric"),r=Bs(t,"b","greater","string_or_numeric");[n,r]=ws(n,r),Vl(n.shape,r.shape);let a={a:n,b:r};return Es.runKernel(an,a)}});var Su=Us({greaterEqual_:function(e,t){let n=Bs(e,"a","greaterEqual","string_or_numeric"),r=Bs(t,"b","greaterEqual","string_or_numeric");[n,r]=ws(n,r),Vl(n.shape,r.shape);let a={a:n,b:r};return Es.runKernel(sn,a)}});var Nu=Us({imag_:function(e){let t={input:Bs(e,"input","imag")};return Es.runKernel(un,t)}});var Tu=Us({isFinite_:function(e){let t={x:Bs(e,"x","isFinite")};return Es.runKernel(pn,t)}});var _u=Us({isInf_:function(e){let t={x:Bs(e,"x","isInf")};return Es.runKernel(dn,t)}});var Cu=Us({isNaN_:function(e){let t={x:Bs(e,"x","isNaN")};return Es.runKernel(hn,t)}});var Eu=Us({leakyRelu_:function(e,t=.2){let n={x:Bs(e,"x","leakyRelu")},r={alpha:t};return Es.runKernel(cn,n,r)}});var $u=Us({less_:function(e,t){let n=Bs(e,"a","less","string_or_numeric"),r=Bs(t,"b","less","string_or_numeric");[n,r]=ws(n,r),Vl(n.shape,r.shape);let a={a:n,b:r};return Es.runKernel(fn,a)}});var Au=Us({lessEqual_:function(e,t){let n=Bs(e,"a","lessEqual","string_or_numeric"),r=Bs(t,"b","lessEqual","string_or_numeric");[n,r]=ws(n,r),Vl(n.shape,r.shape);let a={a:n,b:r};return Es.runKernel(mn,a)}});function Fu(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return Es.runKernel(gn,{},r)}var Ru=Us({localResponseNormalization_:function(e,t=5,n=1,r=1,a=.5){let s=Bs(e,"x","localResponseNormalization");Y(4===s.rank||3===s.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`)),Y(re(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=s,o=!1;3===s.rank&&(o=!0,i=Zo(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:a},p=Es.runKernel(Nn,l,u);return o?Zo(p,[p.shape[1],p.shape[2],p.shape[3]]):p}});var Du=Us({log_:function(e){let t={x:Bs(e,"x","log","float32")};return Es.runKernel(yn,t)}});var Mu=Us({log1p_:function(e){let t={x:Bs(e,"x","log1p")};return Es.runKernel(bn,t)}});function Ou(e){return Y(Ie(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{let r=Bs(t,"x","tf.grad","string_or_numeric"),a=null!=n?Bs(n,"dy","tf.grad"):null;return Es.tidy((()=>{let{value:t,grads:n}=Es.gradients((()=>e(r)),[r],a);return null!=a&&Z(t.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Vu(n),n[0]}))}}function Lu(e){return Y(Ie(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{Y(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));let r=Ws(t,"args","tf.grads","string_or_numeric"),a=null!=n?Bs(n,"dy","tf.grads"):null;return Es.tidy((()=>{let{value:t,grads:n}=Es.gradients((()=>e(...r)),r,a);return null!=a&&Z(t.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Vu(n),n}))}}function zu(e){return Y(Ie(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{Y(t instanceof is,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),Y(null==n||n instanceof is,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));let{grads:r,value:a}=Es.gradients((()=>e(t)),[t],n);return Vu(r),{grad:r[0],value:a}}}function Pu(e){return Y(Ie(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{Y(Array.isArray(t)&&t.every((e=>e instanceof is)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),Y(null==n||n instanceof is,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));let r=Es.gradients((()=>e(...t)),t,n);return null!=n&&Z(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Vu(r.grads),r}}function Bu(e,t){Y(Ie(e),(()=>"The f passed in variableGrads(f) must be a function")),Y(null==t||Array.isArray(t)&&t.every((e=>e instanceof ls)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));let n=null!=t;if(!n){t=[];for(let e in Es.registeredVariables)t.push(Es.registeredVariables[e])}let r=n?t.filter((e=>!e.trainable)):null,a=t.length;Y((t=t.filter((e=>e.trainable))).length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`));let{value:s,grads:i}=Es.gradients(e,t,null,!0);Y(i.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Y(0===s.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`));let o={};return t.forEach(((e,t)=>{null!=i[t]&&(o[e.name]=i[t])})),null!=r&&r.forEach((e=>o[e.name]=null)),{value:s,grads:o}}function Wu(e){return Es.customGrad(e)}function Vu(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}var Uu=Us({neg_:function(e){let t={x:Bs(e,"x","neg")};return Es.runKernel(Vn,t)}});var Gu=Us({softplus_:function(e){let t={x:Bs(e,"x","softplus")};return Es.runKernel(_r,t)}});var Hu=Us({logSigmoid_:function(e){let t=Bs(e,"x","logSigmoid");return Wu((e=>({value:Uu(Gu(Uu(e))),gradFunc:t=>ko(t,nl(Uu(e)))})))(t)}});var ju=Us({sub_:function(e,t){let n=Bs(e,"a","sub"),r=Bs(t,"b","sub");[n,r]=ws(n,r);let a={a:n,b:r};return Es.runKernel(Hr,a)}});var qu=Us({logSoftmax_:function(e,t=-1){let n=Bs(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Wu(((e,n)=>{let r=iu(e,t,!0),a=ju(e,r),s=ju(go(a,"float32"),Du(hu(gu(a),t,!0)));return n([s]),{value:s,gradFunc:(e,n)=>{let[r]=n,a=gu(r);return ju(e,ko(hu(e,t,!0),a))}}}))(n)}});var Ku=Us({logSumExp_:function(e,t=null,n=!1){let r=Bs(e,"x","logSumExp"),a=pe(t,r.shape),s=iu(r,a,!0),i=ju(r,s),o=gu(i),l=hu(o,a),u=Du(l),p=xo(Zo(s,u.shape),u);if(n){let e=tu(p.shape,a);return Zo(p,e)}return p}});var Xu=Us({logicalAnd_:function(e,t){let n=Bs(e,"a","logicalAnd","bool"),r=Bs(t,"b","logicalAnd","bool");Vl(n.shape,r.shape);let a={a:n,b:r};return Es.runKernel(xn,a)}});var Yu=Us({logicalNot_:function(e){let t={x:Bs(e,"x","logicalNot","bool")};return Es.runKernel(wn,t)}});var Zu=Us({logicalOr_:function(e,t){let n=Bs(e,"a","logicalOr","bool"),r=Bs(t,"b","logicalOr","bool");Vl(n.shape,r.shape);let a={a:n,b:r};return Es.runKernel(vn,a)}});var Ju=Us({logicalXor_:function(e,t){let n=Bs(e,"a","logicalXor","bool"),r=Bs(t,"b","logicalXor","bool");return Vl(n.shape,r.shape),Xu(Zu(e,t),Yu(Xu(e,t)))}}),Qu=2147483648;var ep=Us({searchSorted_:function(e,t,n="left"){let r=Bs(e,"sortedSequence","searchSorted"),a=Bs(t,"values","searchSorted"),s=r.shape[r.shape.length-1],i=a.shape[a.shape.length-1],o=Zo(r,[-1,s]),l=Zo(a,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Q(l.shape)>=Qu)throw new Error(`values tensor size must less than ${Qu}`);if(o.shape[1]>=Qu)throw new Error(`trailing dim_size must less than ${Qu} for int32 output type, was ${o.shape[1]}`);let u={sortedSequence:o,values:l},p={side:n};return Es.runKernel(xr,u,p)}});function tp(e,t){return ep(e,t,"left")}var np=Us({maxPool_:function(e,t,n,r,a){let s=Bs(e,"x","maxPool"),i=s,o=!1;3===s.rank&&(o=!0,i=Zo(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Y(4===i.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`)),Y(qo(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),Yo("maxPool",r,a);let l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},p=Es.runKernel($n,l,u);return o?Zo(p,[p.shape[1],p.shape[2],p.shape[3]]):p}});var rp=Us({maxPool3d_:function(e,t=[1,1,1],n,r,a,s="NDHWC"){let i=Bs(e,"x","maxPool3d"),o=i,l=!1;4===i.rank&&(l=!0,o=Zo(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Y(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),Y("NDHWC"===s,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),Yo("maxPool3d",r,a);let u={x:o},p={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},d=Es.runKernel(Fn,u,p);return l?Zo(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});var ap=Us({maxPoolWithArgmax_:function(e,t,n,r,a=!1){let s={x:Bs(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:a},o=Es.runKernel(Dn,s,i);return{result:o[0],indexes:o[1]}}});var sp=Us({maximum_:function(e,t){let n=Bs(e,"a","maximum"),r=Bs(t,"b","maximum");[n,r]=ws(n,r),"bool"===n.dtype&&(n=go(n,"int32"),r=go(r,"int32")),Vl(n.shape,r.shape);let a={a:n,b:r};return Es.runKernel(En,a)}});var ip=Us({mean_:function(e,t=null,n=!1){let r={x:Bs(e,"x","mean")},a={axis:t,keepDims:n};return Es.runKernel(Mn,r,a)}});function op(e,t="float32"){if(Fe(e),"complex64"===t){let t=op(e,"float32"),n=op(e,"float32");return Gs(t,n)}let n=$e(Q(e),t);return Es.makeTensor(n,e,t)}function lp(e,t="float32"){if(Fe(e),"complex64"===t){let t=lp(e,"float32"),n=op(e,"float32");return Gs(t,n)}let n=Ee(Q(e),t);return Es.makeTensor(n,e,t)}function up(e,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=Bs(e,"x","meshgrid",e instanceof is?e.dtype:"float32");if(void 0===t)return[r];let a=Bs(t,"y","meshgrid",t instanceof is?t.dtype:"float32"),s=Q(r.shape),i=Q(a.shape);return"xy"===n?(r=Zo(r,[1,-1]),a=Zo(a,[-1,1]),[tl(lp([i,1],r.dtype),r),tl(a,lp([1,s],a.dtype))]):(r=Zo(r,[-1,1]),a=Zo(a,[1,-1]),[tl(r,lp([1,i],r.dtype)),tl(lp([s,1],a.dtype),a)])}var pp=Us({minimum_:function(e,t){let n=Bs(e,"a","minimum"),r=Bs(t,"b","minimum");[n,r]=ws(n,r),"bool"===n.dtype&&(n=go(n,"int32"),r=go(r,"int32")),Vl(n.shape,r.shape);let a={a:n,b:r};return Es.runKernel(Ln,a)}});var dp=Us({mirrorPad_:function(e,t,n){Y("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));let r=Bs(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Y(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));let a="reflect"===n?1:0;for(let e=0;e<r.rank;e++)Y(2===t[e].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Y(t[e][0]>=0&&t[e][0]<=r.shape[e]-a&&t[e][1]>=0&&t[e][1]<=r.shape[e]-a,(()=>`Padding in dimension ${e} cannot be greater than or equal to ${r.shape[e]-a} or less than 0 for input of shape ${r.shape}`));let s={paddings:t,mode:n},i={x:r};return Es.runKernel(zn,i,s)}});var hp=Us({mod_:function(e,t){let n=Bs(e,"a","mod"),r=Bs(t,"b","mod");[n,r]=ws(n,r);let a={a:n,b:r};return Es.runKernel(Pn,a)}});var cp=Us({moments_:function(e,t=null,n=!1){let r=pe(t,(e=Bs(e,"x","moments")).shape),a=ip(e,r,n),s=a.shape;n||(s=tu(a.shape,r));let i=du(ju(go(e,"float32"),Zo(a,s)));return{mean:a,variance:ip(i,r,n)}}});var fp=Us({multiRNNCell_:function(e,t,n,r){let a=Bs(t,"data","multiRNNCell"),s=Ws(n,"c","multiRNNCell"),i=Ws(r,"h","multiRNNCell"),o=a,l=[];for(let t=0;t<e.length;t++){let n=e[t](o,s[t],i[t]);l.push(n[0]),l.push(n[1]),o=n[1]}let u=[],p=[];for(let e=0;e<l.length;e+=2)u.push(l[e]),p.push(l[e+1]);return[u,p]}});var mp=Us({multinomial_:function(e,t,n,r=!1){let a=Bs(e,"logits","multinomial"),s=a.size,i=a.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:1===i?Zo(a,[1,-1]):a},l={numSamples:t,seed:n,normalized:r},u=Es.runKernel(Bn,o,l);return 1===i?Zo(u,[u.size]):u}});var gp=Us({notEqual_:function(e,t){let n=Bs(e,"a","notEqual","string_or_numeric"),r=Bs(t,"b","notEqual","string_or_numeric");[n,r]=ws(n,r),Vl(n.shape,r.shape);let a={a:n,b:r};return Es.runKernel(Un,a)}});var yp=Us({oneHot_:function(e,t,n=1,r=0,a="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:Bs(e,"indices","oneHot","int32")},i={dtype:a,depth:t,onValue:n,offValue:r};return Es.runKernel(Kn,s,i)}});var bp=Us({onesLike_:function(e){let t={x:Bs(e,"x","onesLike")};return Es.runKernel(qn,t)}});var xp=Us({outerProduct_:function(e,t){let n=Bs(e,"v1","outerProduct"),r=Bs(t,"v2","outerProduct");Y(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));let a=Zo(n,[-1,1]),s=Zo(r,[1,-1]);return tl(a,s)}});var wp=Us({pad_:function(e,t,n=0){let r=Bs(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let a={paddings:t,constantValue:n},s={x:r};return Es.runKernel(Yn,s,a)}});var vp=Us({pad1d_:function(e,t,n=0){return Y(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),wp(e,[t],n)}});var kp=Us({pad2d_:function(e,t,n=0){return Y(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),wp(e,t,n)}});var Ip=Us({pad3d_:function(e,t,n=0){return Y(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),wp(e,t,n)}});var Sp=Us({pad4d_:function(e,t,n=0){return Y(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),wp(e,t,n)}});var Np=Us({spaceToBatchND_:function(e,t,n){let r=Bs(e,"x","spaceToBatchND");Y(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),Y(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),Y(r.shape.reduce(((e,r,a)=>a>0&&a<=t.length?e&&(r+n[a-1][0]+n[a-1][1])%t[a-1]==0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));let a={x:r},s={blockShape:t,paddings:n};return Es.runKernel($r,a,s)}});var Tp=Us({pool_:function(e,t,n,r,a,s,i){null==a&&(a=[1,1]),null==s&&(s=1),0===r&&(r="valid");let o=Bs(e,"x","maxPool"),l=o,u=!1;3===o.rank&&(u=!0,l=Zo(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Y(qo(s,a),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`));let p,d=Lo(l.shape,t,s,a,r),h=[d.dilationHeight,d.dilationWidth];p="same"===r?function(e,t){let n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),r=n.map((e=>Math.floor(e/2))),a=n.map(((e,t)=>e-r[t]));return n.map(((e,t)=>[r[t],a[t]]))}([d.filterHeight,d.filterWidth],h):[[0,0],[0,0]];let c=1===h[0]&&1===h[1],[f,m]=function(e,t,n){let r=n.map((e=>e[0])),a=n.map((e=>e[1])),s=e.concat(r,a),i=t.map(((e,t)=>(e-s[t]%e)%e)),o=a.map(((e,t)=>e+i[t])),l=t.map(((e,t)=>[r[t],o[t]])),u=t.map(((e,t)=>[0,i[t]]));return[l,u]}([d.inHeight,d.inWidth],h,p),g=c?r:"valid",y=c?l:Np(l,h,f),b=("avg"===n?()=>Jo(y,t,s,g,i):()=>np(y,t,s,g,i))(),x=c?b:il(b,h,m);return u?Zo(x,[x.shape[1],x.shape[2],x.shape[3]]):x}});var _p=Us({prelu_:function(e,t){let n={x:Bs(e,"x","prelu"),alpha:Bs(t,"alpha","prelu")};return Es.runKernel(Qn,n)}});var Cp=Us({prod_:function(e,t=null,n=!1){let r=Bs(e,"x","prod");"bool"===r.dtype&&(r=go(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return Es.runKernel(er,a,s)}});var Ep=Us({raggedGather_:function(e,t,n,r){let a={paramsNestedSplits:e.map(((e,t)=>Bs(e,`tensors${t}`,"raggedGather","int32"))),paramsDenseValues:Bs(t,"paramsDenseValues","raggedGather"),indices:Bs(n,"indices","raggedGather","int32")},s={outputRaggedRank:r},i=Es.runKernel(tr,a,s);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}});var $p=Us({raggedRange_:function(e,t,n){let r=Bs(e,"starts","raggedRange"),a={starts:r,limits:Bs(t,"limits","raggedRange",r.dtype),deltas:Bs(n,"deltas","raggedRange",r.dtype)},s=Es.runKernel(nr,a);return{rtNestedSplits:s[0],rtDenseValues:s[1]}}});var Ap=Us({raggedTensorToTensor_:function(e,t,n,r,a){let s=Bs(e,"shape","raggedTensorToTensor","int32"),i=Bs(t,"values","raggedTensorToTensor"),o={shape:s,values:i,defaultValue:Bs(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:r.map(((e,t)=>Bs(e,`tensors${t}`,"raggedTensorToTensor","int32")))},l={rowPartitionTypes:a};return Es.runKernel(rr,o,l)}});var Fp=Us({rand_:function(e,t,n){Fe(e);let r=Q(e),a=null;if(null==n||"float32"===n)a=new Float32Array(r);else if("int32"===n)a=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);a=new Uint8Array(r)}for(let e=0;e<r;e++)a[e]=t();return Es.makeTensor(a,e,n)}}),Rp=y(E()),Dp={};g(Dp,{TEST_EPSILON_FLOAT16:()=>Op,createVideoElement:()=>qp,encodeStrings:()=>jp,expectArrayBuffersEqual:()=>Hp,expectArraysClose:()=>Lp,expectArraysEqual:()=>Wp,expectNumbersClose:()=>Vp,expectPromiseToFail:()=>Bp,expectValuesInRange:()=>Gp,play:()=>Kp,testEpsilon:()=>zp});var Mp=.001,Op=.1;function Lp(e,t,n){return null==n&&(n=zp()),Pp(e,t,((e,t)=>Up(e,t,n)))}function zp(){return 32===Es.backend.floatPrecision()?Mp:Op}function Pp(e,t,n){let r=!0;if((Ga(e)||Ga(t))&&(r=!1),Ga(e)&&Ga(t)&&(r=!0),r){let n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){let n=Ls(e),r=Ls(t);if(!ne(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}let a=Ga(e)?e:Ha(e),s=Ga(t)?t:Ha(t);if(a.length!==s.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${s.length}.\nActual:   ${a}.\nExpected: ${s}.`);for(let e=0;e<s.length;++e){let t=a[e],r=s[e];if(!n(t,r))throw new Error(`Arrays differ: actual[${e}] = ${t}, expected[${e}] = ${r}.\nActual:   ${a}.\nExpected: ${s}.`)}"undefined"!=typeof expect&&expect().nothing()}function Bp(e,t){e().then((()=>t.fail()),(()=>t())),"undefined"!=typeof expect&&expect().nothing()}function Wp(e,t){let n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return xe(e)||xe(e[0])||xe(t)||xe(t[0])?Pp(e,n,((e,t)=>e==t)):Pp(e,t,((e,t)=>Up(e,t,0)))}function Vp(e,t,n){if(null==n&&(n=zp()),!Up(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);"undefined"!=typeof expect&&expect().nothing()}function Up(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function Gp(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function Hp(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let e=0;e<r.length;e++)if(n[e]!==r[e])throw new Error(`Expected ArrayBuffer value at ${e} to be ${r[e]} but got ${n[e]} instead`)}function jp(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?jp(n):e[t]=Va(n)}return e}function qp(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise((e=>{t.addEventListener("loadeddata",(n=>e(t))),t.load()}))}async function Kp(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise((t=>{e.requestVideoFrameCallback(t)}))}var Xp=class{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);let s=a||Math.random();this.random=Rp.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},Yp=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let a=r||Math.random();this.randu=Rp.alea(a.toString()),this.randn=new Xp(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,s;for(;;){do{r=this.randn.nextValue(),s=1+this.c*r}while(s<=0);if(s*=s*s,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),a=this.randu(),a<t||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}},Zp=class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Rp.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};var Jp=Us({randomGamma_:function(e,t,n=1,r="float32",a){if(Fe(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);let s=new Yp(t,n,r,a),i=mo(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=s.nextValue();return i.toTensor()}});var Qp=Us({randomNormal_:function(e,t=0,n=1,r,a){if(Fe(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);let s=new Xp(t,n,r,!1,a),i=mo(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=s.nextValue();return i.toTensor()}});var ed=Us({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return Qp(e,0,1,t,n)}});var td=Us({randomUniform_:function(e,t=0,n=1,r="float32",a){Fe(e);let s=mo(e,r),i=new Zp(t,n,null,a);for(let e=0;e<s.values.length;e++)s.values[e]=i.nextValue();return s.toTensor()}});var nd=Us({randomUniformInt_:function(e,t,n,r){return td(e,t,n,"int32",r)}});function rd(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");let a={start:e,stop:t,step:n,dtype:r};return Es.runKernel(ar,{},a)}var ad=Us({real_:function(e){let t={input:Bs(e,"input","real")};return Es.runKernel(sr,t)}});var sd=Us({reciprocal_:function(e){let t={x:Bs(e,"x","reciprocal")};return Es.runKernel(ir,t)}});var id=Us({relu_:function(e){let t={x:Bs(e,"x","relu")};return Es.runKernel(or,t)}});var od=Us({relu6_:function(e){let t={x:Bs(e,"x","relu6")};return Es.runKernel(cr,t)}});var ld=Us({reverse_:function(e,t){let n={x:Bs(e,"x","reverse")},r={dims:t};return Es.runKernel(fr,n,r)}});var ud=Us({reverse1d_:function(e){let t=Bs(e,"x","reverse");return Y(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),ld(t,0)}});var pd=Us({reverse2d_:function(e,t){let n=Bs(e,"x","reverse");return Y(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),ld(n,t)}});var dd=Us({reverse3d_:function(e,t){let n=Bs(e,"x","reverse");return Y(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),ld(n,t)}});var hd=Us({reverse4d_:function(e,t){let n=Bs(e,"x","reverse");return Y(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),ld(n,t)}});var cd=Us({round_:function(e){let t={x:Bs(e,"x","round")};return Es.runKernel(mr,t)}});var fd=Us({rsqrt_:function(e){let t={x:Bs(e,"x","rsqrt","float32")};return Es.runKernel(gr,t)}});var md=Us({selu_:function(e){let t={x:Bs(e,"x","selu")};return Es.runKernel(vr,t)}});var gd=Us({separableConv2d_:function(e,t,n,r,a,s=[1,1],i="NHWC"){let o=Bs(e,"x","separableConv2d"),l=Bs(t,"depthwiseFilter","separableConv2d"),u=Bs(n,"pointwiseFilter","separableConv2d"),p=o,d=!1;if(3===o.rank&&(d=!0,p=Zo(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Y(4===p.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${p.rank}.`)),Y(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),Y(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),Y(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),Y(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));let h=l.shape[2],c=l.shape[3];Y(u.shape[2]===h*c,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*c}, but got ${u.shape[2]}.`));let f=Ol(p,l,r,a,i,s),m=Il(f,u,1,"valid",i);return d?Zo(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});var yd=async function(e,t){let n=Bs(e,"x","setdiff1d"),r=Bs(t,"y","setdiff1d");Y(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),Y(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),Y(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));let a=await n.data(),s=await r.data(),i=new Set(s),o=0;for(let e=0;e<a.length;e++)i.has(a[e])||o++;let l=new rs([o],n.dtype),u=new rs([o],"int32");for(let e=0,t=0;e<a.length;e++)i.has(a[e])||(l.values[t]=a[e],u.values[t]=e,t++);return[l.toTensor(),u.toTensor()]};var bd=Us({sign_:function(e){let t={x:Bs(e,"x","sign")};return Es.runKernel(Nr,t)}});var xd=Us({sin_:function(e){let t={x:Bs(e,"x","sin","float32")};return Es.runKernel(Ir,t)}});var wd=Us({sinh_:function(e){let t={x:Bs(e,"x","sinh")};return Es.runKernel(Sr,t)}});var vd=Us({slice1d_:function(e,t,n){let r=Bs(e,"x","slice1d");return Y(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),rl(r,[t],[n])}});var kd=Us({slice2d_:function(e,t,n){let r=Bs(e,"x","slice2d");return Y(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),rl(r,t,n)}});var Id=Us({slice3d_:function(e,t,n){let r=Bs(e,"x","slice3d");return Y(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),rl(r,t,n)}});var Sd=Us({slice4d_:function(e,t,n){let r=Bs(e,"x","slice4d");return Y(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),rl(r,t,n)}});var Nd=Us({softmax_:function(e,t=-1){let n=Bs(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},a={dim:t};return Es.runKernel(Fr,r,a)}});var Td=Us({fft_:function(e){Y("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));let t={input:e};return Es.runKernel(Yt,t)}});var _d=Us({ifft_:function(e){Y("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));let t={input:e};return Es.runKernel(ln,t)}});var Cd=Us({irfft_:function(e){let t,n=e.shape[e.shape.length-1],r=e.size/n;if(n<=2){let a=Zo(e,[r,n]);t=_d(a)}else{let a=[r,2*(n-1)],s=Zo(ad(e),[r,n]),i=Zo(Nu(e),[r,n]),o=ld(rl(s,[0,1],[r,n-2]),1),l=ko(ld(rl(i,[0,1],[r,n-2]),1),uu(-1)),u=el([s,o],1),p=el([i,l],1),d=Zo(Gs(u,p),[a[0],a[1]]);t=_d(d)}if(t=ad(t),3===e.rank&&0!==e.shape[0]){let n=t,r=e.shape[0];t=Zo(t,[r,t.shape[0]/r,t.shape[1]]),n.dispose()}return t}});var Ed=Us({split_:function(e,t,n=0){let r={x:Bs(e,"x","split")},a={numOrSizeSplits:t,axis:n};return Es.runKernel(Ar,r,a)}});var $d=Us({rfft_:function(e,t){Y("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n,r=e.shape[e.shape.length-1],a=e.size/r;if(null!=t&&t<r){let a=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,n=rl(e,a,s),r=t}else if(null!=t&&t>r){let a=e.shape.map((e=>e));a[e.shape.length-1]=t-r,n=el([e,op(a)],e.shape.length-1),r=t}else n=e;let s=Hl(n),i=Zo(Gs(n,s),[a,r]),o=Td(i),l=Math.floor(r/2)+1,u=ad(o),p=Nu(o),d=Ed(u,[l,r-l],u.shape.length-1),h=Ed(p,[l,r-l],p.shape.length-1),c=n.shape.slice();return c[n.shape.length-1]=l,Zo(Gs(d[0],h[0]),c)}});var Ad=Us({squaredDifference_:function(e,t){let n=Bs(e,"a","squaredDifference"),r=Bs(t,"b","squaredDifference");[n,r]=ws(n,r),Vl(n.shape,r.shape);let a={a:n,b:r};return Es.runKernel(zr,a,{})}});var Fd=Us({squeeze_:function(e,t){let n=Bs(e,"x","squeeze","string_or_numeric");return Zo(n,de(n.shape,t).newShape)}});var Rd=Us({stack_:function(e,t=0){let n=Ws(e,"tensors","stack","string_or_numeric");Y(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Y(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));let r=n,a={axis:t};return Es.runKernel(Xn,r,a)}});var Dd=Us({step_:function(e,t=0){let n={x:Bs(e,"x","step")},r={alpha:t};return Es.runKernel(ra,n,r)}});var Md=Us({stridedSlice_:function(e,t,n,r,a=0,s=0,i=0,o=0,l=0){let u={x:Bs(e,"x","stridedSlice","string_or_numeric")},p={begin:t,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return Es.runKernel(Wr,u,p)}});var Od=Us({tan_:function(e){let t={x:Bs(e,"x","tan","float32")};return Es.runKernel(jr,t)}});function Ld(e,t){J(e);let n=Ls(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Hs(e,null,n,t)}function zd(e,t,n){if(J(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");let r=Ls(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Hs(e,t,r,n)}function Pd(e,t,n){if(J(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");let r=Ls(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Hs(e,t,r,n)}function Bd(e,t,n){if(J(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");let r=Ls(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Hs(e,t,r,n)}function Wd(e,t,n){if(J(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");let r=Ls(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Hs(e,t,r,n)}function Vd(e,t,n){if(J(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");let r=Ls(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Hs(e,t=t||r,r,n)}var Ud={};function Gd(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+" update.rank != "+(a+e.length-r));for(let e=0;e<a;++e)if(n.shape[e]!==t.shape[e])throw new Error(s+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-a;++t)if(n.shape[t+a]!==e[t+r])throw new Error(s+` updates.shape[${t+a}] (${n.shape[t+a]}) != shape[${t+a}] (${e[t+a]})`)}function Hd(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Gd(n,t,e)}function jd(e,t,n){let r=t.shape.length,a=r>1?t.shape[r-1]:1,s=n.length,i=1;for(let e=a;e<s;++e)i*=n[e];let o=a<1?1:a;return{sliceRank:a,numUpdates:Q(t.shape)/o,sliceSize:i,strides:[...Ne(n.slice(0,a)),1],outputSize:Q(n)}}g(Ud,{calculateShapes:()=>jd,validateInput:()=>Hd,validateUpdateShape:()=>Gd});var qd=Us({tensorScatterUpdate_:function(e,t,n){let r=Bs(e,"tensor","tensorScatterupdate"),a=Bs(t,"indices","tensorScatterupdate","int32"),s=Bs(n,"updates","tensorScatterupdate");if(Hd(s,a,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);let i={tensor:r,indices:a,updates:s};return Es.runKernel(br,i,{})}});var Kd=Us({topk_:function(e,t=1,n=!0){let r=Bs(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");let a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);let s={x:r},i={k:t,sorted:n},[o,l]=Es.runKernel(Xr,s,i);return{values:o,indices:l}}});var Xd=Us({truncatedNormal_:function(e,t=0,n=1,r,a){if(Fe(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");let s=new Xp(t,n,r,!0,a),i=mo(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=s.nextValue();return i.toTensor()}});var Yd=Us({unique_:function(e,t=0){let n=Bs(e,"x","unique","string_or_numeric");Y(n.rank>0,(()=>"The input tensor must be at least 1D"));let r={x:n},a={axis:t},[s,i]=Es.runKernel(Jr,r,a);return{values:s,indices:i}}});var Zd=Us({unsortedSegmentSum_:function(e,t,n){let r=Bs(e,"x","unsortedSegmentSum"),a=Bs(t,"segmentIds","unsortedSegmentSum","int32");Y(re(n),(()=>"numSegments must be of dtype int"));let s={x:r,segmentIds:a},i={numSegments:n};return Es.runKernel(ea,s,i)}});var Jd=Us({unstack_:function(e,t=0){let n=Bs(e,"x","unstack","string_or_numeric");Y(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));let r={value:n},a={axis:t};return Es.runKernel(Qr,r,a)}});function Qd(e,t){return ep(e,t,"right")}function eh(e,t=!0,n,r){return Es.makeVariable(e,t,n,r)}function th(e,t){let n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);let r=mo(e,"int32"),a=mo([n.length,e.length],"int32");for(let t=0;t<n.length;t++){let s=r.indexToLoc(n[t]),i=t*e.length;a.values.set(s,i)}return a.toTensor()}var nh=async function(e){let t=Bs(e,"condition","whereAsync","bool"),n=await t.data(),r=th(t.shape,n);return e!==t&&t.dispose(),r};var rh=async function(e,t,n){let r=Bs(e,"tensor","boolMask"),a=Bs(t,"mask","boolMask","bool"),s=null==n?0:n,i=a.rank,o=r.shape;Y(i>0,(()=>"mask cannot be scalar")),Z(o.slice(s,s+i),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let e=s;e<s+i;e++)l*=o[e];let u=o.slice(0,s).concat([l],o.slice(s+i)),p=Zo(r,u),d=Zo(a,[-1]),h=await nh(d),c=Fd(h,[1]),f=ku(p,c,s);return e!==r&&r.dispose(),t!==a&&a.dispose(),c.dispose(),p.dispose(),d.dispose(),h.dispose(),f};var ah=Us({transpose_:function(e,t,n){let r=Bs(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),Y(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{Y(e>=0&&e<r.rank,(()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`))})),r.rank<=1)return r.clone();let a={x:r},s={perm:t};return"complex64"===r.dtype?ri((()=>{let e=ad(r),t=Nu(r);return e=Es.runKernel(Zr,{x:e},s),t=Es.runKernel(Zr,{x:t},s),n&&(t=Uu(t)),Gs(e,t)})):Es.runKernel(Zr,a,s)}});var sh=Us({movingAverage_:function(e,t,n,r,a=!0){let s=Bs(e,"v","movingAverage"),i=Bs(t,"x","movingAverage"),o=Bs(n,"decay","movingAverage");vs(s,i),Y(ne(s.shape,i.shape),(()=>"Shape mismatch in v and x"));let l=uu(1),u=ju(l,o),p=ko(ju(i,s),u);if(a){Y(null!=r,(()=>"When using zeroDebias: true, step is required."));let e=Bs(r,"step","movingAverage");p=vo(p,ju(l,lu(o,e)))}return xo(s,p)}});var ih=Us({scatterND_:function(e,t,n){Fe(n);let r=Bs(e,"indices","scatterND","int32"),a=Bs(t,"updates","scatterND");Hd(a,r,n);let s={indices:r,updates:a},i={shape:n};return Es.runKernel(yr,s,i)}});var oh=Us({sparseToDense_:function(e,t,n,r=0){Fe(n);let a=Bs(e,"sparseIndices","sparseToDense","int32"),s=Bs(t,"sparseValues","sparseToDense","string_or_numeric"),i=Bs(r,"defaultValue","sparseToDense",s.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let a=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);let i=t.size;if(0!==t.rank&&(1!==t.rank||i!==a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(a,s,n,i);let o={sparseIndices:a,sparseValues:s,defaultValue:i},l={outputShape:n};return Es.runKernel(Lr,o,l)}});var lh=Us({gatherND_:function(e,t){let n=Bs(t,"indices","gatherND","int32"),r={params:Bs(e,"x","gatherND","string_or_numeric"),indices:n};return Es.runKernel(rn,r)}});var uh=Us({dropout_:function(e,t,n,r){let a=Bs(e,"x","dropout");if(Y("float32"===a.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`)),Y(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof is?a.clone():a;let s=function(e,t){if(null==t)return e.shape.slice();if(ne(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(a,n),i=1-t,o=vo(vu(xo(td(s,0,1,"float32",r),i)),i);return ko(a,o)}});function ph(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function dh(e,t,n){let r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(i)}return Ld(a,"float32")}var hh=async function(e,t,n=1){let r=Bs(e,"predictions","inTopK"),a=Bs(t,"targets","inTopK");Y(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),Y(r.rank-1===a.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`)),Z(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];Y(n>0&&n<=s,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`));let i=await r.data(),o=await a.data(),[l,u]=[i.length/s,s],p=he("bool",l);for(let e=0;e<l;e++){let t=e*u,r=i.subarray(t,t+u),a=[];for(let e=0;e<r.length;e++)a.push({value:r[e],index:e});a.sort(((e,t)=>t.value-e.value)),p[e]=0;for(let t=0;t<n;t++)if(a[t].index===o[e]){p[e]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),js(p,a.shape,"bool")},ch={};g(ch,{conv2d:()=>xh,depthwiseConv2d:()=>kh,matMul:()=>Ih});var fh=Us({conv2DBackpropFilter_:function(e,t,n,r,a,s="NHWC",i){let o=e;3===e.rank&&(o=Zo(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Zo(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Y(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),Y(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),Y(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));let u="NHWC"===s?o.shape[3]:o.shape[1],p="NHWC"===s?l.shape[3]:l.shape[1];Y(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),Y(p===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${p}) must match output depth for filter (${n[3]}).`)),Yo("conv2dDerFilter",a,i);let d={x:o,dy:l},h={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,filterShape:n};return Es.runKernel(vt,d,h)}});function mh(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return ko(e,Dd(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function gh(e,t){let n=t,r=Wl(e.shape,t.shape);return r.length>0&&(n=hu(n,r)),Zo(n,e.shape)}function yh(e,t,n,r){if("linear"===t)return e;if("relu"===t)return id(e);if("elu"===t)return Xl(e);if("relu6"===t)return od(e);if("prelu"===t)return _p(e,n);if("leakyrelu"===t)return Eu(e,r);if("sigmoid"===t)return nl(e);throw new Error(`Unknown fused activation ${t}.`)}var bh=(e,t)=>!(e>0)||"linear"===t;var xh=Us({fusedConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:p}){if(l=l||"linear",!1===bh(Es.state.gradientDepth,l)){Y("NHWC"===a,(()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let d=Il(e,t,n,r,a,s,i);return null!=o&&(d=xo(d,o)),yh(d,l,u,p)}let d=Bs(e,"x","conv2d","float32"),h=Bs(t,"filter","conv2d","float32"),c=d,f=!1;3===d.rank&&(f=!0,c=Zo(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Y(4===c.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${c.rank}.`)),Y(4===h.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`)),Yo("fused conv2d",r,i);let m="NHWC"===a?c.shape[3]:c.shape[1];Y(h.shape[2]===m,(()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`)),Y(qo(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`));let g,y,b=Po(c.shape,h.shape,n,s,r,i);if(null!=o&&(g=Bs(o,"bias","fused conv2d"),[g]=ws(g,d),"NHWC"===a?Vl(b.outShape,g.shape):(Y(g.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${g.shape.length}.`)),Y(0===g.shape.length||g.shape[0]===b.outChannels||1===g.shape[0],(()=>`Error in fused conv2d: bias shape (${g.shape}) is not compatible with the number of output channels (${b.outChannels})`)))),null!=u){let e=u.shape;if(Y(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)Y(1===e[0]||e[0]===b.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${b.outChannels}).`));else if(3===e.length)try{Vl(e,b.outShape)}catch(t){let n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${b.outShape}).`;throw Error(n)}y=Bs(u,"prelu weights","fused conv2d")}let x=(e,t)=>{Y("NHWC"===a,(()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`));let[i,o,u,p]=t,d=mh(e,u,l);Y(jo(s),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`));let h=[Nl(o.shape,d,i,n,r),fh(o,d,i.shape,n,r)];if(null!=p){let e=gh(p,d);h.push(e)}return h},w={x:c,filter:h,bias:g,preluActivationWeights:y},v={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:p};return null==o?Wu(((e,t,n)=>{let r=Es.runKernel(oa,w,v);return n([t,e,r]),f&&(r=Zo(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}))(c,h):Wu(((e,t,n,r)=>{let a=Es.runKernel(oa,w,v);return r([t,e,a,n]),f&&(a=Zo(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}))(c,h,g)}});var wh=Us({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,a,s=[1,1],i){let o=e;3===e.rank&&(o=Zo(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Zo(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:o,dy:l},p={strides:r,pad:a,dimRoundingMode:i,dilations:s,filterShape:n};return Es.runKernel(Dt,u,p)}});var vh=Us({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,a,s=[1,1],i){let o=t,l=!1;3===t.rank&&(l=!0,o=Zo(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:o,filter:n},p={strides:r,pad:a,dimRoundingMode:i,dilations:s,inputShape:e},d=Es.runKernel(Mt,u,p);return l?Zo(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});var kh=Us({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:p}){if(!1===bh(Es.state.gradientDepth,l)){let d=Ol(e,t,n,r,a,s,i);return null!=o&&(d=xo(d,o)),yh(d,l,u,p)}let d=Bs(e,"x","depthwiseConv2d","float32"),h=Bs(t,"filter","depthwiseConv2d","float32"),c=d,f=!1;3===d.rank&&(f=!0,c=Zo(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Y(4===c.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`)),Y(4===h.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`)),Y(c.shape[3]===h.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`)),null==s&&(s=[1,1]),Y(qo(n,s),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),Yo("fused depthwiseConv2d",r,i);let m,g,y=Po(c.shape,h.shape,n,s,r,i,!0);null!=o&&(m=Bs(o,"bias","fused conv2d"),[m]=ws(m,d),Vl(y.outShape,m.shape)),null!=u&&(g=Bs(u,"prelu weights","fused depthwiseConv2d"));let b=(e,t)=>{Y(jo(s),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`));let[a,o,u,p]=t,d=mh(e,u,l),h=vh(o.shape,d,a,n,r,s,i),c=wh(o,d,a.shape,n,r,s,i);if(null!=p){return[h,c,gh(m,d)]}return[h,c]},x={x:c,filter:h,bias:m,preluActivationWeights:g},w={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:p};return null==o?Wu(((e,t,n)=>{let r=Es.runKernel(la,x,w);return n([t,e,r]),f&&(r=Zo(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}}))(c,h):Wu(((e,t,n,r)=>{let a=Es.runKernel(la,x,w);return r([t,e,a,n]),f&&(a=Zo(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:b}}))(c,h,m)}});var Ih=Us({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:a,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(!1===bh(Es.state.gradientDepth,s)){let l=tl(e,t,n,r);return null!=a&&(l=xo(l,a)),yh(l,s,i,o)}let l=Bs(e,"a","fused matMul"),u=Bs(t,"b","fused matMul");[l,u]=ws(l,u);let p=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=n?l.shape[l.rank-1]:l.shape[l.rank-2],c=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=Q(f),y=Q(m);Y(p===d,(()=>`Error in fused matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`));let b,x,w=Vl(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([h,c]),v=Zo(l,n?[g,p,h]:[g,h,p]),k=Zo(u,r?[y,c,d]:[y,d,c]);null!=a&&(b=Bs(a,"bias","fused matMul"),[b]=ws(b,l),Vl(w,b.shape)),null!=i&&(x=Bs(i,"prelu weights","fused matMul"));let I=(e,t)=>{let i,o,[l,u,p,d]=t,h=mh(Zo(e,p.shape),p,s);if(n||r?!n&&r?(i=tl(h,u,!1,!1),o=tl(h,l,!0,!1)):n&&!r?(i=tl(u,h,!1,!0),o=tl(l,h,!1,!1)):(i=tl(u,h,!0,!0),o=tl(h,l,!0,!0)):(i=tl(h,u,!1,!0),o=tl(l,h,!0,!1)),null!=a){return[i,o,gh(d,h)]}return[i,o]},S={a:v,b:k,bias:b,preluActivationWeights:x},N={transposeA:n,transposeB:r,activation:s,leakyreluAlpha:o};return null==a?Wu(((e,t,n)=>{let r=Es.runKernel(ia,S,N);return n([e,t,r]),{value:Zo(r,w),gradFunc:I}}))(v,k):Wu(((e,t,n,r)=>{let a=Es.runKernel(ia,S,N);return r([e,t,a,n]),{value:Zo(a,w),gradFunc:I}}))(v,k,b)}});var Sh=Us({hammingWindow_:function(e){return dh(e,.54,.46)}});var Nh=Us({hannWindow_:function(e){return dh(e,.5,.5)}});var Th=Us({frame_:function(e,t,n,r=!1,a=0){let s=0,i=[];for(;s+t<=e.size;)i.push(rl(e,s,t)),s+=n;if(r)for(;s<e.size;){let r=s+t-e.size,o=el([rl(e,s,t-r),yl([r],a)]);i.push(o),s+=n}return 0===i.length?zd([],[0,t]):Zo(el(i),[i.length,t])}});var _h=Us({stft_:function(e,t,n,r,a=Nh){null==r&&(r=ph(t));let s=Th(e,t,n),i=ko(s,a(t));return $d(i,r)}});var Ch=Us({cropAndResize_:function(e,t,n,r,a="bilinear",s=0){let i=Bs(e,"image","cropAndResize"),o=Bs(t,"boxes","cropAndResize","float32"),l=Bs(n,"boxInd","cropAndResize","int32"),u=o.shape[0];Y(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),Y(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),Y(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),Y(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),Y(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),Y("bilinear"===a||"nearest"===a,(()=>`method must be bilinear or nearest, but was ${a}`));let p={image:i,boxes:o,boxInd:l},d={method:a,extrapolationValue:s,cropSize:r};return Es.runKernel($t,p,d)}});var Eh=Us({flipLeftRight_:function(e){let t=Bs(e,"image","flipLeftRight","float32");Y(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));let n={image:t};return Es.runKernel(Jt,n,{})}});var $h=Us({grayscaleToRGB_:function(e){let t=Bs(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];Y(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),Y(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));let a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,xu(t,a)}});var Ah=Us({rgbToGrayscale_:function(e){let t=Bs(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];Y(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),Y(3===r,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`));let a,s=t.dtype,i=go(t,"float32"),o=Ld([.2989,.587,.114]);switch(t.rank){case 2:a=Kl("ij,j->i",i,o);break;case 3:a=Kl("ijk,k->ij",i,o);break;case 4:a=Kl("ijkl,l->ijk",i,o);break;case 5:a=Kl("ijklm,m->ijkl",i,o);break;case 6:a=Kl("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return a=yu(a,-1),go(a,s)}});var Fh=Us({rotateWithOffset_:function(e,t,n=0,r=.5){let a=Bs(e,"image","rotateWithOffset","float32");Y(4===a.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`));let s={image:a},i={radians:t,fillValue:n,center:r};return Es.runKernel(sa,s,i)}});function Rh(e,t,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);let i=e.shape[0];return n=Math.min(n,i),Y(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),Y(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),Y(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),Y(1===t.rank,(()=>"scores must be a 1D tensor")),Y(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),Y(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}var Dh=Us({nonMaxSuppression_:function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let s=Bs(e,"boxes","nonMaxSuppression","float32"),i=Bs(t,"scores","nonMaxSuppression","float32"),o=Rh(s,i,n,r,a),l={maxOutputSize:n=o.maxOutputSize,iouThreshold:r=o.iouThreshold,scoreThreshold:a=o.scoreThreshold};return Es.runKernel(Gn,{boxes:s,scores:i},l)}});function Mh(e,t,n){let r=function(e,t,n){return function(e,t,n){let r=0,a=e.length,s=0,i=!1;for(;r<a;){s=r+(a-r>>>1);let o=n(t,e[s]);o>0?r=s+1:(a=s,i=!o)}return i?r:-r-1}(e,t,n||Oh)}(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function Oh(e,t){return e>t?1:e<t?-1:0}function Lh(e,t,n,r,a){return Bh(e,t,n,r,a,0)}function zh(e,t,n,r,a,s){return Bh(e,t,n,r,a,0,!1,s,!0)}function Ph(e,t,n,r,a,s){return Bh(e,t,n,r,a,s,!0)}function Bh(e,t,n,r,a,s,i=!1,o=!1,l=!1){let u=[];for(let e=0;e<t.length;e++)t[e]>a&&u.push({score:t[e],boxIndex:e,suppressBeginIndex:0});u.sort(Uh);let p=s>0?-.5/s:0,d=[],h=[];for(;d.length<n&&u.length>0;){let t=u.pop(),{score:n,boxIndex:s,suppressBeginIndex:i}=t;if(n<a)break;let o=!1;for(let n=d.length-1;n>=i;--n){let i=Wh(e,s,d[n]);if(i>=r){o=!0;break}if(t.score=t.score*Vh(r,p,i),t.score<=a)break}t.suppressBeginIndex=d.length,o||(t.score===n?(d.push(s),h.push(t.score)):t.score>a&&Mh(u,t,Uh))}let c=d.length,f=n-c;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));let m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=c),m}function Wh(e,t,n){let r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(a[0],a[2]),p=Math.min(a[1],a[3]),d=Math.max(a[0],a[2]),h=Math.max(a[1],a[3]),c=(o-s)*(l-i),f=(d-u)*(h-p);if(c<=0||f<=0)return 0;let m=Math.max(s,u),g=Math.max(i,p),y=Math.min(o,d),b=Math.min(l,h),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(c+f-x)}function Vh(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function Uh(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}var Gh=async function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let s=Bs(e,"boxes","nonMaxSuppressionAsync"),i=Bs(t,"scores","nonMaxSuppressionAsync"),o=Rh(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l=await Promise.all([s.data(),i.data()]),u=l[0],p=l[1],{selectedIndices:d}=Lh(u,p,n,r,a);return s!==e&&s.dispose(),i!==t&&i.dispose(),Ld(d,"int32")};var Hh=Us({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){let i=Bs(e,"boxes","nonMaxSuppression"),o=Bs(t,"scores","nonMaxSuppression"),l=Rh(i,o,n,r,a,s),u={boxes:i,scores:o},p={maxOutputSize:n=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:a=l.scoreThreshold,softNmsSigma:s=l.softNmsSigma},d=Es.runKernel(jn,u,p);return{selectedIndices:d[0],selectedScores:d[1]}}});var jh=async function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){let i=Bs(e,"boxes","nonMaxSuppressionAsync"),o=Bs(t,"scores","nonMaxSuppressionAsync"),l=Rh(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let u=await Promise.all([i.data(),o.data()]),p=u[0],d=u[1],{selectedIndices:h,selectedScores:c}=Ph(p,d,n,r,a,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Ld(h,"int32"),selectedScores:Ld(c)}};var qh=Us({nonMaxSuppressionPadded_:function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){let i=Bs(e,"boxes","nonMaxSuppression"),o=Bs(t,"scores","nonMaxSuppression"),l=Rh(i,o,n,r,a,null),u={boxes:i,scores:o},p={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s},d=Es.runKernel(Hn,u,p);return{selectedIndices:d[0],validOutputs:d[1]}}});var Kh=async function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){let i=Bs(e,"boxes","nonMaxSuppressionAsync"),o=Bs(t,"scores","nonMaxSuppressionAsync"),l=Rh(i,o,n,r,a,null),u=l.maxOutputSize,p=l.iouThreshold,d=l.scoreThreshold,[h,c]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=zh(h,c,u,p,d,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Ld(f,"int32"),validOutputs:uu(m,"int32")}};var Xh=Us({resizeBilinear_:function(e,t,n=!1,r=!1){let a=Bs(e,"images","resizeBilinear");Y(3===a.rank||4===a.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`)),Y(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),Y(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=Zo(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=Es.runKernel(dr,o,l);return i?Zo(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});var Yh=Us({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){let a=Bs(e,"images","resizeNearestNeighbor");Y(3===a.rank||4===a.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`)),Y(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),Y("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Y(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=Zo(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=Es.runKernel(ur,o,l);return i?Zo(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});var Zh=Us({threshold_:function(e,t="binary",n=!1,r=.5){let a,s,i,o,l=Bs(e,"image","threshold"),u=l.shape[0]*l.shape[1],p=ko(Ld([r]),255);if(Y(3===l.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${l.rank}.`)),Y(3===l.shape[2]||1===l.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${l.shape[2]}.`)),Y("int32"===l.dtype||"float32"===l.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${l.dtype}.`)),Y("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===l.shape[2]){[a,s,i]=Ed(l,[1,1,1],-1);let e=ko(a,.2989),t=ko(s,.587),n=ko(i,.114);o=xo(xo(e,t),n)}else o=e;if("otsu"===t){p=function(e,t){let n,r,a,s,i,o,l=Ld([-1]),u=Ld([0]),p=Ld([0]);for(let d=0;d<e.size-1;d++){n=rl(e,0,d+1),r=rl(e,d+1),i=vo(hu(n),t),o=vo(hu(r),t);let h=hu(ko(n,rd(0,n.size)));a=vo(h,hu(n));let c=yl(r.shape,n.size),f=xo(rd(0,r.size),c),m=ko(r,f);s=vo(hu(m),hu(r));let g=ju(a,s),y=ju(a,s),b=ko(i,o);p=ko(ko(b,g),y);let x=Iu(p,u);u=Gl(x,p,u),l=Gl(x,Ld([d]),l)}return l}(hl(go(cd(o),"int32"),js([]),256),u)}let d=n?Au(o,p):Iu(o,p);return go(ko(d,255),"int32")}});var Jh=Us({transform_:function(e,t,n="nearest",r="constant",a=0,s){let i=Bs(e,"image","transform","float32"),o=Bs(t,"transforms","transform","float32");Y(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),Y(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Y(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));let l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return Es.runKernel(Yr,l,u)}});var Qh=Us({bandPart_:function(e,t,n){let r=Bs(e,"a","bandPart");Y(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));let a,s,i=r.shape,[o,l]=r.shape.slice(-2);"number"==typeof t?(Y(t%1==0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),Y(t<=o,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`)),a=Bs(t<0?o:t,"numLower","bandPart")):(Y("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),a=Gl($u(t,0),o,pp(t,o))),"number"==typeof n?(Y(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),Y(n<=l,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${l}).`)),s=Bs(n<0?l:n,"numUpper","bandPart")):(Y("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),s=Gl($u(n,0),l,pp(n,l)));let u=Zo(rd(0,o,1,"int32"),[-1,1]),p=rd(0,l,1,"int32"),d=ju(u,p),h=Xu(Au(d,a),Su(d,Uu(s))),c=op([o,l],r.dtype);return Zo(Rd(Jd(Zo(r,[-1,o,l])).map((e=>Gl(h,e,c)))),i)}});var ec=Us({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Y(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));let n=e[0].shape[0];for(let t=1;t<e.length;++t)Y(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=Ed(e,e.shape[0],0).map((e=>Fd(e,[0])));Y(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));let n=[],r=e;for(let t=0;t<e.length;++t)n.push(Es.tidy((()=>{let e=r[t];if(t>0)for(let r=0;r<t;++r){let t=ko(hu(ko(n[r],e)),n[r]);e=ju(e,t)}return vo(e,fu(e,"euclidean"))})));return t?Rd(n,0):n}});function tc(e,t=!1){return Es.tidy((()=>{Y(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));let n=e.shape[0],r=e.shape[1],a=wu(n),s=yo(e),i=zd([[1]],[1,1]),o=yo(i),l=n>=r?r:n;for(let e=0;e<l;++e){let t=s,l=o,u=a;[o,s,a]=Es.tidy((()=>{let t=rl(s,[e,e],[n-e,1]),l=fu(t),u=rl(s,[e,e],[1,1]),p=Gl(Iu(u,0),zd([[-1]]),zd([[1]])),d=ju(u,ko(p,l)),h=vo(t,d);o=1===h.shape[0]?yo(i):el([i,rl(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);let c=Uu(vo(tl(p,d),l)),f=rl(s,[e,0],[n-e,r]),m=ko(c,o),g=ah(o);if(0===e)s=ju(f,tl(m,tl(g,f)));else{let t=ju(f,tl(m,tl(g,f)));s=el([rl(s,[0,0],[e,r]),t],0)}let y=ah(m),b=rl(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=ju(b,tl(tl(b,o),y));else{let t=ju(b,tl(tl(b,o),y));a=el([rl(a,[0,0],[n,e]),t],1)}return[o,s,a]})),ai([t,l,u])}return!t&&n>r&&(a=rl(a,[0,0],[n,r]),s=rl(s,[0,0],[r,r])),[a,s]}))}var nc,rc=Us({qr_:function(e,t=!1){if(Y(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return tc(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=Jd(Zo(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];return r.forEach((e=>{let[n,r]=tc(e,t);a.push(n),s.push(r)})),[Zo(Rd(a,0),e.shape),Zo(Rd(s,0),e.shape)]}}});!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(nc||(nc={}));var ac=Us({computeWeightedLoss_:function(e,t,n=nc.SUM_BY_NONZERO_WEIGHTS){let r=Bs(e,"losses","computeWeightedLoss"),a=null;null!=t&&(a=Bs(t,"weights","computeWeightedLoss"));let s=null==a?r:ko(r,a);if(n===nc.NONE)return s;if(n===nc.SUM)return hu(s);if(n===nc.MEAN){if(null==a)return ip(s);{let e=r.size/a.size,t=vo(hu(s),hu(a));return e>1?vo(t,uu(e)):t}}if(n===nc.SUM_BY_NONZERO_WEIGHTS){if(null==a)return vo(hu(s),uu(r.size));{let e=ko(a,lp(r.shape)),t=go(hu(gp(e,uu(0))),"float32");return vo(hu(s),t)}}throw Error(`Unknown reduction: ${n}`)}});var sc=Us({absoluteDifference_:function(e,t,n,r=nc.SUM_BY_NONZERO_WEIGHTS){let a=Bs(e,"labels","absoluteDifference"),s=Bs(t,"predictions","absoluteDifference"),i=null;null!=n&&(i=Bs(n,"weights","absoluteDifference")),Z(a.shape,s.shape,"Error in absoluteDifference: ");let o=Io(ju(a,s));return ac(o,i,r)}});var ic=Us({cosineDistance_:function(e,t,n,r,a=nc.SUM_BY_NONZERO_WEIGHTS){let s=Bs(e,"labels","cosineDistance"),i=Bs(t,"predictions","cosineDistance"),o=null;null!=r&&(o=Bs(r,"weights","cosineDistance")),Z(s.shape,i.shape,"Error in cosineDistance: ");let l=uu(1),u=ju(l,hu(ko(s,i),n,!0));return ac(u,o,a)}});var oc=Us({hingeLoss_:function(e,t,n,r=nc.SUM_BY_NONZERO_WEIGHTS){let a=Bs(e,"labels","hingeLoss"),s=Bs(t,"predictions","hingeLoss"),i=null;null!=n&&(i=Bs(n,"weights","hingeLoss")),Z(a.shape,s.shape,"Error in hingeLoss: ");let o=uu(1);a=ju(ko(uu(2),a),o);let l=id(ju(o,ko(a,s)));return ac(l,i,r)}});var lc=Us({huberLoss_:function(e,t,n,r=1,a=nc.SUM_BY_NONZERO_WEIGHTS){let s=Bs(e,"labels","huberLoss"),i=Bs(t,"predictions","huberLoss"),o=null;null!=n&&(o=Bs(n,"weights","huberLoss")),Z(s.shape,i.shape,"Error in huberLoss: ");let l=uu(r),u=Io(ju(i,s)),p=pp(u,l),d=ju(u,p),h=xo(ko(uu(.5),du(p)),ko(l,d));return ac(h,o,a)}});var uc=Us({logLoss_:function(e,t,n,r=1e-7,a=nc.SUM_BY_NONZERO_WEIGHTS){let s=Bs(e,"labels","logLoss"),i=Bs(t,"predictions","logLoss"),o=null;null!=n&&(o=Bs(n,"weights","logLoss")),Z(s.shape,i.shape,"Error in logLoss: ");let l=uu(1),u=uu(r),p=Uu(ko(s,Du(xo(i,u)))),d=ko(ju(l,s),Du(xo(ju(l,i),u))),h=ju(p,d);return ac(h,o,a)}});var pc=Us({meanSquaredError_:function(e,t,n,r=nc.SUM_BY_NONZERO_WEIGHTS){let a=Bs(e,"labels","meanSquaredError"),s=Bs(t,"predictions","meanSquaredError"),i=null;null!=n&&(i=Bs(n,"weights","meanSquaredError")),Z(a.shape,s.shape,"Error in meanSquaredError: ");let o=Ad(a,s);return ac(o,i,r)}});var dc=Us({sigmoidCrossEntropy_:function(e,t,n,r=0,a=nc.SUM_BY_NONZERO_WEIGHTS){let s=Bs(e,"multiClassLabels","sigmoidCrossEntropy"),i=Bs(t,"logits","sigmoidCrossEntropy"),o=null;if(null!=n&&(o=Bs(n,"weights","sigmoidCrossEntropy")),Z(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let e=uu(r),t=uu(1),n=uu(.5);s=xo(ko(s,ju(t,e)),ko(n,e))}let l=function(e,t){let n=Bs(e,"labels","sigmoidCrossEntropyWithLogits"),r=Bs(t,"logits","sigmoidCrossEntropyWithLogits");Z(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let a=id(r),s=ko(r,n),i=Mu(gu(Uu(Io(r))));return xo(ju(a,s),i)}(s,i);return ac(l,o,a)}});var hc=Us({softmaxCrossEntropy_:function(e,t,n,r=0,a=nc.SUM_BY_NONZERO_WEIGHTS){let s=Bs(e,"onehotLabels","softmaxCrossEntropy"),i=Bs(t,"logits","softmaxCrossEntropy"),o=null;if(null!=n&&(o=Bs(n,"weights","softmaxCrossEntropy")),Z(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let e=uu(r),t=uu(1),n=uu(s.shape[1]);s=xo(ko(s,ju(t,e)),vo(e,n))}let l=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Wu(((e,t,r)=>{let a=Ku(t,[n],!0),s=ju(go(t,"float32"),a);r([e,s]);let i=Uu(ko(s,e));return{value:hu(i,[n]),gradFunc:(e,t)=>{let[r,a]=t,s=tu(e.shape,[n]);return[ko(Zo(e,s),ju(go(r,"float32"),gu(a))),ko(Zo(e,s),ju(gu(a),go(r,"float32")))]}}}))(e,t)}(s,i);return ac(l,o,a)}});var cc=Us({sparseFillEmptyRows_:function(e,t,n,r){let a=Bs(e,"indices","sparseFillEmptyRows","int32"),s=Bs(t,"values","sparseFillEmptyRows"),i=Bs(n,"denseShape","sparseFillEmptyRows","int32"),o=Bs(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:a,values:s,denseShape:i,defaultValue:o},u=Es.runKernel(Rr,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}});var fc=Us({sparseReshape_:function(e,t,n){let r=Bs(e,"inputIndices","sparseReshape","int32"),a=Bs(t,"inputShape","sparseReshape","int32"),s=Bs(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:r,inputShape:a,newShape:s},o=Es.runKernel(Dr,i);return{outputIndices:o[0],outputShape:o[1]}}});var mc=Us({sparseSegmentMean_:function(e,t,n){let r=Bs(e,"data","sparseSegmentMean"),a=Bs(t,"indices","sparseSegmentMean","int32"),s=Bs(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return Es.runKernel(Mr,i)}});var gc=Us({sparseSegmentSum_:function(e,t,n){let r=Bs(e,"data","sparseSegmentSum"),a=Bs(t,"indices","sparseSegmentSum","int32"),s=Bs(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return Es.runKernel(Or,i)}});var yc=Us({stringNGrams_:function(e,t,n,r,a,s,i,o){let l=Bs(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=Bs(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");let p={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:i,preserveShortSequences:o},d={data:l,dataSplits:u},h=Es.runKernel(Vr,d,p);return{nGrams:h[0],nGramsSplits:h[1]}}});var bc=Us({stringSplit_:function(e,t,n=!0){let r=Bs(e,"input","stringSplit","string"),a=Bs(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==a.rank)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);let s={skipEmpty:n},i={input:r,delimiter:a},o=Es.runKernel(Ur,i,s);return{indices:o[0],values:o[1],shape:o[2]}}});var xc=Us({stringToHashBucketFast_:function(e,t){let n=Bs(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let a={input:n};return Es.runKernel(Gr,a,r)}});var wc=Us({staticRegexReplace_:function(e,t,n,r=!0){let a=Bs(e,"input","staticRegexReplace","string"),s={pattern:t,rewrite:n,replaceGlobal:r};return Es.runKernel(Br,{x:a},s)}}),vc={fft:Td,ifft:_d,rfft:$d,irfft:Cd},kc={hammingWindow:Sh,hannWindow:Nh,frame:Th,stft:_h},Ic={flipLeftRight:Eh,grayscaleToRGB:$h,resizeNearestNeighbor:Yh,resizeBilinear:Xh,rgbToGrayscale:Ah,rotateWithOffset:Fh,cropAndResize:Ch,nonMaxSuppression:Dh,nonMaxSuppressionAsync:Gh,nonMaxSuppressionWithScore:Hh,nonMaxSuppressionWithScoreAsync:jh,nonMaxSuppressionPadded:qh,nonMaxSuppressionPaddedAsync:Kh,threshold:Zh,transform:Jh},Sc={bandPart:Qh,gramSchmidt:ec,qr:rc},Nc={absoluteDifference:sc,computeWeightedLoss:ac,cosineDistance:ic,hingeLoss:oc,huberLoss:lc,logLoss:uc,meanSquaredError:pc,sigmoidCrossEntropy:dc,softmaxCrossEntropy:hc},Tc={sparseFillEmptyRows:cc,sparseReshape:fc,sparseSegmentMean:mc,sparseSegmentSum:gc},_c={stringNGrams:yc,stringSplit:bc,stringToHashBucketFast:xc,staticRegexReplace:wc},Cc={};g(Cc,{Serializable:()=>Ac,SerializationMap:()=>Fc,getRegisteredName:()=>Dc,registerClass:()=>Rc});var Ec=new Map,$c=new Map,Ac=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},Fc=class e{constructor(){this.classNameMap={}}static getMap(){return null==e.instance&&(e.instance=new e),e.instance}static register(t){e.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function Rc(e,t,n){Y(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),Y("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),Y(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),void 0===t&&(t="Custom"),void 0===n&&(n=e.className);let r=t+">"+n;return Fc.register(e),Ec.set(r,e),$c.set(e,r),e}function Dc(e){return $c.has(e)?$c.get(e):e.className}var Mc=class extends Ac{minimize(e,t=!1,n){let{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){let e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else this.applyGradients(a);return ai(a),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Bu(e,t)}dispose(){null!=this.iterations_&&ai(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:uu(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Mc,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});var Oc=class extends Mc{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Es.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Es.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:ri((()=>Hl(r).variable(false)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:ri((()=>Hl(r).variable(false)))});let a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;let s=this.accumulatedGrads[n].variable,i=this.accumulatedUpdates[n].variable;ri((()=>{let e=xo(ko(s,this.rho),ko(du(a),1-this.rho)),t=ko(vo(pu(xo(i,this.epsilon)),pu(xo(s,this.epsilon))),a),n=xo(ko(i,this.rho),ko(du(t),1-this.rho));s.assign(e),i.assign(n);let o=xo(ko(t,-this.learningRate),r);r.assign(o)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(ai(this.accumulatedGrads.map((e=>e.variable))),ai(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){let t=(e=await this.extractIterations(e)).length/2;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},Lc=class extends Mc{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Es.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:ri((()=>yl(r.shape,this.initialAccumulatorValue).variable(!1)))});let a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;let s=this.accumulatedGrads[n].variable;ri((()=>{let e=xo(s,du(a));s.assign(e);let t=xo(ko(vo(a,pu(xo(e,Es.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&ai(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},zc=class extends Mc{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ri((()=>{this.accBeta1=uu(t).variable(),this.accBeta2=uu(n).variable()})),null==r&&(this.epsilon=Es.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);ri((()=>{let n=ju(1,this.accBeta1),r=ju(1,this.accBeta2);t.forEach(((t,a)=>{let s=Es.registeredVariables[t];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:ri((()=>Hl(s).variable(false)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${t}/v`,variable:ri((()=>Hl(s).variable(false)))});let i=Array.isArray(e)?e[a].tensor:e[t];if(null==i)return;let o=this.accumulatedFirstMoment[a].variable,l=this.accumulatedSecondMoment[a].variable,u=xo(ko(o,this.beta1),ko(i,1-this.beta1)),p=xo(ko(l,this.beta2),ko(du(i),1-this.beta2)),d=vo(u,n),h=vo(p,r);o.assign(u),l.assign(p);let c=xo(ko(vo(d,xo(pu(h),this.epsilon)),-this.learningRate),s);s.assign(c)})),this.accBeta1.assign(ko(this.accBeta1,this.beta1)),this.accBeta2.assign(ko(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&ai(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&ai(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),ri((()=>{this.accBeta1.assign(lu(this.beta1,this.iterations_+1)),this.accBeta2.assign(lu(this.beta2,this.iterations_+1))}));let t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},Pc=class extends Mc{static get className(){return"Adamax"}constructor(e,t,n,r=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ri((()=>{this.iteration=uu(0).variable(),this.accBeta1=uu(t).variable()})),null==r&&(this.epsilon=Es.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);ri((()=>{let n=ju(1,this.accBeta1),r=vo(-this.learningRate,xo(ko(this.iteration,this.decay),1));t.forEach(((t,a)=>{let s=Es.registeredVariables[t];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:Hl(s).variable(false)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${t}/v`,variable:Hl(s).variable(false)});let i=Array.isArray(e)?e[a].tensor:e[t];if(null==i)return;let o=this.accumulatedFirstMoment[a].variable,l=this.accumulatedWeightedInfNorm[a].variable,u=xo(ko(o,this.beta1),ko(i,1-this.beta1)),p=ko(l,this.beta2),d=Io(i),h=sp(p,d);o.assign(u),l.assign(h);let c=xo(ko(vo(r,n),vo(u,xo(h,this.epsilon))),s);s.assign(c)})),this.iteration.assign(xo(this.iteration,1)),this.accBeta1.assign(ko(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&ai(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&ai(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},Bc=class extends Mc{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;let a=Es.registeredVariables[t];ri((()=>{let e=xo(ko(this.c,r),a);a.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=si(uu(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},Wc=class extends Bc{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=uu(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Es.registeredVariables[t];null==this.accumulations[n]&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:ri((()=>Hl(r).variable(!1)))});let a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&ri((()=>{let e,t=xo(ko(this.m,a),s);e=this.useNesterov?xo(ko(this.c,xo(s,ko(t,this.m))),r):xo(ko(this.c,t),r),a.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&ai(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},Vc=class extends Mc{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=Es.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Es.registeredVariables[t],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:ri((()=>Hl(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:ri((()=>Hl(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:ri((()=>Hl(r).variable(a)))});let s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;ri((()=>{let e=xo(ko(i,this.decay),ko(du(s),1-this.decay));if(this.centered){let t=this.accumulatedMeanGrads[n].variable,a=xo(ko(t,this.decay),ko(s,1-this.decay)),l=vo(ko(s,this.learningRate),pu(ju(e,xo(du(a),this.epsilon)))),u=xo(ko(o,this.momentum),l);i.assign(e),t.assign(a),o.assign(u);let p=ju(r,u);r.assign(p)}else{let e=xo(ko(i,this.decay),ko(du(s),1-this.decay)),t=xo(ko(o,this.momentum),vo(ko(s,this.learningRate),pu(xo(e,this.epsilon))));i.assign(e),o.assign(t);let n=ju(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&ai(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&ai(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&ai(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},Uc=[Oc,Lc,zc,Pc,Wc,Vc,Bc];var Gc={};g(Gc,{CompositeArrayBuffer:()=>Ks,browserFiles:()=>Kc,browserHTTPRequest:()=>rf,concatenateArrayBuffers:()=>_i,copyModel:()=>po,decodeWeights:()=>bi,decodeWeightsStream:()=>Ii,encodeWeights:()=>yi,fromMemory:()=>lf,fromMemorySync:()=>uf,getLoadHandlers:()=>zi,getModelArtifactsForJSON:()=>Ai,getModelArtifactsForJSONSync:()=>$i,getModelArtifactsInfoForJSON:()=>Fi,getSaveHandlers:()=>Li,getWeightSpecs:()=>Ri,http:()=>nf,isHTTPScheme:()=>ef,listModels:()=>lo,loadWeights:()=>Zc,moveModel:()=>ho,registerLoadRouter:()=>Oi,registerSaveRouter:()=>Mi,removeModel:()=>uo,weightsLoaderFactory:()=>Jc,withSaveHandler:()=>pf,withSaveHandlerSync:()=>df});function Hc(e){return new Promise((e=>setTimeout(e))).then(e)}var jc=class e{constructor(t){if(!Pe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(e.URL_SCHEME)&&(t=t.slice(e.URL_SCHEME.length)),(null==t||0===t.length)&&(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=Ks.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let t=Ei(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await Hc((()=>a.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){let e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await Hc((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Fi(e)}}}};jc.URL_SCHEME="downloads://";var qc=class{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{let n=new FileReader;n.onload=n=>{let r=JSON.parse(n.target.result),a=r.modelTopology;if(null==a)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:a});let s=Ai(r,(e=>this.loadWeights(e)));e(s)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){let t=[],n=[];for(let r of e)t.push(...r.weights),n.push(...r.paths);let r=this.checkManifestAndWeightFiles(e),a=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(a).then((e=>[t,e]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{let a=new FileReader;a.onload=e=>{let t=e.target.result;n(t)},a.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map((e=>Ci(e.name))),r={};for(let a of e)a.paths.forEach((e=>{let a=Ci(e);if(-1!==t.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),-1===n.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(a)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}};function Kc(e){return new qc(e)}function Xc(e,t,n,r){var a;Y(null!=(a=e)&&Array.isArray(a)&&a.length>0,(()=>"promises must be a none empty array")),function(e,t){Y(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),Y(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),Y(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(e.map((a=>(a.then((a=>{let i=n+ ++s/e.length*(r-n);return t(i),a})),a))))}async function Yc(e,t){null==t&&(t={});let n=null==t.fetchFunc?Pe().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),a=(null==t.onProgress?await Promise.all(r):await Xc(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(a):await Xc(a,t.onProgress,.5,1)}async function Zc(e,t="",n,r){return Jc((e=>Yc(e,{requestInit:r})))(e,t,n)}function Jc(e){return async(t,n="",r)=>{let a=t.map((()=>!1)),s={},i=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{let l="quantization"in e?e.quantization.dtype:e.dtype,u=qs[l]*Q(e.shape),p=()=>{a[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((t,n)=>{t===e.name&&(p(),i[n]=!0)})):p(),o.push(e.name),n+=u}))})),!i.every((e=>e))){let e=r.filter(((e,t)=>!i[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}let l=a.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{let t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));let p=await e(u),d={},h=0;return l.forEach((e=>{let n=t[e].paths.length,r=new Ks(p.slice(h,h+n));s[e].forEach((e=>{let t=bi(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(let e in t)d[e]=t[e]})),h+=n})),d}}Di.registerSaveRouter((e=>Pe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(jc.URL_SCHEME)?function(e="model"){return new jc(e)}(e.slice(jc.URL_SCHEME.length)):null));var Qc=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Y("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=Pe().platform.fetch,Y(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&Y(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=Ei(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){let n=Ks.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}let r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:Fi(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){let e,t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);try{e=await t.json()}catch(e){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}let n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return Ai(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=Ri(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;let r,a=null==t.fetchFunc?Pe().platform.fetch:t.fetchFunc,s=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;s<e.length;){r||(r=(await a(e[s],t.requestInit,{isBinary:!0})).body.getReader());let{done:o,value:l}=await r.read();if(!o)return void n.enqueue(l);s++,r=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,s/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}(t),a=this.weightPathPrefix||n,s=[],i=[];for(let t of e)for(let e of t.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):s.push(a+e+r);return this.weightUrlConverter&&s.push(...await Promise.all(i)),s}async loadWeights(e){let t=await this.getWeightUrls(e);return[Ri(e),await Yc(t,this.loadOptions)]}};function ef(e){return null!=e.match(Qc.URL_SCHEME_REGEX)}Qc.URL_SCHEME_REGEX=/^https?:\/\//;var tf=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>ef(e))):ef(e),n)return nf(e,t)}return null};function nf(e,t){return new Qc(e,t)}function rf(e,t){return nf(e,t)}Di.registerSaveRouter(tf),Di.registerLoadRouter(tf);var af=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},sf=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},of=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function lf(e,t,n,r){return new of(uf(...arguments))}function uf(e,t,n,r){return 1===arguments.length?null!=e.modelTopology||null!=e.weightSpecs?new af(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new af({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new af({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function pf(e){return new sf(e)}function df(e){return new sf(e)}var hf={};g(hf,{confusionMatrix:()=>cf});var cf=Us({confusionMatrix_:function(e,t,n){let r=Bs(e,"labels","confusionMatrix"),a=Bs(t,"predictions","confusionMatrix");Y(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),Y(1===r.rank,(()=>`Expected the rank of labels to be 1, but got ${r.rank}`)),Y(1===a.rank,(()=>`Expected the rank of predictions to be 1, but got ${a.rank}`)),Y(r.shape[0]===a.shape[0],(()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`)),Y(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));let s=yp(go(r,"int32"),n),i=yp(go(a,"int32"),n),o=ah(s),l=tl(o,i);return go(l,"int32")}}),ff={};g(ff,{draw:()=>kf,fromPixels:()=>If,fromPixelsAsync:()=>xf,toPixels:()=>vf});var mf,gf=!1;function yf(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)a=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(null!=ca(aa,Es.backendName)){let n={pixels:e},r={numChannels:t};return Es.runKernel(aa,n,r)}let l,u,[p,d]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height];if(i)l=e.getContext("2d").getImageData(0,0,p,d).data;else if(r||n)l=e.data;else if(s||a||o){if(null==mf)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");mf=new OffscreenCanvas(1,1).getContext("2d")}else mf=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});mf.canvas.width=p,mf.canvas.height=d,mf.drawImage(e,0,0,p,d),l=mf.getImageData(0,0,p,d).data}if(4===t)u=new Int32Array(l);else{let e=p*d;u=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)u[n*t+e]=l[4*n+e]}return Pd(u,[d,p,t],"int32")}function bf(e){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}async function xf(e,t=3){let n=null;if(Pe().getBool("WRAP_TO_IMAGEBITMAP")&&bf(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(e){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return yf(n,t)}function wf(e){if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}async function vf(e,t){let n=Bs(e,"img","toPixels");if(!(e instanceof is)){let e=n;n=go(e,"int32"),e.dispose()}wf(n);let[r,a]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2],i=await n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(a*r*4);for(let e=0;e<r*a;++e){let t=[0,0,0,255];for(let r=0;r<s;r++){let a=i[e*s+r];if("float32"===n.dtype){if(a<0||a>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${a}.`)}else if("int32"===n.dtype&&(a<0||a>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${a}.`);1===s?(t[0]=a*o,t[1]=a*o,t[2]=a*o):t[r]=a*o}let r=4*e;l[r+0]=Math.round(t[0]),l[r+1]=Math.round(t[1]),l[r+2]=Math.round(t[2]),l[r+3]=Math.round(t[3])}if(null!=t){gf||null!=ca(Bt,Es.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),gf=!0),t.width=a,t.height=r;let e=t.getContext("2d"),n=new ImageData(l,a,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),l}function kf(e,t,n){let r=Bs(e,"img","draw");if(!(e instanceof is)){let e=r;r=go(e,"int32"),e.dispose()}wf(r),function(e){let t=(null==e?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}(null==n?void 0:n.imageOptions);let a={image:r},s={canvas:t,options:n};Es.runKernel(Bt,a,s)}var If=Us({fromPixels_:yf}),Sf={};function Nf(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===Q(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let a=t.shape,s=a[a.length-1],i=1;for(let e=0;e<a.length-1;++e)i*=a[e];let o=e.shape,l=a.slice();l.pop();let u=1;for(let e=s;e<n;++e)u*=o[e],l.push(o[e]);let p=[...Ne(e.shape).map((e=>e/u)),1].slice(0,s);return[l,i,u,p]}g(Sf,{prepareAndValidate:()=>Nf});var Tf={};g(Tf,{assertParamsValid:()=>Ef,computeFlatOffset:()=>Vf,computeOutShape:()=>Af,getNormalizedAxes:()=>Mf,isSliceContinous:()=>Wf,maskToAxes:()=>$f,parseSliceParams:()=>Uf,sliceInfo:()=>Gf,startForAxis:()=>Pf,startIndicesWithElidedDims:()=>Of,stopForAxis:()=>Bf,stopIndicesWithElidedDims:()=>Lf,stridesForAxis:()=>zf,stridesWithElidedDims:()=>Ff});var _f=-2,Cf=-1;function Ef(e,t,n){let r=e.shape.length;Y(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),Y(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let a=0;a<r;++a)Y(t[a]+n[a]<=e.shape[a],(()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`))}function $f(e){let t=[],n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function Af(e,t,n){let r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function Ff(e,t,n,r){let a=[...e];for(let e=a.length;e<r.length;e++)a.push(1);for(let e=0;e<n;e++)0===e?a[t]=1:(a.splice(t,0,1),a.pop());return a}function Rf(e,t,n){return n<=e?n:n-(t-1)}function Df(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function Mf(e,t,n,r,a,s,i,o,l){let u=e.length,p=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&n>0){let l=t[0],u=n+1;p=Of(i,l,u,r,e),d=Lf(o,l,u,a,e),h=Ff(s,l,u,e)}else for(let t=0;t<u;t++)p[t]=Pf(i,r,s,e,t,l),d[t]=Bf(o,a,s,e,t,l),h[t]=zf(s,t,l);return{begin:p,end:d,strides:h}}function Of(e,t,n,r,a){let s=[...a],i=Df(n,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=0;else{let i=Rf(t,n,a),o=r[i];e&1<<i&&(o=0),s[a]=o}return s}function Lf(e,t,n,r,a){let s=[...a],i=Df(n,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{let i=Rf(t,n,a),o=r[i];e&1<<i&&(o=Number.MAX_SAFE_INTEGER),s[a]=o}for(let e=0;e<s.length;e++){let t=a[e];s[e]<0&&(s[e]+=t),s[e]=G(0,s[e],a[e])}return s}function zf(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function Pf(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=G(0,i,l-1),i}function Bf(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=o>0?G(0,i,l):G(-1,i,l-1),i}function Wf(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function Vf(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function Uf(e,t,n){let r,a,s=e.shape.length;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach((e=>{Y(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(Y(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function Gf(e,t,n,r,a,s,i,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let p=!1,d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let e=0;e<d.dims;e++)p&&1<<e&o&&d.numAddAxisAfterEllipsis++,1<<e&i&&(p=!0);p||(d.ellipsisMask|=1<<d.dims,d.dims++);let h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(_f),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(Cf),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(d,h);let c=!0,f=!0,m=!0,g=[],y=[];for(let t=0;t<e.length;++t){if(0===h.strides[t])throw Error(`strides[${t}] must be non-zero`);let n=!!(h.shrinkAxisMask&1<<t),r=e[t];if(-1===r){g.push(n?1:-1);continue}let a=[h.beginMask&1<<t,h.endMask&1<<t],s=[h.strides[t]>0?0:-1,h.strides[t]>0?r:r-1];if(n&&h.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[t];let i=!!(h.beginMask&1<<t&&h.endMask&1<<t);if(h.beginValid&&h.endValid){if(n){let e=h.begin[t]<0?r+h.begin[t]:h.begin[t];if(h.begin[t]=e,h.end[t]=h.begin[t]+1,e<0||e>=r)throw Error(`slice index ${h.begin[t]} of dimension ${t} out of bounds.`)}else h.begin[t]=Hf(h.begin[t],0,h.strides[t],r,a,s),h.end[t]=Hf(h.end[t],1,h.strides[t],r,a,s);let e=1===h.strides[t]&&0===h.begin[t]&&h.end[t]===r;c=c&&e,f=f&&(0===t&&1===h.strides[t]||e)}else c=c&&1===h.strides[t]&&i,f=f&&(0===t&&1===h.strides[t]||i);let o,l=!1;if(h.beginValid&&h.endValid?(o=h.end[t]-h.begin[t],l=!0):n?(o=1,l=!0):i&&r>=0&&(o=h.strides[t]<0?-r:r,l=!0),l){let e;e=0===o||o<0!=h.strides[t]<0?0:Math.trunc(o/h.strides[t])+(o%h.strides[t]!=0?1:0),g.push(e)}else g.push(-1)}for(let e=0;e<h.finalShapeGatherIndices.length;++e){let t=h.finalShapeGatherIndices[e];t>=0?y.push(g[t]):t===_f&&y.push(1)}return{finalShapeSparse:y.filter(((e,t)=>h.finalShapeGatherIndices[t]!==_f)),finalShape:y,isIdentity:c,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function Hf(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{let t=e<0?r+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}var jf="4.22.0",qf=class{static sgd(e){return new Bc(e)}static momentum(e,t,n=!1){return new Wc(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,a=!1){return new Vc(e,t,n,r,a)}static adam(e=.001,t=.9,n=.999,r=null){return new zc(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new Oc(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,a=0){return new Pc(e,t,n,r,a)}static adagrad(e,t=.1){return new Lc(e,t)}},Kf=qf,Xf="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function Yf(){return new Promise((e=>Xf((()=>e()))))}var Zf,Jf={};function Qf(e,t){let n=e[0].length;e.forEach(((e,t)=>{Y(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),Y(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));let r=e[0];e.forEach(((e,a)=>{for(let s=0;s<n;s++)Y(s===t||e[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`))}))}function em(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}function tm(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){let s=n[a],i=r[r.length-n.length+a],o=r[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${s} but shape[${a+e}] = ${o}`)}else r[i]=s}return r}function nm(e){let t={FIRST_DIM_SIZE:Zf.FIRST_DIM_SIZE,VALUE_ROWIDS:Zf.VALUE_ROWIDS,ROW_LENGTHS:Zf.ROW_LENGTHS,ROW_SPLITS:Zf.ROW_SPLITS,ROW_LIMITS:Zf.ROW_LIMITS,ROW_STARTS:Zf.ROW_STARTS},n=[];for(let r of e){if(!(r in t))break;n.push(t[r])}return n}function rm(e){return 0===e.length?0:e[0]===Zf.FIRST_DIM_SIZE?e.length-1:e.length}function am(e,t){if(null==e||null==t)return;let n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){let n=e[a],r=t[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${n} but ragged tensor input.flatValues.shape[${a-e.length}] = ${r}`)}}g(Jf,{ERF_A1:()=>gm,ERF_A2:()=>ym,ERF_A3:()=>bm,ERF_A4:()=>xm,ERF_A5:()=>wm,ERF_P:()=>mm,PARALLELIZE_THRESHOLD:()=>sm,RowPartitionType:()=>Zf,SELU_SCALE:()=>fm,SELU_SCALEALPHA:()=>cm,applyActivation:()=>yh,assertAndGetBroadcastShape:()=>Vl,assertAxesAreInnerMostDims:()=>nu,assertParamsConsistent:()=>Qf,assignToTypedArray:()=>Tm,axesAreInnerMostDims:()=>Jl,calculateShapes:()=>jd,checkEinsumDimSizes:()=>Mm,checkPadOnDimRoundingMode:()=>Yo,combineLocations:()=>Ql,combineRaggedTensorToTensorShapes:()=>tm,complexWithEvenIndex:()=>Im,complexWithOddIndex:()=>Sm,computeConv2DInfo:()=>Po,computeConv3DInfo:()=>Bo,computeDefaultPad:()=>Wo,computeDilation2DInfo:()=>Oo,computeOptimalWindowSize:()=>im,computeOutAndReduceShapes:()=>eu,computeOutShape:()=>em,computePool2DInfo:()=>Lo,computePool3DInfo:()=>zo,convertConv2DDataFormat:()=>Xo,decodeEinsumEquation:()=>Rm,eitherStridesOrDilationsAreOne:()=>qo,expandShapeToKeepDim:()=>tu,exponent:()=>Cm,exponents:()=>_m,fromStringArrayToUint8:()=>rg,fromUint8ToStringArray:()=>ng,getAxesPermutation:()=>ru,getBroadcastDims:()=>Bl,getComplexWithIndex:()=>Nm,getEinsumComputePath:()=>Om,getEinsumPermutation:()=>Dm,getFusedBiasGradient:()=>gh,getFusedDyActivation:()=>mh,getImageCenter:()=>om,getInnerMostAxes:()=>su,getPermuted:()=>um,getRaggedRank:()=>rm,getReductionAxes:()=>Wl,getReshaped:()=>lm,getReshapedPermuted:()=>pm,getRowPartitionTypesHelper:()=>nm,getSliceBeginCoords:()=>dm,getSliceSize:()=>hm,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Bm,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Wm,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Vm,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Hm,getSparseReshapeInputOutputMismatchErrorMessage:()=>qm,getSparseReshapeInputOutputMultipleErrorMessage:()=>jm,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Um,getSparseReshapeNegativeOutputDimErrorMessage:()=>Gm,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Zm,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Km,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Xm,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Ym,getUndoAxesPermutation:()=>au,isIdentityPermutation:()=>Lm,log:()=>pa,mergeRealAndImagArrays:()=>vm,prepareAndValidate:()=>Nf,prepareSplitSize:()=>Pm,segment_util:()=>Jm,shouldFuse:()=>bh,slice_util:()=>Tf,splitRealAndImagArrays:()=>km,stridesOrDilationsArePositive:()=>Ko,tupleValuesAreOne:()=>jo,upcastType:()=>gs,validateDefaultValueShape:()=>am,validateInput:()=>Hd,validateUpdateShape:()=>Gd,warn:()=>ua}),function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(Zf||(Zf={}));var sm=30;function im(e){return e<=sm?e:Se(e,Math.floor(Math.sqrt(e)))}function om(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function lm(e,t,n,r=!0){let a=[];if(r)a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);let n=t.length;for(let r=0;r<n;++r)a=a.concat([e[r+1]/t[r],t[r]]);a=a.concat(e.slice(n+1))}return a}function um(e,t,n=!0){let r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{let n=[],a=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?a.push(r):n.push(r);r.push(...n),r.push(0),r.push(...a)}return r}function pm(e,t,n,r=!0){let a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?r?a.push(t[n-1]*e[n]):a.push(e[n]/t[n-1]):a.push(e[n]);return a}function dm(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function hm(e,t,n){let r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}var cm=1.7580993408473768,fm=1.0507009873554805,mm=.3275911,gm=.254829592,ym=-.284496736,bm=1.421413741,xm=-1.453152027,wm=1.061405429;function vm(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function km(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function Im(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function Sm(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function Nm(e,t){return{real:e[2*t],imag:e[2*t+1]}}function Tm(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function _m(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){let s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function Cm(e,t,n){let r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}var Em="->",$m=/->/g,Am=",",Fm="...";function Rm(e,t){let n=((e=e.replace(/\s/g,"")).length-e.replace($m,"").length)/Em.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Em}").`);let[r,a]=e.split(Em);Y(-1===r.indexOf(Fm),(()=>`The ellipsis notation ("${Fm}") is not supported yet.`));let s=r.split(Am),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let e=0;e<a.length;++e){let t=a[e];if(!s.some((e=>-1!==e.indexOf(t))))throw new Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===o.indexOf(t)&&o.push(t)}for(let e=0;e<r.length;++e){let t=r[e];-1===o.indexOf(t)&&t!==Am&&o.push(t)}let l=new Array(s.length);for(let e=0;e<i;++e){if(new Set(s[e].split("")).size!==s[e].length)throw new Error(`Found duplicate axes in input component ${s[e]}. Support for duplicate axes in input is not implemented yet.`);l[e]=[];for(let t=0;t<s[e].length;++t)l[e].push(o.indexOf(s[e][t]))}let u=o.length,p=[];for(let e=a.length;e<u;++e)p.push(e);return{allDims:o,summedDims:p,idDims:l}}function Dm(e,t){let n=new Array(e);n.fill(-1);for(let e=0;e<t.length;++e)n[t[e]]=e;let r=[];for(let t=0;t<e;++t)-1===n[t]&&r.push(t);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function Mm(e,t,n){let r=new Array(e);for(let e=0;e<n.length;++e){let a=n[e].shape;for(let n=0;n<t[e].length;++n)void 0===r[t[e][n]]?r[t[e][n]]=a[n]:Y(r[t[e][n]]===a[n],(()=>`Expected dimension ${r[t[e][n]]} at axis ${n} of input shaped ${JSON.stringify(a)}, but got dimension ${a[n]}`))}}function Om(e,t){let n=e,r=[],a=0;0===e.length&&n.push(-1),a=e.length+1;for(let e=0;e<a;++e)r.push([]);let s=[];for(let e=0;e<n.length;++e){let a=zm(t,n[e]);for(let t of a)-1===s.indexOf(t)&&(r[e].push(t),s.push(t))}return{path:n,steps:r}}function Lm(e){return e.every(((e,t)=>e===t))}function zm(e,t){let n=[];for(let r=0;r<e.length;++r)(0===e[r].length||-1!==e[r].indexOf(t)||-1===t)&&n.push(r);return n}function Pm(e,t,n=0){let r=[];if("number"==typeof t)Y(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{Y(t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0)<=1,(()=>"There should be only one negative value in split array."));let a=t.indexOf(-1);if(-1!==a){let r=t.reduce(((e,t)=>t>0?e+t:e));t[a]=e.shape[n]-r}Y(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function Bm(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function Wm(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function Vm(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function Um(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Gm(e,t){return`size ${e} must be non-negative, not ${t}`}function Hm(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function jm(e,t){return`Input to reshape is a SparseTensor with ${Q(e)}\n  dense values, but the requested shape requires a multiple of ${Q(t)}. inputShape=${e} outputShape= ${t}`}function qm(e,t){return`Input to reshape is a tensor with ${Q(e)} dense values, but the requested shape has ${Q(t)}. inputShape=${e} outputShape=${t}`}function Km(){return"segment ids must be >= 0"}function Xm(){return"segment ids are not increasing"}function Ym(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Zm(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var Jm={};function Qm(e,t){let n,r=!1;for(e<=sm?(n=e,r=!0):n=Se(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=Se(e,n+1);return n}function eg(e,t,n){let r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function tg(e,t,n,r){let a=t.shape.length,s=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(e.shape[n]!==t.shape[n])throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);let i=e.shape[n],o=[],l=1,u=1,p=1;for(let t=0;t<r;++t)o.push(e.shape[t]),l*=e.shape[t];for(let t=r;t<n;t++)o.push(e.shape[t]),u*=e.shape[t];for(let e=r;e<a;e++)o.push(t.shape[e]);for(let t=n+1;t<s;t++)o.push(e.shape[t]),p*=e.shape[t];return{batchSize:l,sliceSize:p,outerSize:u,dimSize:i,outputShape:o}}function ng(e){try{return e.map((e=>Ua(e)))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function rg(e){return e.map((e=>Va(e)))}g(Jm,{collectGatherOpShapeInfo:()=>tg,computeOutShape:()=>eg,segOpComputeOptimalWindowSize:()=>Qm});var ag={};g(ag,{nonMaxSuppressionV3Impl:()=>Lh,nonMaxSuppressionV4Impl:()=>zh,nonMaxSuppressionV5Impl:()=>Ph,whereImpl:()=>th}),function(){for(let e of Uc)Rc(e)}();var sg={kernelName:Ge,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ko(e,Dd(go(n,"float32"),-1))}}},ig={kernelName:He,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=du(go(n,"float32")),r=pu(ju(uu(1),t));return Uu(vo(e,r))}}}},og={kernelName:je,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=pu(ju(du(go(n,"float32")),1));return vo(e,t)}}}},lg={kernelName:qe,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Vl(n.shape,r.shape);return{a:()=>{let t=e,r=Wl(n.shape,a);return r.length>0&&(t=hu(t,r)),Zo(t,n.shape)},b:()=>{let t=e,n=Wl(r.shape,a);return n.length>0&&(t=hu(t,n)),Zo(t,r.shape)}}}},ug={kernelName:Ke,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},pg={kernelName:Ze,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Hl(n)}}},dg={kernelName:Je,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Hl(n)}}},hg={kernelName:Qe,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>vo(e,pu(ju(uu(1),du(go(n,"float32")))))}}},cg={kernelName:et,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=pu(xo(uu(1),du(go(n,"float32"))));return vo(e,t)}}}},fg={kernelName:rt,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Vl(n.shape,r.shape);return{a:()=>{let t=xo(du(n),du(r)),s=ko(e,vo(r,t)),i=Wl(n.shape,a);return i.length>0&&(s=hu(s,i)),Zo(s,n.shape)},b:()=>{let t=xo(du(n),du(r)),s=Uu(ko(e,vo(n,t))),i=Wl(r.shape,a);return i.length>0&&(s=hu(s,i)),Zo(s,r.shape)}}}},mg={kernelName:tt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>vo(e,xo(du(go(n,"float32")),1))}}},gg={kernelName:nt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>vo(e,ju(uu(1),du(go(n,"float32"))))}}};var yg=Us({avgPool3dGrad_:function(e,t,n,r,a,s){let i=Bs(e,"dy","avgPool3dGrad"),o=Bs(t,"input","avgPool3dGrad"),l=i,u=o,p=!1;4===o.rank&&(p=!0,l=Zo(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=Zo(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Y(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),Y(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),Yo("avgPool3dGrad",a,s);let d={dy:l,input:u},h={filterSize:n,strides:r,pad:a,dimRoundingMode:s},c=Es.runKernel(ot,d,h);return p?Zo(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),bg={kernelName:it,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>yg(e,r,a,s,i,o)}}};var xg=Us({avgPoolGrad_:function(e,t,n,r,a){let s=Bs(e,"dy","avgPoolGrad"),i=Bs(t,"input","avgPoolGrad");Y(i.rank===s.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`));let o=i,l=s,u=!1;3===i.rank&&(u=!0,o=Zo(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=Zo(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Y(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),Y(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));let p={dy:l,input:o},d={filterSize:n,strides:r,pad:a},h=Es.runKernel(st,p,d);return u?Zo(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),wg={kernelName:at,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i}=n;return{x:()=>xg(e,r,a,s,i)}}},vg={kernelName:lt,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,a]=t,{transposeA:s,transposeB:i}=n;return s||i?!s&&i?{a:()=>tl(e,a,!1,!1),b:()=>tl(e,r,!0,!1)}:s&&!i?{a:()=>tl(a,e,!1,!0),b:()=>tl(r,e,!1,!1)}:{a:()=>tl(a,e,!0,!0),b:()=>tl(e,r,!0,!0)}:{a:()=>tl(e,a,!1,!0),b:()=>tl(r,e,!0,!1)}}},kg={kernelName:ut,gradFunc:(e,t,n)=>{let{blockShape:r,crops:a}=n;return{x:()=>Np(e,r,a)}}},Ig={kernelName:ht,gradFunc:(e,t,n)=>{let r=n,a=r.inputShape,s=r.shape,i=Array.from(s);for(let e=a.length-1;e>=0;e--)if(a[e]===s[e])i[e]=1;else if(1!==a[e])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${s}].`);let o=[];for(let e=0;e<i.length;e++)i[e]>1&&o.push(e);return{x:()=>hu(e,o,!0)}}},Sg={kernelName:ft,gradFunc:e=>({x:()=>e.clone()})},Ng={kernelName:mt,gradFunc:e=>({x:()=>Hl(e)})},Tg={kernelName:gt,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>Gl(Xu(Su(r,a),Au(r,s)),e,Hl(e))}}},_g={kernelName:bt,inputsToSave:["x"],gradFunc:sg.gradFunc},Cg={kernelName:xt,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map((e=>e.shape)),{axis:a}=n,s=pe(a,t[0].shape)[0],i=r.map((e=>e[s]));return Ed(e,i,s).map((e=>()=>e))}},Eg={kernelName:wt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return Y(jo(s),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`)),{x:()=>Nl(r.shape,e,a,i,o,l),filter:()=>fh(r,e,a.shape,i,o,l)}}},$g={kernelName:kt,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>Il(e,a,s,i,o,1,l),filter:()=>fh(e,r,a.shape,s,i,o,l)}}};var Ag=Us({conv3DBackpropFilter_:function(e,t,n,r,a){let s=e;4===e.rank&&(s=Zo(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=Zo(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Y(5===s.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`)),Y(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),Y(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),Y(s.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`)),Y(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));let o={x:s,dy:i},l={strides:r,pad:a,filterShape:n};return Es.runKernel(St,o,l)}}),Fg={kernelName:It,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s}=n;Y(jo(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));let[i,o]=t;return{x:()=>Cl(i.shape,e,o,a,s),filter:()=>Ag(i,e,o.shape,a,s)}}},Rg={kernelName:Tt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ko(Uu(xd(go(n,"float32"))),e)}}},Dg={kernelName:_t,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ko(wd(go(n,"float32")),e)}}},Mg={kernelName:Et,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a,exclusive:s,reverse:i}=n;return{x:()=>{let t=ru([a],r.rank),n=Rl(e,a,s,!i);return null!=t&&(n=ah(n,t)),n}}}},Og={kernelName:Rt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s,dimRoundingMode:i}=n,o=null==r?[1,1]:r;Y(jo(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));let[l,u]=t;return Y(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),Y(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),Y(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),Y(qo(a,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`)),Yo("depthwiseConv2d",s,i),{x:()=>vh(l.shape,e,u,a,s,o,i),filter:()=>wh(l,e,u.shape,a,s,o,i)}}},Lg={kernelName:Lt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,s={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>Es.runKernel(zt,s,n),filter:()=>Es.runKernel(Pt,i,n)}}},zg={kernelName:Ut,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>Es.runKernel(Gt,r)}}},Pg={kernelName:Ht,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=ko(gu(Uu(du(n))),2/Math.sqrt(Math.PI));return{x:()=>ko(e,r)}}},Bg={kernelName:qt,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ko(e,n)}}},Wg={kernelName:Kt,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>Zo(e,n.shape)}}},Vg={kernelName:Xt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ko(e,gu(n))}}},Ug={kernelName:Qt,gradFunc:e=>({x:()=>Hl(e)})},Gg={kernelName:en,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Vl(n.shape,r.shape);return{a:()=>{let t=vo(e,go(r,"float32")),s=Wl(n.shape,a);return s.length>0?Zo(hu(t,s),n.shape):t},b:()=>{let t=ko(e,go(n,"float32")),s=Wl(r.shape,a);s.length>0&&(t=Zo(hu(t,s),r.shape));let i=du(r);return Uu(vo(t,go(i,"float32")))}}}},Hg={kernelName:tn,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[a,s,i,o]=t,l=null==o?uu(1):o,u=Wl(s.shape,a.shape),p=[];if(1===s.rank){for(let e=0;e<a.shape.length-1;++e)p.push(a.shape[e]);p.push(1)}let d=ju(a,s),h=ko(e,l),c=fd(xo(i,uu(r))),f=ko(ko(ko(c,c),c),uu(-.5));return{x:()=>1===s.rank?Zo(ko(ko(e,xu(Zo(c,[1,1,1,s.shape[0]]),p)),l),a.shape):Zo(ko(ko(e,c),l),a.shape),mean:()=>{let e=ko(ko(c,uu(-1)),h);return 1===s.rank&&(e=hu(e,u)),Zo(e,s.shape)},variance:()=>{let e=ko(ko(f,d),h);return 1===s.rank&&(e=hu(e,u)),Zo(e,s.shape)},scale:()=>{let t=ko(d,c),n=ko(e,t);return 1===s.rank&&(n=hu(n,u)),Zo(n,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=hu(t,u)),Zo(t,s.shape)}}}},jg={kernelName:nn,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,a]=t,{axis:s,batchDims:i}=n,o=pe(s,r.shape)[0],l=(e,t,n)=>()=>{let r=e.shape,a=t.size,i=r.slice(0,o),l=i.length,u=r.slice(s,r.length).slice(1),p=u.length,d=qg(0,l),h=qg(l+1,l+1+p),c=Kg([i,[a],u]),f=Zo(n,c),m=Zo(t,[a]),g=Kg([[l],d,h]),y=ah(f,g),b=Zd(y,m,e.shape[o]),x=au(g);return b=ah(b,x),b};if(1===i){let t=r.shape[0],n=r.split(t,0);return{x:()=>Rd(n.map(((t,n)=>l(t,a.slice(n,1),e.slice(n,1))()))).reshape(r.shape),indices:()=>a}}return{x:l(r,a,e),indices:()=>a}}};function qg(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function Kg(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var Xg={kernelName:sn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>Hl(n),b:()=>Hl(r)}}},Yg={kernelName:on,gradFunc:e=>({x:()=>go(e,"float32")})},Zg={kernelName:pn,gradFunc:e=>({x:()=>Hl(e)})},Jg={kernelName:dn,gradFunc:e=>({x:()=>Hl(e)})},Qg={kernelName:hn,gradFunc:e=>({x:()=>Hl(e)})},ey={kernelName:cn,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:a}=n,s=Iu(r,0);return{x:()=>Gl(s,e,ko(e,a))}}},ty={kernelName:bn,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>vo(e,xo(n,1))}}},ny={kernelName:yn,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>vo(e,go(n,"float32"))}}},ry={kernelName:In,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n;return{logits:()=>{let t=gu(r);return ju(e,ko(hu(e,a,!0),t))}}}};var ay=Us({localResponseNormalizationBackprop_:function(e,t,n,r=5,a=1,s=1,i=.5){let o={x:e,y:t,dy:n},l={depthRadius:r,bias:a,alpha:s,beta:i};return Es.runKernel(Tn,o,l)}}),sy={kernelName:Nn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>ay(r,a,e,s,i,o,l)}}};function iy(e,t,n,r){return t.rank<n.rank&&(t=Zo(t,tu(t.shape,r))),e.rank<n.rank&&(e=Zo(e,tu(e.shape,r))),{x:()=>ko(e,go(Ul(n,t),e.dtype))}}var oy={kernelName:Cn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:a}=r,s=t[0],i=iy(e,t[1],s,pe(a,s.shape));return{x:()=>i.x()}}},ly={kernelName:En,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>ko(e,go(Su(n,r),"float32")),b:()=>ko(e,go($u(n,r),"float32"))}}};var uy=Us({maxPool3dGrad_:function(e,t,n,r,a,s,i){let o=Bs(e,"dy","maxPool3dGrad"),l=Bs(t,"input","maxPool3dGrad"),u=Bs(n,"output","maxPool3dGrad"),p=o,d=l,h=u,c=!1;4===l.rank&&(c=!0,p=Zo(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=Zo(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=Zo(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Y(5===p.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${p.rank}.`)),Y(5===d.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`)),Y(5===h.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`)),Yo("maxPool3dGrad",s,i);let f={dy:p,input:d,output:h},m={filterSize:r,strides:a,pad:s,dimRoundingMode:i},g=Es.runKernel(Rn,f,m);return c?Zo(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),py={kernelName:Fn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>uy(e,r,a,s,i,o,l)}}};var dy=Us({maxPoolGrad_:function(e,t,n,r,a,s,i){let o=Bs(e,"dy","maxPoolGrad"),l=Bs(t,"input","maxPoolGrad"),u=Bs(n,"output","maxPoolGrad");Y(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),Y(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),Y(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),Yo("maxPoolGrad",s,i);let p={dy:o,input:l,output:u},d={filterSize:r,strides:a,pad:s,dimRoundingMode:i};return Es.runKernel(An,p,d)}}),hy={kernelName:$n,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>dy(e,r,a,s,i,o)}}},cy={kernelName:Mn,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=pe(a,r.shape),i=Q(eu(r.shape,s)[1]);return{x:()=>{let t=r.shape.slice();s.forEach((e=>{t[e]=1}));let n=Zo(e,t);return vo(ko(n,lp(r.shape,"float32")),i)}}}},fy={kernelName:On,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:a}=r,[s,i]=t,o=iy(e,i,s,pe(a,s.shape));return{x:()=>o.x()}}},my={kernelName:Ln,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>ko(e,go(Au(n,r),"float32")),b:()=>ko(e,go(Iu(n,r),"float32"))}}},gy={kernelName:zn,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>rl(e,s,r.shape)}}},yy={kernelName:Pn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Vl(n.shape,r.shape);return{a:()=>{let t=Wl(n.shape,a);return t.length>0?Zo(hu(e,t),n.shape):e},b:()=>{let t=ko(e,Uu(vu(vo(n,r)))),s=Wl(r.shape,a);return s.length>0?Zo(hu(t,s),r.shape):t}}}},by={kernelName:Wn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Vl(n.shape,r.shape);return{a:()=>{let t=ko(e,go(r,"float32")),s=Wl(n.shape,a);return s.length>0?Zo(hu(t,s),n.shape):t},b:()=>{let t=ko(e,go(n,"float32")),s=Wl(r.shape,a);return s.length>0?Zo(hu(t,s),r.shape):t}}}},xy={kernelName:Vn,gradFunc:e=>({x:()=>Uu(e)})},wy={kernelName:Kn,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>op(n.shape,"float32")}}},vy={kernelName:qn,gradFunc:e=>({x:()=>Hl(e)})},ky={kernelName:Xn,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return Jd(e,r).map((e=>()=>e))}},Iy={kernelName:Yn,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>rl(e,s,r.shape)}}},Sy={kernelName:Jn,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,a]=t,s=n,i=r,o=Vl(s.shape,i.shape);return{a:()=>{let t=go(i,"float32"),n=ko(e,ko(t,lu(s,ju(t,uu(1))))),r=Wl(s.shape,o);return r.length>0&&(n=hu(n,r)),Zo(n,s.shape)},b:()=>{let t=Iu(s,0),n=Gl(t,Du(s),Hl(s)),r=ko(e,ko(a,n)),l=Wl(i.shape,o);return l.length>0&&(r=hu(r,l)),Zo(r,i.shape)}}}},Ny={kernelName:Qn,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,a=Iu(n,0);return{x:()=>Gl(a,e,ko(e,r)),alpha:()=>{let t=Gl(a,Hl(e),ko(e,n)),s=Wl(r.shape,e.shape);return s.length>0&&(t=hu(t,s)),Zo(t,r.shape)}}}};function Ty(e,t,n){let r=e.shape.length,a=r-n.length,s=Jf.getAxesPermutation(n,r),i=e;null!=s&&(i=ah(e,s));let o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=function(e,t,n){let r=e.shape.slice();r[n]=1;let a=Zo(t,r),s=Fl(e,n,!0,!1),i=Fl(e,n,!0,!0),o=ko(s,i);return ko(a,o)}(i.reshape(o),t,a);if(u=u.reshape(i.shape),null!=s){let e=Jf.getUndoAxesPermutation(s);u=ah(u,e)}return u}var _y={kernelName:er,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=[];return s=null==a?r.shape.map(((e,t)=>t)):"number"==typeof a?[a]:a,{x:()=>Ty(r,e,s)}}},Cy={kernelName:Wt,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Vl(n.shape,r.shape);return{a:()=>{let t=vo(e,go(r,"float32")),s=Wl(n.shape,a);return s.length>0?Zo(hu(t,s),n.shape):t},b:()=>{let t=ko(e,go(n,"float32")),s=Wl(r.shape,a);s.length>0&&(t=Zo(hu(t,s),r.shape));let i=du(r);return Uu(vo(t,go(i,"float32")))}}}},Ey={kernelName:ir,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>vo(e,Uu(du(n)))}}},$y={kernelName:cr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=ko(Au(n,6),Dd(n));return{x:()=>ko(e,go(r,"float32"))}}},Ay={kernelName:or,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ko(e,go(Dd(n),"float32"))}}},Fy={kernelName:lr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Zo(e,n.shape)}}},Ry={kernelName:dr,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>Es.runKernel(hr,a,n)}}},Dy={kernelName:ur,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>Es.runKernel(pr,a,n)}}},My={kernelName:fr,gradFunc:(e,t,n)=>{let{dims:r}=n,a=pe(r,e.shape);return{x:()=>ld(e,a)}}},Oy={kernelName:mr,gradFunc:e=>({x:()=>Hl(e)})},Ly={kernelName:gr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Uu(vo(e,ko(lu(n,1.5),2)))}}},zy={kernelName:wr,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>go(Hl(n),"float32"),t:()=>ko(e,go(n,e.dtype)),e:()=>ko(e,go(Yu(n),e.dtype))}}},Py={kernelName:vr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=Iu(n,uu(0)),r=uu(cm),a=uu(fm),s=ko(e,a),i=ko(ko(e,r),gu(go(n,"float32")));return Gl(t,s,i)}}}},By={kernelName:Tr,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ko(e,ko(n,ju(uu(1),n)))}}},Wy={kernelName:Nr,gradFunc:e=>({x:()=>Hl(e)})},Vy={kernelName:Ir,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ko($l(go(n,"float32")),e)}}},Uy={kernelName:Sr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ko(Al(go(n,"float32")),e)}}},Gy={kernelName:kr,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:a,size:s}=n,i=r.shape,[o,l]=Uf(r,a,s),u=[];for(let t=0;t<e.rank;t++)u.push([o[t],i[t]-o[t]-l[t]]);return{x:()=>wp(e,u)}}},Hy={kernelName:Fr,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:a}=n,s=ko(e,r);return{logits:()=>ju(s,ko(hu(s,[a],true),r))}}},jy={kernelName:_r,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ko(e,nl(n))}}},qy={kernelName:$r,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:a}=n;return{x:()=>il(e,r,a)}}},Ky={kernelName:Ar,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>el(e,r)}}},Xy={kernelName:Cr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>vo(e,ko(pu(go(n,"float32")),2))}}},Yy={kernelName:Pr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ko(e,ko(go(n,"float32"),2))}}},Zy={kernelName:zr,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=uu(2);return{a:()=>ko(e,ko(a,ju(n,r))),b:()=>ko(e,ko(a,ju(r,n)))}}},Jy={kernelName:ra,gradFunc:e=>({x:()=>Hl(e)})},Qy={kernelName:Hr,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Vl(n.shape,r.shape);return{a:()=>{let t=e,r=Wl(n.shape,a);return r.length>0&&(t=hu(t,r)),Zo(t,n.shape)},b:()=>{let t=e,n=Wl(r.shape,a);return n.length>0&&(t=hu(t,n)),Zo(Uu(t),r.shape)}}}},eb={kernelName:Er,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,a=r.shape.slice(),{axis:s}=n;pe(s,r.shape).forEach((e=>{a[e]=1}));let i=Zo(e,a),o=ko(i,lp(r.shape,"float32"));return{x:()=>o}}},tb={kernelName:jr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>vo(e,du($l(n)))}}},nb={kernelName:qr,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ko(ju(uu(1),du(n)),e)}}},rb={kernelName:Kr,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:a}=n;return{x:()=>{let t=Hl(r);if(1===r.rank)for(let n=0;n<a[0];++n)t=xo(t,rl(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)t=xo(t,rl(e,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)t=xo(t,rl(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)for(let o=0;o<a[3];++o)t=xo(t,rl(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},ab={kernelName:Zr,gradFunc:(e,t,n)=>{let r=n,{perm:a}=r,s=au(a);return{x:()=>ah(e,s)}}},sb={kernelName:Qr,gradFunc:(e,t,n)=>{let r=n,{axis:a}=r;return{value:()=>Rd(e,a)}}},ib={kernelName:ea,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>function(e,t){let n=sp(t,Hl(t)),r=ku(e,n),a=Su(t,uu(0,"int32")),s=r.rank-a.rank;for(let e=0;e<s;++e)a=yu(a,e+1);a=Xu(a,lp(r.shape,"bool"));let i=Hl(r);return Gl(a,r,i)}(e,n)}}};var ob={kernelName:na,gradFunc:e=>({x:()=>Hl(e)})},lb=[sg,ig,og,lg,ug,pg,dg,hg,cg,fg,mg,gg,bg,wg,vg,kg,Ig,Sg,Ng,Tg,_g,Cg,$g,Eg,Fg,Rg,Dg,Mg,Og,Lg,Cy,zg,Pg,Bg,Wg,Vg,Gg,Ug,Hg,jg,Xg,Yg,Zg,Jg,Qg,ey,ty,ny,ry,sy,oy,oy,ly,py,hy,cy,fy,my,gy,yy,by,xy,wy,vy,ky,Iy,Iy,Sy,Ny,_y,Ey,$y,Ay,Fy,Ry,Dy,My,Oy,Ly,zy,Py,By,Wy,Vy,Uy,Gy,Hy,jy,qy,qy,Ky,Ky,Xy,Zy,Yy,Jy,Qy,eb,tb,nb,rb,ab,sb,ib,ob];for(let e of lb)ya(e);os().prototype.abs=function(){return this.throwIfDisposed(),Io(this)},os().prototype.acos=function(){return this.throwIfDisposed(),So(this)},os().prototype.acosh=function(){return this.throwIfDisposed(),No(this)},os().prototype.add=function(e){return this.throwIfDisposed(),xo(this,e)},os().prototype.all=function(e,t){return this.throwIfDisposed(),_o(this,e,t)},os().prototype.any=function(e,t){return this.throwIfDisposed(),Co(this,e,t)},os().prototype.argMax=function(e){return this.throwIfDisposed(),Eo(this,e)},os().prototype.argMin=function(e){return this.throwIfDisposed(),$o(this,e)},os().prototype.asScalar=function(){return this.throwIfDisposed(),Y(1===this.size,(()=>"The array must have only 1 element.")),Zo(this,[])},os().prototype.asType=function(e){return this.throwIfDisposed(),go(this,e)},os().prototype.as1D=function(){return this.throwIfDisposed(),Zo(this,[this.size])},os().prototype.as2D=function(e,t){return this.throwIfDisposed(),Zo(this,[e,t])},os().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Zo(this,[e,t,n])},os().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),Zo(this,[e,t,n,r])},os().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),Zo(this,[e,t,n,r,a])},os().prototype.asin=function(){return this.throwIfDisposed(),Ao(this)},os().prototype.asinh=function(){return this.throwIfDisposed(),Fo(this)},os().prototype.atan=function(){return this.throwIfDisposed(),Ro(this)},os().prototype.atan2=function(e){return this.throwIfDisposed(),Do(this,e)},os().prototype.atanh=function(){return this.throwIfDisposed(),Mo(this)},os().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),Jo(this,e,t,n,r)},os().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),il(this,e,t)},os().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),ll(this,e,t,n,r,a)},os().prototype.broadcastTo=function(e){return this.throwIfDisposed(),ml(this,e)},os().prototype.cast=function(e){return this.throwIfDisposed(),go(this,e)},os().prototype.ceil=function(){return this.throwIfDisposed(),gl(this)},os().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),bl(this,e,t)},os().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof is&&(e=[e]),el([this,...e],t)},os().prototype.conv1d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Sl(this,e,t,n,r,a,s)},os().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),Tl(this,e,t,n,r,a)},os().prototype.conv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Il(this,e,t,n,r,a,s)},os().prototype.cos=function(){return this.throwIfDisposed(),$l(this)},os().prototype.cosh=function(){return this.throwIfDisposed(),Al(this)},os().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Fl(this,e,t,n)},os().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Rl(this,e,t,n)},os().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),Ml(this,e,t)},os().prototype.depthwiseConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Ol(this,e,t,n,r,a,s)},os().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),zl(this,e,t,n,r,a)},os().prototype.divNoNan=function(e){return this.throwIfDisposed(),jl(this,e)},os().prototype.div=function(e){return this.throwIfDisposed(),vo(this,e)},os().prototype.dot=function(e){return this.throwIfDisposed(),ql(this,e)},os().prototype.elu=function(){return this.throwIfDisposed(),Xl(this)},os().prototype.equal=function(e){return this.throwIfDisposed(),Ul(this,e)},os().prototype.erf=function(){return this.throwIfDisposed(),Zl(this)},os().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),mu(this,e,t)},os().prototype.exp=function(){return this.throwIfDisposed(),gu(this)},os().prototype.expandDims=function(e){return this.throwIfDisposed(),yu(this,e)},os().prototype.expm1=function(){return this.throwIfDisposed(),bu(this)},os().prototype.fft=function(){return this.throwIfDisposed(),Td(this)},os().prototype.flatten=function(){return this.throwIfDisposed(),Zo(this,[this.size])},os().prototype.floor=function(){return this.throwIfDisposed(),vu(this)},os().prototype.floorDiv=function(e){return this.throwIfDisposed(),wo(this,e)},os().prototype.gather=function(e,t,n){return this.throwIfDisposed(),ku(this,e,t,n)},os().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Su(this,e)},os().prototype.greater=function(e){return this.throwIfDisposed(),Iu(this,e)},os().prototype.ifft=function(){return this.throwIfDisposed(),_d(this)},os().prototype.irfft=function(){return this.throwIfDisposed(),Cd(this)},os().prototype.isFinite=function(){return this.throwIfDisposed(),Tu(this)},os().prototype.isInf=function(){return this.throwIfDisposed(),_u(this)},os().prototype.isNaN=function(){return this.throwIfDisposed(),Cu(this)},os().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Eu(this,e)},os().prototype.lessEqual=function(e){return this.throwIfDisposed(),Au(this,e)},os().prototype.less=function(e){return this.throwIfDisposed(),$u(this,e)},os().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),Ru(this,e,t,n,r)},os().prototype.logSigmoid=function(){return this.throwIfDisposed(),Hu(this)},os().prototype.logSoftmax=function(e){return this.throwIfDisposed(),qu(this,e)},os().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Ku(this,e,t)},os().prototype.log=function(){return this.throwIfDisposed(),Du(this)},os().prototype.log1p=function(){return this.throwIfDisposed(),Mu(this)},os().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Xu(this,e)},os().prototype.logicalNot=function(){return this.throwIfDisposed(),Yu(this)},os().prototype.logicalOr=function(e){return this.throwIfDisposed(),Zu(this,e)},os().prototype.logicalXor=function(e){return this.throwIfDisposed(),Ju(this,e)},os().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),tl(this,e,t,n)},os().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),np(this,e,t,n,r)},os().prototype.max=function(e,t){return this.throwIfDisposed(),iu(this,e,t)},os().prototype.maximum=function(e){return this.throwIfDisposed(),sp(this,e)},os().prototype.mean=function(e,t){return this.throwIfDisposed(),ip(this,e,t)},os().prototype.min=function(e,t){return this.throwIfDisposed(),ou(this,e,t)},os().prototype.minimum=function(e){return this.throwIfDisposed(),pp(this,e)},os().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),dp(this,e,t)},os().prototype.mod=function(e){return this.throwIfDisposed(),hp(this,e)},os().prototype.mul=function(e){return this.throwIfDisposed(),ko(this,e)},os().prototype.neg=function(){return this.throwIfDisposed(),Uu(this)},os().prototype.norm=function(e,t,n){return this.throwIfDisposed(),fu(this,e,t,n)},os().prototype.notEqual=function(e){return this.throwIfDisposed(),gp(this,e)},os().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),yp(this,e,t,n)},os().prototype.onesLike=function(){return this.throwIfDisposed(),bp(this)},os().prototype.pad=function(e,t){return this.throwIfDisposed(),wp(this,e,t)},os().prototype.pool=function(e,t,n,r,a,s){return this.throwIfDisposed(),Tp(this,e,t,n,r,a,s)},os().prototype.pow=function(e){return this.throwIfDisposed(),lu(this,e)},os().prototype.prelu=function(e){return this.throwIfDisposed(),_p(this,e)},os().prototype.prod=function(e,t){return this.throwIfDisposed(),Cp(this,e,t)},os().prototype.reciprocal=function(){return this.throwIfDisposed(),sd(this)},os().prototype.relu=function(){return this.throwIfDisposed(),id(this)},os().prototype.relu6=function(){return this.throwIfDisposed(),od(this)},os().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Zo(this,e.shape)},os().prototype.reshape=function(e){return this.throwIfDisposed(),Zo(this,e)},os().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),Xh(this,e,t,n)},os().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),Yh(this,e,t,n)},os().prototype.reverse=function(e){return this.throwIfDisposed(),ld(this,e)},os().prototype.rfft=function(){return this.throwIfDisposed(),$d(this)},os().prototype.round=function(){return this.throwIfDisposed(),cd(this)},os().prototype.rsqrt=function(){return this.throwIfDisposed(),fd(this)},os().prototype.selu=function(){return this.throwIfDisposed(),md(this)},os().prototype.separableConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),gd(this,e,t,n,r,a,s)},os().prototype.sigmoid=function(){return this.throwIfDisposed(),nl(this)},os().prototype.sign=function(){return this.throwIfDisposed(),bd(this)},os().prototype.sin=function(){return this.throwIfDisposed(),xd(this)},os().prototype.sinh=function(){return this.throwIfDisposed(),wd(this)},os().prototype.slice=function(e,t){return this.throwIfDisposed(),rl(this,e,t)},os().prototype.softmax=function(e){return this.throwIfDisposed(),Nd(this,e)},os().prototype.softplus=function(){return this.throwIfDisposed(),Gu(this)},os().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),Np(this,e,t)},os().prototype.split=function(e,t){return this.throwIfDisposed(),Ed(this,e,t)},os().prototype.sqrt=function(){return this.throwIfDisposed(),pu(this)},os().prototype.square=function(){return this.throwIfDisposed(),du(this)},os().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Ad(this,e)},os().prototype.squeeze=function(e){return this.throwIfDisposed(),Fd(this,e)},os().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof is?[this,e]:[this,...e];return Rd(n,t)},os().prototype.step=function(e){return this.throwIfDisposed(),Dd(this,e)},os().prototype.stridedSlice=function(e,t,n,r,a,s,i,o){return this.throwIfDisposed(),Md(this,e,t,n,r,a,s,i,o)},os().prototype.sub=function(e){return this.throwIfDisposed(),ju(this,e)},os().prototype.sum=function(e,t){return this.throwIfDisposed(),hu(this,e,t)},os().prototype.tan=function(){return this.throwIfDisposed(),Od(this)},os().prototype.tanh=function(){return this.throwIfDisposed(),al(this)},os().prototype.tile=function(e){return this.throwIfDisposed(),xu(this,e)},os().prototype.toBool=function(){return this.throwIfDisposed(),go(this,"bool")},os().prototype.toFloat=function(){return this.throwIfDisposed(),go(this,"float32")},os().prototype.toInt=function(){return this.throwIfDisposed(),go(this,"int32")},os().prototype.topk=function(e,t){return this.throwIfDisposed(),Kd(this,e,t)},os().prototype.transpose=function(e){return this.throwIfDisposed(),ah(this,e)},os().prototype.unique=function(e){return this.throwIfDisposed(),Yd(this,e)},os().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Zd(this,e,t)},os().prototype.unstack=function(e){return this.throwIfDisposed(),Jd(this,e)},os().prototype.where=function(e,t){return this.throwIfDisposed(),Gl(e,this,t)},os().prototype.zerosLike=function(){return this.throwIfDisposed(),Hl(this)};var ub=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},pb=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},db=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},hb=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},cb=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},fb=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}};function mb(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{let n=new Array(t);return n.fill(e),n}}function gb(e,t){if(!e)throw new cb(t)}function yb(e,t){let n=0;for(let r of e)r===t&&n++;return n}function bb(e){return 1===e.length?e[0]:e}function xb(e){return Array.isArray(e)?e:[e]}function wb(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function vb(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}var kb={};function Ib(e){if(null==e)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Sb(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach((e=>Sb(e)));else{let t=Object.keys(e);for(let n of t){let t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?Sb(t):e[n]=t.value)}}}function Nb(e,t={},n={},r="object",a=!1){if("string"==typeof e){let a,s=e;if(s in n)a=n[s];else if(s in kb)a=kb[s];else if(a=t[s],null==a)throw new db(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{let s=e;if(null==s.className||null==s.config)throw new db(`${r}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);let i,o,l=s.className;if(l in n?[i,o]=n[l]:l in kb?[i,o]=kb.className:l in t&&([i,o]=t[l]),null==i)throw new db(`Unknown ${r}: ${l}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=o){let e={};for(let t of Object.keys(kb))e[t]=kb[t];for(let t of Object.keys(n))e[t]=n[t];s.config.customObjects=e;let t=Object.assign({},kb);for(let e of Object.keys(n))kb[e]=n[e];Sb(s.config);let r=o(i,s.config,n,a);return kb=Object.assign({},t),r}{let e=Object.assign({},kb);for(let e of Object.keys(n))kb[e]=n[e];let t=new i(s.config);return kb=Object.assign({},e),t}}}function Tb(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function _b(e){if(null==e)return e;let t=[];for(let n of e)-1===t.indexOf(n)&&t.push(n);return t}function Cb(e){if(null==e)throw new db(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function Eb(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new db(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function $b(e,t,n=0,r=1/0){return gb(n>=0),gb(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function Ab(e,t){Array.isArray(e)?(ka.assert(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>Ab(e,`element ${n+1} of ${t}`)))):ka.assert(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${Fb(e)}.`))}function Fb(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>Fb(e))).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function Rb(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}var Db=0;function Mb(){return Db++}var Ob={};function Lb(e=""){return e in Ob||(Ob[e]=0),Ob[e]+=1,e+Ob[e].toString()}var zb=["channelsFirst","channelsLast"],Pb=["nearest","bilinear"],Bb=["valid","same","causal"],Wb=["max","avg"],Vb=["sum","mul","concat","ave"],Ub=new Map;function Gb(e){Eb(zb,"DataFormat",e)}function Hb(e){Eb(Bb,"PaddingMode",e)}function jb(e){Eb(Wb,"PoolMode",e)}var qb=[],Kb="/";function Xb(e,t){qb.push(e);try{let e=t();return qb.pop(),e}catch(e){throw qb.pop(),e}}function Yb(e){if(!ex(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===qb.length?"":qb.join(Kb)+Kb)+e}function Zb(e){if(!ex(e))throw new Error("Not a valid tensor name: '"+e+"'");Ub.has(e)||Ub.set(e,0);let t=Ub.get(e);if(Ub.set(e,Ub.get(e)+1),t>0){let n=`${e}_${t}`;return Ub.set(n,1),n}return e}var Jb,Qb=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function ex(e){return!!e.match(Qb)}function tx(e){return e===parseInt(e.toString(),10)}function nx(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function rx(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function ax(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function sx(e,t){if(t<e)throw new db(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}function ix(){return null==Jb&&(Jb=fi().epsilon()),Jb}function ox(e,t){return go(e,t)}function lx(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Zo(e,n)}function ux(e,t,n){return ri((()=>{switch(e.rank){case 1:return vd(e,t,n);case 2:return kd(e,[t,0],[n,e.shape[1]]);case 3:return Id(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Sd(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return rl(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return rl(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new db(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function px(e,t,n){return ri((()=>{switch(e.rank){case 1:return vd(e,t,n);case 2:return kd(e,[0,t],[e.shape[0],n]);case 3:return Id(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Sd(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new db(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function dx(e,t,n,r){return ri((()=>{switch(e.rank){case 1:return vd(e,t,n);case 2:switch(r){case 1:return ux(e,t,n);case 2:return px(e,t,n);default:throw new db(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return ux(e,t,n);case 2:return Id(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return px(e,t,n);default:throw new db(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return ux(e,t,n);case 2:return Sd(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Sd(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return px(e,t,n);default:throw new db(`The axis is not within the rank of the tensor ${r}`)}default:throw new db(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function hx(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),el(e,t)}function cx(e,t){switch(e.rank){case 1:return xl([e,t]);case 2:return wl([e,t],0);case 3:return vl([e,t],0);case 4:return kl([e,t],0);default:throw new db(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function fx(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new db(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return xu(e,t)}function mx(e,t=0,n=1,r,a){return Qp(e,t,n,r,a)}function gx(e,t,n,r){if(e.rank<2||t.rank<2)throw new hb(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new hb(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank)return ch.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?xx(e.rank,r,"channelsLast"):null,activation:n});{let a=e.shape.slice(),s=a.pop();e=Zo(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],p=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=Zo(ah(t,p),[l,-1]);let d=[...a,...u];return Zo(ch.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?xx(e.rank,r,"channelsLast"):null,activation:n}),d)}}function yx(e,t,n){return ri((()=>(t=Array.isArray(t)?Ld(t,"int32"):go(t,"int32"),ku(e,t,n))))}function bx(e){return ko(e,e)}function xx(e,t,n){let r=t.shape;if(1!==t.rank&&t.rank!==e)throw new db(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?Zo(t,[1,r[0],1,1,1]):Zo(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?Zo(t,[1,1,1,1,r[0]]):Zo(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?Zo(t,[1,r[0],1,1]):Zo(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?Zo(t,[1,1,1,r[0]]):Zo(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?Zo(t,[1,r[0],1]):Zo(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?Zo(t,[1,1,r[0]]):Zo(t,[1].concat(r))}else if(e<3)return t;throw new db(`Unsupported input rank by biasAdd: ${t.rank}`)}function wx(e,t,n){return ri((()=>(null==n&&(n="channelsLast"),Gb(n),xo(e,xx(e.rank,t,n)))))}function vx(e,t,n,r){return ri((()=>uh(e,t,n,r)))}function kx(e,t,n=!1){return n?e():t()}var Ix=["fanIn","fanOut","fanAvg"],Sx=["normal","uniform","truncatedNormal"];var Nx=class extends Cc.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},Tx=class extends Nx{apply(e,t){return op(e,t)}};Tx.className="Zeros",Cc.registerClass(Tx);var _x=class extends Nx{apply(e,t){return lp(e,t)}};_x.className="Ones",Cc.registerClass(_x);var Cx=class extends Nx{constructor(e){if(super(),"object"!=typeof e)throw new db(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new db(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return ri((()=>ko(uu(this.value),lp(e,t))))}getConfig(){return{value:this.value}}};Cx.className="Constant",Cc.registerClass(Cx);var Ex=class extends Nx{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return td(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};Ex.className="RandomUniform",Cc.registerClass(Ex);var $x=class extends Nx{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new hb(`randomNormal does not support dType ${t}.`);return mx(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};$x.className="RandomNormal",Cc.registerClass($x);var Ax=class extends Nx{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new hb(`truncatedNormal does not support dType ${t}.`);return Xd(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Ax.className="TruncatedNormal",Cc.registerClass(Ax);var Fx=class extends Nx{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return ri((()=>{if(2!==e.length||e[0]!==e[1])throw new db("Identity matrix initializer can only be used for 2D square matrices.");return ko(this.gain,wu(e[0]))}))}getConfig(){return{gain:this.gain}}};Fx.className="Identity",Cc.registerClass(Fx);var Rx=class extends Nx{constructor(e){if(super(),e.scale<0)throw new db(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function(e){Eb(Ix,"FanMode",e)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function(e){Eb(Sx,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){let n=function(e,t="channelsLast"){let n,r;if(Gb(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){let t=nx(e,2);n=e[1]*t,r=e[0]*t}else if("channelsLast"===t){let t=nx(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{let t=nx(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}(e),r=n[0],a=n[1],s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){let n=Math.sqrt(s);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new hb(`${this.getClassName()} does not support dType ${t}.`);return Xd(e,0,n,t,this.seed)}{let n=Math.sqrt(3*s);return td(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};Rx.className="VarianceScaling",Cc.registerClass(Rx);var Dx=class extends Rx{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Rx.className}};Dx.className="GlorotUniform",Cc.registerClass(Dx);var Mx=class extends Rx{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Rx.className}};Mx.className="GlorotNormal",Cc.registerClass(Mx);var Ox=class extends Rx{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Rx.className}};Ox.className="HeNormal",Cc.registerClass(Ox);var Lx=class extends Rx{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Rx.className}};Lx.className="HeUniform",Cc.registerClass(Lx);var zx=class extends Rx{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Rx.className}};zx.className="LeCunNormal",Cc.registerClass(zx);var Px=class extends Rx{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Rx.className}};Px.className="LeCunUniform",Cc.registerClass(Px);var Bx=class extends Nx{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return ri((()=>{if(e.length<2)throw new hb("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);let n=ka.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);let s=mx([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=Sc.qr(s,!1),o=i[0],l=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return o=ko(o,l.sign()),n<r&&(o=o.transpose()),ko(uu(this.gain),o.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}};Bx.className="Orthogonal",Cc.registerClass(Bx);var Wx={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Vx(e,t={}){return Nb(e,Cc.SerializationMap.getMap().classNameMap,t,"initializer")}function Ux(e){return Ib(e)}function Gx(e){if("string"==typeof e){let t=e in Wx?Wx[e]:e;if("GlorotNormal"===t)return new Mx;if("GlorotUniform"===t)return new Dx;if("HeNormal"===t)return new Ox;if("HeUniform"===t)return new Lx;if("LeCunNormal"===t)return new zx;if("LeCunUniform"===t)return new Px;{let e={};return e.className=t,e.config={},Vx(e)}}return e instanceof Nx?e:Vx(e)}function Hx(e){return Array.isArray(e)&&Array.isArray(e[0])}function jx(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function qx(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new db(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function Kx(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new db(`Expected exactly 1 Shape; got ${e.length}`)}return e}function Xx(e){let t=0;for(let n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}var Yx="Variable",Zx=class{constructor(e,t="float32",n=Yx,r=!0,a=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=Mb(),n=null==n?Yx:n,this.originalName=Yb(n),this.name=Zb(this.originalName),this.trainable_=r,this.constraint=a,this.val=eh(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function Jx(e){return e.map((e=>e.read()))}function Qx(e){e.forEach((e=>{e[0].write(e[1])}))}var ew=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},tw=class{constructor(e,t,n,r,a,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=Mb(),null!=s&&(this.originalName=Yb(s),this.name=Zb(this.originalName)),this.rank=t.length}},nw=0,rw=class{constructor(e,t){this.callArgs=t,this.id=nw++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let t of e.inboundLayers)null!=t&&t.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},aw=0,sw=class extends Cc.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=aw++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let e=this.getClassName();t=wb(e)+"_"+Lb(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new pb(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new db(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return bb(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return bb(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ub(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new ub(`Layer ${this.name} is not connected, no input to return.`);return bb(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new ub(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new ub(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return bb(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=xb(e);if(null==this.inputSpec||0===this.inputSpec.length)return;let n=xb(this.inputSpec);if(t.length!==n.length)throw new db(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let e=0;e<t.length;e++){let r=t[e],a=n[e];if(null==a)continue;let s=r.rank;if(null!=a.ndim&&s!==a.ndim)throw new db(`Input ${e} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${s}`);if(null!=a.maxNDim&&s>a.maxNDim)throw new db(`Input ${e} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${s}`);if(null!=a.minNDim&&s<a.minNDim)throw new db(`Input ${e} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${s}.`);if(null!=a.dtype&&r.dtype!==a.dtype)throw new db(`Input ${e} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${r.dtype}.`);if(a.axes){let t=r.shape;for(let n in a.axes){let r=Number(n),s=a.axes[n],i=r>=0?t[r]:t[t.length+r];if(null!=s&&-1===[s,null].indexOf(i))throw new db(`Input ${e} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${s} but got shape ${t}.`)}}if(null!=a.shape)for(let t=0;t<a.shape.length;++t){let n=a.shape[t],s=r.shape[t];if(null!=n&&null!=s&&n!==s)throw new db(`Input ${e} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=xb(e),r=function(e){let t=!0;for(let n of xb(e))if(!(n instanceof tw)){t=!1;break}return t}(e),a=function(e){let t=!0;for(let n of xb(e))if(n instanceof tw){t=!1;break}return t}(e);if(r===a)throw new db("Arguments to apply() must be all SymbolicTensors or all Tensors");return Xb(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);let t=[];for(let n of xb(e))t.push(n.shape);this.build(bb(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);let a=xb(r),s=[];for(let e of a)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(r=bb(s),null!=this.activityRegularizer)throw new hb("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{let n,r=function(e){e=xb(e);let t=[];for(let n of e)t.push(n.shape);return bb(t)}(e),a=this.computeOutputShape(r),s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?r[0]:r),n=null!=a&&a.length>0&&Array.isArray(a[0])?a.map(((n,r)=>new tw(s,n,this,xb(e),t,this.name,r))):new tw(s,a,this,xb(e),t,this.name),this.addInboundNode(e,n,null,null,r,a,t),this._refCount++,null!=this.activityRegularizer)throw new hb("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return n}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new ub(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new ub(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new pb(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Xx(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Jx(e?this.trainableWeights:this.weights)}setWeights(e){ri((()=>{let t=this.weights;if(t.length!==e.length)throw new db(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;let n=[],r=Jx(t);for(let a=0;a<r.length;++a){let s=r[a],i=t[a],o=e[a];if(!ka.arraysEqual(s.shape,o.shape))throw new db(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}Qx(n)}))}addWeight(e,t,n,r,a,s,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new db(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():Gx("zeros"));let l=r.apply(t,n),u=new Zx(l,n,e,s,i);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(u.read()))),null==s&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=xb(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let r=this.computeMask(e,n),a=xb(t),s=xb(r);if(a.length!==s.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let e=0;e<a.length;e++)a[e].kerasMask=s[e]}addInboundNode(e,t,n,r,a,s,i=null){let o=xb(e);t=xb(t),n=xb(n),r=xb(r),a=jx(a),s=jx(s);let l=[],u=[],p=[];for(let e of o)l.push(e.sourceLayer),u.push(e.nodeIndex),p.push(e.tensorIndex);new rw({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:p,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},i);for(let e=0;e<t.length;e++)t[e].sourceLayer=this,t[e].nodeIndex=this.inboundNodes.length-1,t[e].tensorIndex=e}getConfig(){let e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function iw(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{let e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{let t=[];for(let n=0;n<e.inboundLayers.length;n++){let r=iw(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(let e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}var ow=class extends sw{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:Lb("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new db("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new db("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new db("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new tw(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new rw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new db(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};function lw(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new db("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new ow({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}ow.className="InputLayer",Cc.registerClass(ow);var uw=class e{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof e)for(let e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(let e of t)this.add(e.key,e.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new db(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return go(t,e.dtype)}catch(n){throw new db(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof tw){if(null==this.id2Value[e.id])throw new db(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{let t=this.name2Id[e];if(null==t)throw new db(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof tw){if(null==this.id2Value[e.id])throw new db(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{let t=this.name2Id[e];if(null==t)throw new db(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&ai(this.id2Mask)}},pw=new fb,dw=new fb;function hw(e,t,n,r){let a=null!=n&&n.training,s=Array.isArray(e),i=s?e:[e],o=i.map((e=>e.name)),l=[],u=t.names();for(let e of o)-1!==u.indexOf(e)?l.push(t.getValue(e)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let p,d=o.join(",")+"|"+t.names().sort().join(","),h=pw.get(d);if(null==h){let e=function(e,t){ka.assert(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){let a=fw(e[0],t);n=a.sorted,r=a.recipientMap}else{let a=new Set;for(let s of e){let{sorted:e,recipientMap:i}=fw(s,t);for(let t of e)a.has(t.name)||(n.push(t),a.add(t.name));for(let e in i)null==r[e]&&(r[e]=new Set),i[e].forEach((t=>r[e].add(t)))}}return{sorted:n,recipientCounts:cw(r)}}(i,t);h=e.sorted,p=e.recipientCounts,pw.put(d,h),dw.put(d,p)}p={},a||Object.assign(p,dw.get(d));let c=new uw(t);for(let e=0;e<h.length;++e){if(null!=r){let e=ti().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}let s=h[e],i=s.sourceLayer;if(i instanceof ow)continue;let u=[],d=[],f=[],m=!1;for(let e of s.inputs){let n=c.getValue(e),r=c.getMask(e);u.push(n),d.push(r),null!=r&&(m=!0),a||(p[e.name]--,0===p[e.name]&&!t.hasKey(e)&&-1===o.indexOf(e.name)&&!n.isDisposed&&!0!==e.sourceLayer.stateful&&f.push(n))}m&&((n=n||{}).mask=d[0]);let g=xb(i.apply(u,n)),y=null;i.supportsMasking&&(y=i.computeMask(u,d));let b=mw(s),x=Array.isArray(b)?b:[b];for(let e=0;e<x.length;++e){c.hasKey(x[e])||c.add(x[e],g[e],Array.isArray(y)?y[0]:y);let t=o.indexOf(x[e].name);-1!==t&&(l[t]=g[e])}a||ai(f)}return c.disposeMasks(),s?l:l[0]}function cw(e){let t={};for(let n in e)t[n]=e[n].size;return t}function fw(e,t){let n=new Set,r=[],a={};for(let e of t.names())n.add(e);let s=[],i=[];for(s.push(e);s.length>0;){let e=s[s.length-1];if(n.has(e.name)){s.pop();continue}let t=i[i.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(s.length-1);for(let t of e.inputs)null==a[t.name]&&(a[t.name]=new Set),a[t.name].add(e.name),!n.has(t.name)&&s.push(t)}}return{sorted:r,recipientMap:a}}function mw(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(let r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}Pe().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=pw&&pw.setMaxEntries(e),null!=dw&&dw.setMaxEntries(e)}));var gw={};function yw(e,t){return ri((()=>pu(hu(ko(e,e),t,!0))))}g(gw,{maxNorm:()=>_w,minMaxNorm:()=>$w,nonNeg:()=>Ew,unitNorm:()=>Cw});var bw=class extends Cc.Serializable{getConfig(){return{}}},xw=class extends bw{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return ri((()=>{let t=yw(e,this.axis),n=bl(t,0,this.maxValue);return ko(e,vo(n,xo(ix(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};xw.className="MaxNorm",Cc.registerClass(xw);var ww=class extends bw{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return ri((()=>vo(e,xo(ix(),yw(e,this.axis)))))}getConfig(){return{axis:this.axis}}};ww.className="UnitNorm",Cc.registerClass(ww);var vw=class extends bw{apply(e){return id(e)}};vw.className="NonNeg",Cc.registerClass(vw);var kw=class extends bw{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return ri((()=>{let t=yw(e,this.axis),n=xo(ko(this.rate,bl(t,this.minValue,this.maxValue)),ko(1-this.rate,t));return ko(e,vo(n,xo(ix(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};kw.className="MinMaxNorm",Cc.registerClass(kw);var Iw={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Sw(e){return Ib(e)}function Nw(e,t={}){return Nb(e,Cc.SerializationMap.getMap().classNameMap,t,"constraint")}function Tw(e){if(null==e)return null;if("string"==typeof e){return Nw({className:e in Iw?Iw[e]:e,config:{}})}return e instanceof bw?e:Nw(e)}function _w(e){return new xw(e)}function Cw(e){return new ww(e)}function Ew(){return new vw}function $w(e){return new kw(e)}var Aw={};function Fw(){return new Tx}function Rw(){return new _x}function Dw(e){return new Cx(e)}function Mw(e){return new Ex(e)}function Ow(e){return new $x(e)}function Lw(e){return new Ax(e)}function zw(e){return new Fx(e)}function Pw(e){return new Rx(e)}function Bw(e){return new Dx(e)}function Ww(e){return new Mx(e)}function Vw(e){return new Ox(e)}function Uw(e){return new Lx(e)}function Gw(e){return new zx(e)}function Hw(e){return new Px(e)}function jw(e){return new Bx(e)}g(Aw,{constant:()=>Dw,glorotNormal:()=>Ww,glorotUniform:()=>Bw,heNormal:()=>Vw,heUniform:()=>Uw,identity:()=>zw,leCunNormal:()=>Gw,leCunUniform:()=>Hw,ones:()=>Rw,orthogonal:()=>jw,randomNormal:()=>Ow,randomUniform:()=>Mw,truncatedNormal:()=>Lw,varianceScaling:()=>Pw,zeros:()=>Fw});var qw,Kw={};async function Xw(e){if(null==e)return;let t=[],n=[],r=[];for(let a in e){let s=e[a];if("number"!=typeof s){let e=s;t.push(e.data()),n.push(a),r.push(e)}}if(t.length>0){let a=await Promise.all(t);for(let t=0;t<a.length;++t)e[n[t]]=a[t][0];ai(r)}}function Yw(e){if(null!=e)for(let t in e){let n=e[t];"number"!=typeof n&&n.dispose()}}g(Kw,{Layer:()=>sw,RNN:()=>pI,RNNCell:()=>dI,activation:()=>US,add:()=>JS,alphaDropout:()=>VN,average:()=>QS,averagePooling1d:()=>lN,averagePooling2d:()=>dN,averagePooling3d:()=>fN,avgPool1d:()=>uN,avgPool2d:()=>hN,avgPool3d:()=>mN,avgPooling1d:()=>pN,avgPooling2d:()=>cN,avgPooling3d:()=>gN,batchNormalization:()=>sN,bidirectional:()=>DN,categoryEncoding:()=>qN,centerCrop:()=>HN,concatenate:()=>eN,conv1d:()=>DS,conv2d:()=>MS,conv2dTranspose:()=>OS,conv3d:()=>LS,conv3dTranspose:()=>zS,convLstm2d:()=>$N,convLstm2dCell:()=>AN,cropping2D:()=>BS,dense:()=>GS,depthwiseConv2d:()=>VS,dot:()=>aN,dropout:()=>HS,elu:()=>CS,embedding:()=>ZS,flatten:()=>qS,gaussianDropout:()=>WN,gaussianNoise:()=>BN,globalAveragePooling1d:()=>yN,globalAveragePooling2d:()=>bN,globalMaxPool1d:()=>ON,globalMaxPool2d:()=>LN,globalMaxPooling1d:()=>xN,globalMaxPooling2d:()=>wN,gru:()=>SN,gruCell:()=>NN,input:()=>uk,inputLayer:()=>_S,layerNormalization:()=>iN,leakyReLU:()=>$S,lstm:()=>TN,lstmCell:()=>_N,masking:()=>UN,maxPool1d:()=>zN,maxPool2d:()=>PN,maxPooling1d:()=>vN,maxPooling2d:()=>kN,maxPooling3d:()=>IN,maximum:()=>tN,minimum:()=>nN,multiply:()=>rN,permute:()=>YS,prelu:()=>AS,randomWidth:()=>KN,reLU:()=>ES,repeatVector:()=>KS,rescaling:()=>GN,reshape:()=>XS,resizing:()=>jN,rnn:()=>FN,separableConv2d:()=>PS,simpleRNN:()=>CN,simpleRNNCell:()=>EN,softmax:()=>FS,spatialDropout1d:()=>jS,stackedRNNCells:()=>RN,thresholdedReLU:()=>RS,timeDistributed:()=>MN,upSampling2d:()=>WS,zeroPadding2d:()=>oN}),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(qw||(qw={}));var Zw=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},Jw=class{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},Qw=class extends Zw{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});let n=null==t.size?0:t.size;this.seen+=n;for(let e in t){let r=t[e];if("number"==typeof r)this.totals.hasOwnProperty(e)||(this.totals[e]=0),this.totals[e]=this.totals[e]+r*n;else{let t;e in this.totals?t=this.totals[e]:this.totals[e]=0;let a=ri((()=>xo(this.totals[e],ko(r,n))));this.totals[e]=a,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(let e of this.params.metrics)null!=this.totals[e]&&("number"==typeof this.totals[e]?t[e]=this.totals[e]/this.seen:ri((()=>{let n=ko(vo(1,this.seen),this.totals[e]);t[e]=n,this.totals[e].dispose(),si(t[e])})))}},ev=class extends Zw{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(let e in t)null==this.history[e]&&(this.history[e]=[]),this.history[e].push(t[e])}async syncData(){let e=[],t=[],n=[];for(let r in this.history){let a=this.history[r];for(let s=0;s<a.length;++s)if("number"!=typeof a[s]){let i=a[s];e.push(i.data()),t.push(r),n.push(s)}}let r=await Promise.all(e);for(let e=0;e<r.length;++e)this.history[t[e]][n[e]].dispose(),this.history[t[e]][n[e]]=r[e][0]}},tv=class extends Zw{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Yf,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");ka.isNumber(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,a=null!=n?n():ka.now();return(...s)=>{let i=null!=n?n():ka.now();return i-a<t||(a=i,r=e(...s)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];null!=this.yield&&(await Xw(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await Xw(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];null!=this.epochEnd&&(await Xw(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await Xw(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];null!=this.batchEnd&&(await Xw(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):ka.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await Xw(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await Xw(e),await this.trainEnd(e))}};function nv(e,t){return null==e&&(e={}),e instanceof Zw?[e]:Array.isArray(e)&&e[0]instanceof Zw?e:xb(e).map((e=>new tv(e,t)))}var rv=class e{constructor(){}static registerCallbackConstructor(t,n){ka.assert(t>=0&&Number.isInteger(t),(()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`)),e.checkForDuplicate(n),null==e.constructors[t]&&(e.constructors[t]=[]),e.constructors[t].push(n)}static checkForDuplicate(t){for(let n in e.constructors)e.constructors[+n].forEach((e=>{if(e===t)throw new db("Duplicate callback constructor.")}))}static clear(){e.constructors={}}static createCallbacks(t){let n=[];for(let r in e.constructors){let a=+r;t>=a&&n.push(...e.constructors[a])}return n.map((e=>new e))}};function av(e,t,n,r,a,s,i,o,l){let u=new ev,p=[new Qw,...rv.createCallbacks(t)];null!=e&&p.push(...e),p.push(u);let d=new Jw(p);return d.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}function sv(e,t={},n=!1){return Nb(e,Cc.SerializationMap.getMap().classNameMap,t,"layer",n)}function iv(e,t){return ri((()=>{"float32"!==e.dtype&&(e=go(e,"float32"));let n=hu(bx(e),t,!0),r=yl(n.shape,ix()),a=pu(sp(n,r));return vo(e,a)}))}function ov(e,t){return ri((()=>ip(bx(ju(t,e)),-1)))}function lv(e,t){return ri((()=>ip(Io(ju(t,e)),-1)))}function uv(e,t){return ri((()=>{let n=ju(e,t),r=bl(Io(e),ix(),Number.MAX_VALUE),a=Io(vo(n,r));return ko(100,ip(a,-1))}))}function pv(e,t,n=!1){return ri((()=>{if(n)t=Nd(t);else{let e=hu(t,t.shape.length-1,!0);t=vo(t,e)}return t=bl(t,ix(),1-ix()),Uu(hu(ko(go(e,"float32"),Du(t)),t.shape.length-1))}))}function dv(e,t,n=!1){return ri((()=>{let r=go(vu(function(e){let t=[nx(e.shape)];return Zo(e,t)}(e)),"int32"),a=(t=bl(t,ix(),1-ix())).shape;return pv(Zo(yp(r,a[a.length-1]),a),t,n)}))}function hv(e,t){return ri((()=>{let n;return n=bl(t,ix(),1-ix()),n=Du(vo(n,ju(1,n))),ip(function(e,t){if(!ka.arraysEqual(e.shape,t.shape))throw new db(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return ri((()=>{let n=id(t),r=Uu(Io(t));return xo(ju(n,ko(t,e)),Mu(gu(r)))}))}(e,n),-1)}))}function cv(e,t){return ri((()=>{let n=iv(e,-1),r=iv(t,-1),a=ko(n,r);return Uu(hu(a,-1))}))}rv.constructors={};var fv={meanSquaredError:ov,meanAbsoluteError:lv,meanAbsolutePercentageError:uv,meanSquaredLogarithmicError:function(e,t){return ri((()=>{let n=bl(t,ix(),Number.MAX_VALUE),r=Du(xo(1,n)),a=bl(e,ix(),Number.MAX_VALUE),s=Du(xo(1,a));return ip(bx(ju(r,s)),-1)}))},squaredHinge:function(e,t){return ri((()=>{let n=sp(0,ju(1,ko(e,t)));return ip(bx(n),-1)}))},hinge:function(e,t){return ri((()=>{let n=sp(0,ju(1,ko(e,t)));return ip(n,-1)}))},categoricalHinge:function(e,t){return ri((()=>{let n=hu(ko(e,t),-1),r=iu(ko(ju(1,e),t),-1);return sp(0,xo(1,ju(r,n)))}))},logcosh:function(e,t){return ri((()=>{let n=Math.log(2),r=ju(t,e),a=ju(xo(r,Gu(ko(-2,r))),n);return ip(a,-1)}))},categoricalCrossentropy:pv,sparseCategoricalCrossentropy:dv,binaryCrossentropy:hv,kullbackLeiblerDivergence:function(e,t){return ri((()=>{let n=bl(e,ix(),1),r=bl(t,ix(),1);return hu(ko(e,Du(vo(n,r))),-1)}))},poisson:function(e,t){return ri((()=>{let n=Du(xo(ix(),t));return ip(ju(t,ko(e,n)),-1)}))},cosineProximity:cv};function mv(e){if("string"==typeof e){if(e in fv)return fv[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new db(t)}return e}function gv(e,t){return ri((()=>{let n=ko(.5,bp(t)),r=ox(Iu(t,n),e.dtype);return ip(Ul(e,r),-1)}))}function yv(e,t){return ri((()=>ox(Ul(Eo(e,-1),Eo(t,-1)),"float32")))}function bv(e,t){return ri((()=>go(hu(Xu(Ul(e,1),Ul(t,1))),"float32")))}function xv(e,t){return ri((()=>{let n=bv(e,t),r=function(e,t){return ri((()=>go(hu(Xu(Ul(e,0),Ul(t,1))),"float32")))}(e,t),a=xo(n,r);return go(Gl(Iu(a,0),vo(n,a),0),"float32")}))}function wv(e,t){return ri((()=>{let n=bv(e,t),r=function(e,t){return ri((()=>go(hu(Xu(Ul(e,1),Ul(t,0))),"float32")))}(e,t),a=xo(n,r);return go(Gl(Iu(a,0),vo(n,a),0),"float32")}))}function vv(e,t){return hv(e,t)}function kv(e,t){return e.rank===t.rank&&(e=Fd(e,[e.rank-1])),(t=Eo(t,-1)).dtype!==e.dtype&&(t=go(t,e.dtype)),go(Ul(e,t),"float32")}var Iv=pv,Sv=dv,Nv={binaryAccuracy:gv,categoricalAccuracy:yv,precision:xv,categoricalCrossentropy:Iv,sparseCategoricalCrossentropy:Sv,mse:ov,MSE:ov,mae:lv,MAE:lv,mape:uv,MAPE:uv,cosine:cv};function Tv(e){if("string"==typeof e&&e in Nv)return Nv[e];if("string"!=typeof e&&null!=e)return e;throw new db(`Unknown metric ${e}`)}function _v(e){if(gb(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(let n of Object.keys(fv))if(fv[n]===e){t=n;break}if(void 0!==t)return t;for(let n of Object.keys(Nv))if(Nv[n]===e){t=n;break}return void 0!==t?t:e.name}}function Cv(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!Ev(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function Ev(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if("string"!=typeof n||!Ev(e[n]))return!1;return!0}if(Array.isArray(e)){for(let t of e)if(!Ev(t))return!1;return!0}return!1}{let t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function $v(e,t,n,r=console.log){let a,s=function(e){let t=!0,n=[],r=[];for(let t in e.nodesByDepth)n.push(e.nodesByDepth[t]);for(let e of n){if(e.length>1||1===e.length&&e[0].inboundLayers.length>1){t=!1;break}r.push(...e)}if(t)for(let n of e.layers){let e=!1;for(let a of n.inboundNodes)if(-1!==r.indexOf(a)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),i=["Layer (type)","Input Shape","Output shape","Param #"];if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!s){i.push("Receives inputs"),a=[];for(let t in e.nodesByDepth)a.push(...e.nodesByDepth[t])}r("_".repeat(t)),Av(i,n,r),r("=".repeat(t));let o=e.layers;for(let e=0;e<o.length;++e)s?Fv(o[e],n,r):Rv(o[e],n,a,r),r((e===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=function(e){let t;return t=null!=e.collectedTrainableWeights?Xx(e.collectedTrainableWeights):Xx(e.trainableWeights),t}(e),u=Xx(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function Av(e,t,n=console.log){let r="";for(let n=0;n<e.length;++n)n>0&&(r=r.slice(0,r.length-1)+" "),r+=e[n],r=r.slice(0,t[n]),r+=" ".repeat(t[n]-r.length);n(r)}function Fv(e,t,n){let r,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(e){a="multiple"}try{r=JSON.stringify(e.outputShape)}catch(e){r="multiple"}Av([`${e.name} (${e.getClassName()})`,a,r,e.countParams().toString()],t,n)}function Rv(e,t,n,r){let a,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(e){s="multiple"}try{a=JSON.stringify(e.outputShape)}catch(e){a="multiple"}let i=[];for(let t of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(t)))for(let e=0;e<t.inboundLayers.length;++e){let n=t.inboundLayers[e].name,r=t.nodeIndices[e],a=t.tensorIndices[e];i.push(`${n}[${r}][${a}]`)}let o=e.name,l=e.getClassName(),u=0===i.length?"":i[0];Av([`${o} (${l})`,s,a,e.countParams().toString(),u],t,r);for(let e=1;e<i.length;++e)Av(["","","","",i[e]],t,r)}function Dv(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function Mv(e,t){if(null===e)return null;if("string"==typeof e)return vb(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];Dv(t,a,r)?n.push(r):n.push(Mv(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{let e=vb(n);t[e]=Mv(r,e)}}return t}}function Ov(e,t){if(null==e)return null;if("string"==typeof e)return wb(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];Dv(t,a,r)?n.push(r):n.push(Ov(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n],a=wb(n);t[a]="name"!==n&&"className"!==n||"string"!=typeof r?Ov(r,n):r}return t}}var Lv="4.22.0",zv=class e extends sw{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){let e=this.getClassName().toLowerCase();this.name=Lb(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],_b(this.inputs).length!==this.inputs.length)throw new db(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);_b(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let e of this.outputs){let t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(r)}for(let e of this.inputs){let t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;gb(0===n,"input layer has >1 nodes"),gb(0===r,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(r)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let e=0;e<this.inputLayers.length;e++){let n=this.inputLayers[e];if(!(n instanceof ow))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${e} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(let e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));let n={},r={},a={},s={},i={},o=[],l=(t,n,r,a,s,u)=>{(null==a||null==s||null==u)&&(a=t.sourceLayer,s=t.nodeIndex,u=t.tensorIndex);let p=a.inboundNodes[s];if(-1!==r.indexOf(p))throw new pb(`The tensor ${t.name} at layer "${a.name}" is part of a cycle.`);if(-1!==n.indexOf(p))return;this.containerNodes.add(e.nodeKey(a,s)),a.id in i||(i[a.id]=Object.keys(i).length),-1===r.indexOf(p)&&r.push(p);let d=p.inboundLayers.length;for(let e=0;e<d;e++){let t=p.inputTensors[e],a=p.inboundLayers[e],s=p.nodeIndices[e],i=p.tensorIndices[e];l(t,n,r,a,s,i)}for(n.push(p);r.indexOf(p)>=0;)r.splice(r.indexOf(p),1);o.push(p)},u=[],p=[];for(let e of this.outputs)l(e,u,p);let d=o.slice().reverse();for(let e of d){r[e.id]=e,e.id in n||(n[e.id]=0);let t=n[e.id],i=null==a[e.outboundLayer.id]?0:a[e.outboundLayer.id];t=Math.max(t,i),a[e.outboundLayer.id]=t,s[e.outboundLayer.id]=e.outboundLayer,n[e.id]=t;for(let a=0;a<e.inboundLayers.length;a++){let s=e.inboundLayers[a],i=e.nodeIndices[a],o=s.inboundNodes[i],l=null==n[o.id]?0:n[o.id];n[o.id]=Math.max(t+1,l),r[o.id]=o}}let h={};for(let e in n){let t=n[e];t in h||(h[t]=[]),h[t].push(r[e])}let c={};for(let e in a){let t=a[e];t in c||(c[t]=[]),c[t].push(s[e])}let f=Object.keys(c).map((e=>parseInt(e,10))).sort(Tb);this.layers=[];for(let t of f){let n=c[t];n.sort(((e,t)=>{let n=i[e.id],r=i[t.id];return n<r?-1:n>r?1:0}));for(let t of n)t instanceof e&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=c,f=Object.keys(h).map((e=>parseInt(e,10))).sort(Tb);let m=this.inputs.slice(),g=[];for(let e of f)for(let t of h[e]){let e=t.outboundLayer;if(null!=e){for(let n of t.inputTensors)if(-1===m.indexOf(n))throw new pb(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${g}`);for(let e of t.outputTensors)m.push(e);g.push(e.name)}}this.nodesByDepth=h;let y=this.layers.map((e=>e.name));for(let e of y){let t=y.filter((t=>t===e)).length;if(1!==t)throw new pb(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new rw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new db("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let n={},r=0,a=(e=>{let t=Object.keys(e);if(0===t.length)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);a&&this.parseWeights(e);for(let e of this.layers)for(let[t,s]of e.weights.entries()){let e=a?`${s.name.split("/").slice(0,-1).join("/")+"/"}${t}`:s.originalName;if(null!=n[e])throw new db(`Duplicate weight name: ${e}`);n[e]=s,r++}let s=[];for(let r in e){let a=r;if(null==n[r]){let e=r.split("/");a=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[a])s.push([n[a],e[r]]);else if(t)throw new db(`Provided weight data has no target variable: ${r}`);delete n[a]}if(t){let e=[];for(let t in n)e.push(t);if(e.length>0)throw new db(`${e.length} of ${r} weights are not set: ${e}`)}Qx(s)}parseWeights(e){for(let t in Object.keys(e)){let n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],a=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");a!==t&&(e[a]=e[t],delete e[t])}}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${Lv}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){let n=Ov(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return ri((()=>{e=xb(e);let n=new uw;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return hw(this.outputs,n,t)}))}computeMask(e,t){return ri((()=>{let n;return e=xb(e),n=null==t?mb(null,e.length):xb(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){let t=jx(e);if(t.length!==this.inputLayers.length)throw new db(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let e=0;e<t.length;e++){let r=this.inputLayers[e],a=t[e];n[r.name+"_0_0"]=a}let r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(Tb);if(r.length>1)for(let e of r){let t=this.nodesByDepth[e];for(let e of t){let t=e.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(t.id))continue;let r=[];for(let t=0;t<e.inboundLayers.length;t++){let a=e.inboundLayers[t],s=e.nodeIndices[t],i=e.tensorIndices[t],o=n[`${a.name}_${s}_${i}`];r.push(o)}let a=jx(t.computeOutputShape(bb(r))),s=t.inboundNodes.indexOf(e);for(let e=0;e<a.length;e++){n[`${t.name}_${s}_${e}`]=a[e]}}}let a=[],s=[];for(let e=0;e<this.outputLayers.length;e++){let t=this.outputLayers[e],n=this.outputLayersNodeIndices[e],r=this.outputLayersTensorIndices[e],a=`${t.name}_${n}_${r}`;s.push(a)}for(let e=0;e<s.length;e++){let t=s[e];gb(t in n),a.push(n[t])}return bb(a)}runInternalGraph(e,t){null==t&&(t=mb(null,e.length));let n={};for(let r=0;r<this.inputs.length;++r){let a=this.inputs[r],s=e[r],i=t[r];n[a.id]=[s,i]}let r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(Tb);for(let e of r){let t=this.nodesByDepth[e];for(let e of t){let t=e.outboundLayer,r=e.inputTensors,a=e.outputTensors,s=new Array;for(let e of r)e.id in n&&s.push(n[e.id]);if(s.length===r.length){let r,i,o,l,u={};if(null!=e.callArgs&&(u=e.callArgs),1===s.length){let[e,n]=s[0];null==u.mask&&(u.mask=n),o=xb(t.call(e,u)),l=xb(t.computeMask(e,n)),r=[e],i=[n]}else r=s.map((e=>e[0])),i=s.map((e=>e[1])),null==u.mask&&(u.mask=i),o=xb(t.call(r,u)),l=xb(t.computeMask(r,i));if(t.activityRegularizer)throw new hb("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<a.length;++e){let t=a[e],r=o[e],s=l[e];n[t.id]=[r,s]}}}}let a=[],s=[],i=[];for(let e of this.outputs){gb(e.id in n,`Could not compute output ${e.name} : ${e.id}`);let[t,r]=n[e.id];i.push(t.shape),a.push(t),s.push(r)}return[a,s,i]}buildNodeConversionMap(t){let n,r={};for(let t of this.layers){n=t instanceof e?1:0;for(let a=0;a<t.inboundNodes.length;a++){let s=e.nodeKey(t,a);this.containerNodes.has(s)&&(r[s]=n,n+=1)}}return r}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new db("Provide either a layer name or layer index");if("number"==typeof e)return this.findLayer(e);for(let t of this.layers)if(t.name===e)return t;throw new db(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new db(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return ri((()=>{let t=[];for(let n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){let a=e.nodeKey(n,r);this.containerNodes.has(a)&&t.push(...n.calculateLosses())}return t}))}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(let t of this.layers){let a=t.getClassName(),s=t.getConfig(),i=[];for(let r=0;r<t.inboundNodes.length;r++){let a=t.inboundNodes[r],s=e.nodeKey(t,r),o={};if(this.containerNodes.has(s)){if(a.callArgs)try{JSON.stringify(a.callArgs),o=a.callArgs}catch(e){console.warn(`Layer ${t.name} was passed non-serializable keyword arguments: ${a.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),o={}}if(a.inboundLayers.length>0){let t=[];for(let r=0;r<a.inboundLayers.length;r++){let s=a.inboundLayers[r],i=a.nodeIndices[r],l=a.tensorIndices[r],u=n[e.nodeKey(s,i)];null==u&&(u=0),t.push([s.name,u,l,o])}i.push(t)}}}let o={};o.name=t.name,o.className=a,o.config=s,o.inboundNodes=i,r.push(o)}t.layers=r;let a=[];for(let t=0;t<this.inputLayers.length;t++){let r=this.inputLayers[t],s=this.inputLayersNodeIndices[t],i=e.nodeKey(r,s);if(!this.containerNodes.has(i))continue;let o=n[i];null==o&&(o=0);let l=this.inputLayersTensorIndices[t];a.push([r.name,o,l])}t.inputLayers=a;let s=[];for(let t=0;t<this.outputLayers.length;t++){let r=this.outputLayers[t],a=this.outputLayersNodeIndices[t],i=e.nodeKey(r,a);if(!this.containerNodes.has(i))continue;let o=n[i];null==o&&(o=0);let l=this.outputLayersTensorIndices[t];s.push([r.name,o,l])}return t.outputLayers=s,t}static fromConfig(e,t,n={},r=!1){let a={},s={};function i(e,t){e.name in s?s[e.name].push(t):s[e.name]=[t]}function o(e,t){let n,r=[];for(let s of t){let o=s[0],l=s[1],u=s[2];if(n=null==s[3]?{}:s[3],!(o in a))return void i(e,t);let p=a[o];if(p.inboundNodes.length<=l)return void i(e,t);let d=p.inboundNodes[l];r.push(d.outputTensors[u])}r.length>0&&e.apply(bb(r),n)}function l(e){let n=e.name,s=sv(e,null!=t.customObjects?t.customObjects:{});s.setFastWeightInitDuringBuild(r),a[n]=s,e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new db(`Corrupted configuration, expected array for nodeData: ${e}`);i(s,e)}))}let u=t.name,p=t.layers;for(let e of p)l(e);for(;!Cb(s);)for(let e of p){let t=a[e.name];if(t.name in s){let e=s[t.name];delete s[t.name];for(let n of e)o(t,n)}}let d=[],h=[],c=t.inputLayers;for(let e of c){let t=e[0],n=e[1],r=e[2];gb(t in a);let s=a[t].inboundNodes[n].outputTensors;d.push(s[r])}let f=t.outputLayers;for(let e of f){let t=e[0],n=e[1],r=e[2];gb(t in a);let s=a[t].inboundNodes[n].outputTensors;h.push(s[r])}return new e({inputs:d,outputs:h,name:u})}get stateful(){if(this._stateful)throw new db("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){ri((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}};function Pv(e,t){return function(e,t,n){let r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){let n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}(e,t,"classWeight")}async function Bv(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){let t=ri((()=>{if(1===e.shape.length)return yo(e);if(2===e.shape.length){if(e.shape[1]>1)return Eo(e,1);if(1===e.shape[1])return Zo(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());ai(t);let a=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);a.push(n[e])})),Ld(a,"float32")}return null}function Wv(e,t){return ko(e,t)}function Vv(e,t){let n,r,a=t;n=a.xs,r=a.ys,ka.assert(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));let s=Uv("input",e.inputNames,n),i=Uv("output",e.outputNames,r),o=s[0].shape[0];ka.assert(s.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),ka.assert(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let t=0;t<s.length;t++)ka.assert(s[t].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[t]} has ${s[t].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let t=0;t<i.length;t++)ka.assert(i[t].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[t]} has ${i[t].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:s,ys:i}}function Uv(e,t,n){if(n instanceof is)return[n];if(Array.isArray(n))return ka.assert(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{let r=[];for(let a of t){if(null==n[a])throw new db(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}async function Gv(e,t,n){let r=null!=n.batchesPerEpoch;if(ka.assert(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),ka.assert(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),ka.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),ka.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),ka.assert(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let a,s,i=null!=n.validationData;if(i)if(Hv(n.validationData))ka.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{let e=function(e){if(3===e.length)throw new hb("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);a=e.xs,s=e.ys}let o,l=e.makeTrainFunction(),u=e.getDedupedMetricsNames();o=i?u.slice().concat(u.map((e=>"val_"+e))):u.slice();let p=nv(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:h,history:c}=av(p,d,n.epochs,null,null,function(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}(t,n),null,i,o);h.setModel(e),e.history=c,await h.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let o={};await h.onEpochBegin(f);let p=0,d=0;for(r||(m=await t.iterator());!r||p<n.batchesPerEpoch;){let t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${p} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=t.value){let{xs:r,ys:a}=Vv(e,t.value),s={};s.batch=d,s.size=r[0].shape[0],await h.onBatchBegin(d,s);let i=[];if(null!=n.classWeight){let t=Pv(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await Bv(a[e],null,t[e]))}let o=r.concat(a).concat(i),c=l(o);ai(o);for(let e=0;e<u.length;++e){let t=u[e],n=c[e];s[t]=n,si(n)}await h.onBatchEnd(d,s),Yw(s),d++,p++}if(r?p>=n.batchesPerEpoch:t.done){if(i){let t;t=Hv(n.validationData)?xb(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):xb(e.evaluate(a,s,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)o[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,o),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function Hv(e){return"function"==typeof e.iterator}function jv(e){ka.assert(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function qv(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>ux(e,t,n-t))):ux(e,t,n-t)}function Kv(e,t){return ri((()=>null==e?null:Array.isArray(e)?e.map((e=>Kv(e,t))):yx(e,"int32"===t.dtype?t:go(t,"int32"))))}function Xv(e,t){let n=[],r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function Yv(e){let t=[];e instanceof is&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(1===r.rank)t.push(lx(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Zv(e,t){if(null==e)return;let n=[];if(t instanceof is)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(let e in t){let r=t[e];n.push(r.id)}let r=[];if(e instanceof is)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(let t in e){let a=e[t];-1===n.indexOf(a.id)&&r.push(a)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function Jv(e){return Array.isArray(e)}function Qv(e){return!function(e){return e instanceof is}(e)&&!Jv(e)}function ek(e,t,n,r=!0,a=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(Jv(e)&&e.length>0)t=!0;else if(Qv(e)){for(let n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new db(`Error when checking model ${a} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));let s;if(Qv(e)){s=[];for(let n of t){if(null==e[n])throw new db(`No data provided for "${n}". Need data for each key in: ${t}`);s.push(e[n])}}else if(Jv(e)){if(e.length!==t.length)throw new db(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(t.length>1)throw new db(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=Yv(s),null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;let i=s[e];if(i.shape.length!==n[e].length)throw new db(`Error when checking ${a}: expected ${t[e]} to have ${n[e].length} dimension(s). but got array with shape ${i.shape}`);for(let t=0;t<n[e].length;++t){if(0===t&&!r)continue;let s=i.shape[t],o=n[e][t];if(null!=o&&o>=0&&s!==o)throw new db(`${a} expected a batch of elements where each example has shape [${n[e].slice(1,n[e].length)}] (i.e.,tensor shape [*,${n[e].slice(1,n[e].length)}]) but the ${a} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return s}function tk(e,t,n,r=!0,a=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new db(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new db(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;let i=s[e];if(i.shape.length!==n[e].length)throw new db(`Error when checking ${a}: expected ${t[e]} to have ${n[e].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let s=0;s<n[e].length;++s){if(0===s&&!r)continue;let o=i.shape[s],l=n[e][s];if(null!=l&&l!==o)throw new db(`Error when checking ${a}: expected ${t[e]} to have shape ${JSON.stringify(n[e])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}var nk=class extends zv{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new db("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");$v(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){let t={Adagrad:()=>Kf.adagrad(.01),Adadelta:()=>Kf.adadelta(1,.95,ix()),Adam:()=>Kf.adam(.001,.9,.999,ix()),Adamax:()=>Kf.adamax(.002,.9,.999,ix(),0),RMSProp:()=>Kf.rmsprop(.001,.9,0,ix()),SGD:()=>Kf.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new db(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Mc))throw new db("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new db(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map((e=>mv(e)))}else{let n=mv(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(let t in e.loss)if(-1===this.outputNames.indexOf(t))throw new db(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(let n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(mv(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let e=0;e<this.outputs.length;++e){let t=this.internalOutputShapes[e],n=this.outputNames[e];this.feedOutputNames.push(n),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[e])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Xb("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;let t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));let r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{let e=[];for(let r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),a=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};Xb("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,r,s;for(let i of t){if("string"==typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){let t,a=this.internalOutputShapes[e];1===a[a.length-1]||this.lossFunctions[e]===hv?-1!==["accuracy","acc"].indexOf(i)?r=gv:-1!==["crossentropy","ce"].indexOf(i)&&(r=vv):this.lossFunctions[e]===dv?-1!==["accuracy","acc"].indexOf(i)?r=kv:-1!==["crossentropy","ce"].indexOf(i)&&(r=Sv):-1!==["accuracy","acc"].indexOf(i)?r=yv:-1!==["crossentropy","ce"].indexOf(i)&&(r=Iv),-1!==["accuracy","acc"].indexOf(i)?t="acc":-1!==["crossentropy","ce"].indexOf(i)&&(t="ce"),s=r,n=""+t}else s=Tv(i),n=""+_v(i);let t;Xb(n,(()=>{t=s})),a(e,n,t)}})(r[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=null==n.batchSize?32:n.batchSize;jv(r);let a=this.standardizeUserDataXY(e,t,!0,r);try{let e=a[0].concat(a[1]);this.makeTestFunction();let t=this.testFunction;return bb(this.testLoop(t,e,r,n.verbose,n.steps))}finally{Zv(a[0],e),Zv(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){let r=null!=(n=n||{}).batches,a=e.testFunction,s=[];if(n.verbose>0)throw new hb("Verbose mode is not implemented yet.");ka.assert(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));let i=function(e){return"function"==typeof e.next}(t)?t:await t.iterator(),o=0,l=0;for(;!r||l<n.batches;){let t=await i.next();if(s=ri((()=>{if(t.value){let{xs:n,ys:r}=Vv(e,t.value),i=n.concat(r),u=ri((()=>a(i)));if(ai(i),0===l)for(let e=0;e<u.length;++e)s.push(uu(0));let p=i[0].shape[0];for(let e=0;e<u.length;++e){let t=u[e],n=s[e];s[e]=ri((()=>xo(s[e],ko(p,t)))),l>0&&ai(n)}ai(u),o+=p,++l}return s})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let e=0;e<s.length;++e){let t=s[e];s[e]=vo(s[e],o),ai(t)}return bb(s)}(this,e,t)}checkNumSamples(e,t,n,r="steps"){let a;if(null!=n){if(a=null,null!=t)throw new db(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new db(`Either the input data should have a defined shape, or ${r} shoud be specified.`);a=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return a}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new db("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),s=new uw;if(e instanceof is&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new db(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(let t of this.inputs){let n=e[t.name];if(null==n)throw new db(`No value is provided for the model's input ${t.name}`);s.add(t,n)}let i=hw(a,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=mb(null,e.length),n=e.length;for(let r of this.layers){let a=Array.isArray(r.output)?r.output:[r.output],s=a.map((e=>e.name));for(let r=0;r<e.length;++r){let i=s.indexOf(e[r]);if(-1!==i&&(t[r]=a[i],n--),0===n)break}if(0===n)break}if(n>0){let n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new db(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return ri((()=>{let r=this.checkNumSamples(e);if(n)throw new hb("Verbose predictLoop() is not implemented yet.");let a=Xv(r,t),s=this.outputs.map((e=>[]));for(let t=0;t<a.length;++t)ri((()=>{let n=a[t][0],r=a[t][1],s=qv(e,n,r),i=[];if(Array.isArray(s))for(let e=0;e<s.length;++e)i.push({key:this.inputs[e],value:s[e]});else i.push({key:this.inputs[0],value:s});let o=new uw(i);return hw(this.outputs,o)})).forEach(((e,t)=>s[t].push(e)));return bb(s.map((e=>el(e,0))))}))}predict(e,t={}){let n=Yv(e);tk(n,this.inputNames,this.feedInputShapes,!1);try{let e=null==t.batchSize?32:t.batchSize;return jv(e),this.predictLoop(n,e)}finally{Zv(n,e)}}predictOnBatch(e){tk(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new pb("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let a=[];for(let e=0;e<this.feedOutputShapes.length;++e){let t=this.feedOutputShapes[e];this.feedLossFns[e]===dv?a.push(t.slice(0,t.length-1).concat([1])):a.push(t)}if(function(e,t,n){let r=_b(e.map((e=>e.shape[0])));r.sort();let a=_b(t.map((e=>e.shape[0])));if(a.sort(),r.length>1)throw new db(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(a.length>1)throw new db(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(r.length>0&&a.length>0&&!ka.arraysEqual(r,a))throw new db(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${a[0]} target sample(s).`)}(e=ek(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=ek(t,this.feedOutputNames,a,!1,"target")),function(e,t,n){let r=[ov,hv,pv];for(let a=0;a<e.length;++a){let s=e[a],i=t[a],o=n[a];if(null!=i){if(i===pv&&1===s.shape[s.shape.length-1])throw new db(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){let e=s.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){let r=e[n],a=t[n];if(null!=a&&r!==a)throw new db(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!=0)throw new db(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,a=!0,s){let[i,o]=this.standardizeUserDataXY(e,t,a,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){let e=Pv(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await Bv(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,n,r=0,a){return ri((()=>{let s=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new hb("Verbose mode is not implemented yet.");if(null!=a)throw new hb("steps mode in testLoop() is not implemented yet");{let r=Xv(s,n),a=Ld(sx(0,s));for(let n=0;n<r.length;++n){let s=r[n][0],o=r[n][1],l=ux(a,s,o-s),u=Kv(t,l),p=e(u);if(0===n)for(let e=0;e<p.length;++e)i.push(uu(0));for(let e=0;e<p.length;++e){let t=p[e];i[e]=xo(i[e],ko(o-s,t))}}for(let e=0;e<i.length;++e)i[e]=vo(i[e],s)}return i}))}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],a=r;if(yb(e,r)>1){a+=`_${yb(e.slice(0,n),r)}`}t.push(a)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],i=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{let e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});let i,o=new uw(e),l=hw(this.outputs,o,{training:!0});for(let e=0;e<this.lossFunctions.length;++e){let n=(0,this.lossFunctions[e])(r[e],l[e]);null!=a[e]&&(n=Wv(n,a[e]));let s=ip(n);t.push(s),i=0===e?n:xo(i,n)}for(let e=0;e<this.metricsTensors.length;++e){let n;if(this.outputs.length>1&&e<this.outputs.length)n=t[e];else{let t=this.metricsTensors[e][0],a=this.metricsTensors[e][1];n=ip(t(r[a],l[a]))}si(n),s.push(n)}return i=ip(i),this.calculateLosses().forEach((e=>{i=xo(i,e)})),i}),!0,i)].concat(s)}}makeTestFunction(){this.testFunction=e=>ri((()=>{let t,n=[],r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:r[e]});let i=new uw(s),o=hw(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){let r=this.lossFunctions[e],s=ip(r(a[e],o[e]));t=0===e?s:xo(t,s),n.push(t)}for(let e=0;e<this.metricsTensors.length;++e){let t=this.metricsTensors[e][0],r=this.metricsTensors[e][1],s=ip(t(a[r],o[r]));n.push(s)}return n}))}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let r,a,s,i,o,l,u,p,d;this.isTraining=!0;try{let h=null==n.batchSize?32:n.batchSize;jv(h);let c=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,!1,h);r=c[0],a=c[1],d=c[2];let f,m=!1;if(null!=n.validationData&&n.validationData.length>0){if(m=!0,2!==n.validationData.length)throw 3===n.validationData.length?new hb("validationData including sample weights is not supported yet."):new db(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);o=n.validationData[0],l=n.validationData[1];let e=await this.standardizeUserData(o,l,null,null,!0,h);u=e[0],p=e[1],f=u.concat(p)}else if(null!=n.validationSplit&&n.validationSplit>0&&n.validationSplit<1){m=!0;let e=Math.floor(r[0].shape[0]*(1-n.validationSplit)),t=r[0].shape[0];u=qv(r,e,t),s=r,r=qv(r,0,e),p=qv(a,e,t),i=a,a=qv(a,0,e),f=u.concat(p)}else null!=n.validationSteps&&(m=!0);let g=r.concat(a).concat(d);this.checkTrainableWeightsConsistency();let y,b,x=this.makeTrainFunction(),w=this.getDedupedMetricsNames();m?(this.makeTestFunction(),y=this.testFunction,b=w.slice().concat(w.map((e=>"val_"+e)))):(y=null,f=[],b=w.slice());let v=nv(n.callbacks,n.yieldEvery);return await this.fitLoop(x,g,w,h,n.epochs,n.verbose,v,y,f,n.shuffle,b,n.initialEpoch,null,null)}finally{this.isTraining=!1,Zv(r,e),Zv(a,t),Zv(s,e),Zv(i,t),Zv(u,o),Zv(p,l),null!=d&&ai(d)}}async fitLoop(e,t,n,r,a,s,i,o,l,u,p,d,h,c){null==r&&(r=32),null==a&&(a=1),null==u&&(u=!0),null==d&&(d=0);let f=!1;if(null!=o&&null!=l&&(f=!0),null!=c&&(f=!0,null==h))throw new db("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let m,g=this.checkNumSamples(t,r,h,"steps_per_epoch");null!=g&&(m=sx(0,g)),null==s&&(s=1);let{callbackList:y,history:b}=av(i,s,a,d,g,h,r,f,p);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let s=d;s<a;++s){await y.onEpochBegin(s);let a={};if(null!=h)throw new hb("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new hb("batch shuffling is not implemneted yet");u&&ka.shuffle(m);let s=Ld(m),i=Xv(g,r);for(let u=0;u<i.length;++u){let p={};if(await y.onBatchBegin(u,p),ri((()=>{let d=i[u][0],h=i[u][1],c=ux(s,d,h-d);p.batch=u,p.size=h-d;let m=Kv(t,c),g=e(m);for(let e=0;e<n.length;++e){let t=n[e],r=g[e];p[t]=r,si(r)}if(u===i.length-1&&f){let e=this.testLoop(o,l,r);for(let t=0;t<n.length;++t){let r=n[t],s=e[t];si(s),a["val_"+r]=s}}})),await y.onBatchEnd(u,p),Yw(p),this.stopTraining_)break}s.dispose()}if(await y.onEpochEnd(s,a),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return Gv(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),i=[];for(let e of s){let t=await e.data();i.push(t[0])}return ai(s),Zv(n[0],e),Zv(n[1],t),bb(i)}getNamedWeights(e){let t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let e=0;e<r.length;++e)n&&!r[e].trainable||t.push({name:r[e].originalName,tensor:a[e]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){let t=ti().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-ti().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=wb(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>wb(e)))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=wb(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[wb(_v(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>wb(_v(e))));{let e={};for(let t in this.metrics)e[t]=wb(_v(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");let t,n,r=sv(Mv(e.optimizer_config));if("string"==typeof e.loss)t=vb(e.loss);else if(Array.isArray(e.loss))t=e.loss.map((e=>vb(e)));else if(null!=e.loss){t={};for(let n in e.loss)t[n]=vb(e.loss[n])}if(Array.isArray(e.metrics))n=e.metrics.map((e=>vb(e)));else if(null!=e.metrics){n={};for(let t in e.metrics)n[t]=vb(e.metrics[t])}this.compile({loss:t,metrics:n,optimizer:r})}async save(e,t){if("string"==typeof e){let t=Gc.getSaveHandlers(e);if(0===t.length)throw new db(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new db(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new db("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Gc.encodeWeights(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${Lv}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();let e="optimizer",{data:t,specs:a}=await Gc.encodeWeights(await this.optimizer.getWeights(),e);n.specs.push(...a),n.data=Gc.concatenateArrayBuffers([n.data,t])}return null!=this.userDefinedMetadata&&(Cv(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){Cv(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};nk.className="Model",Cc.registerClass(nk);var rk=class extends nk{};async function ak(e,t){"modelTopology"in e||(e={modelTopology:e});let n=e.modelTopology;null!=n.model_config&&(n=n.model_config);let r=sv(Mv(n),t);if(null!=e.weightsManifest){let t=await Gc.loadWeights(e.weightsManifest,e.pathPrefix,r.weights.map((e=>e.originalName))),n={};for(let e of r.weights)n[e.originalName]=t[e.originalName];r.loadWeights(n),ai(t)}return r}async function sk(e,t){if(null==t&&(t={}),"string"==typeof e){let n=Gc.getLoadHandlers(e,t);if(0===n.length)n.push(Gc.browserHTTPRequest(e,t));else if(n.length>1)throw new db(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return async function(e,t,n){if(null==n&&(n={}),null==e.load)throw new db("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),a=r.modelTopology;null!=a.model_config&&(a=a.model_config);let s=null==n.strict||n.strict,i=null!=r.weightData&&null!=r.weightSpecs&&s,o=sv(Mv(a),t,i),l=r.trainingConfig;if(null!=l&&o.loadTrainingConfig(l),null!=r.userDefinedMetadata&&o.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new db("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:e,optimizerWeights:t}=function(e,t){let n=Gc.decodeWeights(e,t),r={},a=[];return t.forEach((e=>{"optimizer"===e.group?a.push({name:e.name,tensor:n[e.name]}):r[e.name]=n[e.name]})),{modelWeights:r,optimizerWeights:a}}(r.weightData,r.weightSpecs);o.loadWeights(e,s),null!=o.optimizer&&t.length>0&&await o.optimizer.setWeights(t),ai(e),ai(t.map((e=>e.tensor)))}return o}(e,void 0,t)}rk.className="Functional",Cc.registerClass(rk);var ik=class e extends nk{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:Lb("sequential_"),null!=e.layers)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new db(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n,r=t instanceof e||t instanceof nk;if(r){if(n=t,1!==n.outputs.length)throw new db("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new db("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new db("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let e=lw({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(r)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new db(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new db("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=iw(this.outputs[0])}this.inboundNodes=[],new rw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:mb(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{let e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(Kx(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new nk({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new pb("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new pb("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new pb("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new pb("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(t,n,r={},a=!1){let s,i={};if(n instanceof Array){if(null==n[0].className||"Merge"===n[0].className)throw new db("Legacy serialization format not supported yet.");s=n}else ka.assert(null!=n.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),s=n.layers,delete n.layers,i=n;let o=new t(i);if(!(o instanceof e))throw new hb(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let e of s){let t=sv(e,void 0,a);a&&t.setFastWeightInitDuringBuild(!0),o.add(t)}return o}set stopTraining(e){if(null==this.model)throw new db("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new db("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}};function ok(e){return new nk(e)}function lk(e){return new ik(e)}function uk(e){return lw(e)}function pk(e,t){rv.registerCallbackConstructor(e,t)}ik.className="Sequential",Cc.registerClass(ik);var dk=class extends Cc.Serializable{getConfig(){return{}}},hk=class extends dk{apply(e,t=1){return function(e,t=1){if(1!==t)throw new hb(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Xl(e)}(e,t)}};hk.className="elu",Cc.registerClass(hk);var ck=class extends dk{apply(e){return md(e)}};ck.className="selu",Cc.registerClass(ck);var fk=class extends dk{apply(e){return id(e)}};fk.className="relu",Cc.registerClass(fk);var mk=class extends dk{apply(e){return ri((()=>pp(6,id(e))))}};mk.className="relu6",Cc.registerClass(mk);var gk=class extends dk{apply(e){return e}};gk.className="linear",Cc.registerClass(gk);var yk=class extends dk{apply(e){return nl(e)}};yk.className="sigmoid",Cc.registerClass(yk);var bk=class extends dk{apply(e){return function(e){return ri((()=>{let t=xo(.5,ko(.2,e));return bl(t,0,1)}))}(e)}};bk.className="hardSigmoid",Cc.registerClass(bk);var xk=class extends dk{apply(e){return Gu(e)}};xk.className="softplus",Cc.registerClass(xk);var wk=class extends dk{apply(e){return function(e){return ri((()=>vo(e,xo(Io(e),1))))}(e)}};wk.className="softsign",Cc.registerClass(wk);var vk=class extends dk{apply(e){return al(e)}};vk.className="tanh",Cc.registerClass(vk);var kk=class extends dk{apply(e,t=-1){return Nd(e,t)}};kk.className="softmax",Cc.registerClass(kk);var Ik=class extends dk{apply(e,t=-1){return qu(e,t)}};Ik.className="logSoftmax",Cc.registerClass(Ik);var Sk=class extends dk{apply(e){return ri((()=>ri((()=>{let t=Math.sqrt(2),n=ko(.5,xo(1,Zl(vo(e,t))));return ko(e,n)}))))}};Sk.className="gelu",Cc.registerClass(Sk);var Nk=class extends dk{apply(e){return ri((()=>ko(.5,ko(e,xo(1,al(ko(pu(vo(2,Math.PI)),xo(e,ko(.044715,lu(e,3))))))))))}};Nk.className="gelu_new",Cc.registerClass(Nk);var Tk=class extends dk{apply(e){return ri((()=>ko(e,al(Gu(e)))))}};Tk.className="mish",Cc.registerClass(Tk);var _k=class extends dk{apply(e,t=1){return ri((()=>ko(nl(ko(e,t)),e)))}};function Ck(e){return e.getClassName()}function Ek(e,t={}){return Nb(e,Cc.SerializationMap.getMap().classNameMap,t,"activation")}function $k(e){if(null==e){let e={className:"linear",config:{}};return Ek(e)}if("string"==typeof e){let t={};return t.className=e,t.config={},Ek(t)}return e instanceof dk?e:Ek(e)}function Ak(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}_k.className="swish",Cc.registerClass(_k);var Fk=class extends Cc.Serializable{},Rk=class extends Fk{constructor(e){super(),Ak(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return ri((()=>{let t=op([1]);return this.hasL1&&(t=xo(t,hu(ko(this.l1,Io(e))))),this.hasL2&&(t=xo(t,hu(ko(this.l2,bx(e))))),Zo(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};Rk.className="L1L2",Cc.registerClass(Rk);var Dk={l1l2:"L1L2"};function Mk(e){return Ib(e)}function Ok(e,t={}){return Nb(e,Cc.SerializationMap.getMap().classNameMap,t,"regularizer")}function Lk(e){if(null==e)return null;if("string"==typeof e){return Ok({className:e in Dk?Dk[e]:e,config:{}})}return e instanceof Fk?e:Ok(e)}var zk=class extends sw{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=qx(e);let n=id(e);return null!=this.maxValue&&(n=bl(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};zk.className="ReLU",Cc.registerClass(zk);var Pk=class extends sw{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=qx(e);return Eu(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};Pk.className="LeakyReLU",Cc.registerClass(Pk);var Bk=class extends sw{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Gx(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Lk(e.alphaRegularizer),this.alphaConstraint=Tw(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new db(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){let t=(e=Kx(e)).slice(1);if(null!=this.sharedAxes)for(let e of this.sharedAxes)t[e-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(null!=this.sharedAxes)for(let t=1;t<e.length;++t)n[t]=e[t];this.inputSpec=[new ew({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=qx(e),_p(e,this.alpha.read())}getConfig(){let e={alphaInitializer:Ux(this.alphaInitializer),alphaRegularizer:Mk(this.alphaRegularizer),alphaConstraint:Sw(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};Bk.className="PReLU",Cc.registerClass(Bk);var Wk=class extends sw{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new hb(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=qx(e);return Xl(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};Wk.className="ELU",Cc.registerClass(Wk);var Vk=class extends sw{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){let n=qx(e);return ko(n,go(Iu(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};Vk.className="ThresholdedReLU",Cc.registerClass(Vk);var Uk=class extends sw{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new kk).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return ri((()=>{let n=qx(e),r=t.mask;if(null!=r){let e=ko(ju(lp(n.shape),go(r,n.dtype)),uu(-1e9));n=xo(n,e)}return this.axis instanceof Array?this.axis.length>1?gu(ju(n,Ku(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function Gk(e,t,n){if("number"==typeof e)return mb(e,t);if(e.length!==t)throw new db(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let a=e[r];if(!tx(a))throw new db(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function Hk(e,t,n,r,a=1){if(null==e)return e;let s;return s="same"===n?e:e-(t+(t-1)*(a-1))+1,Math.floor((s+r-1)/r)}function jk(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+ax([n-t,0]);else{if("same"!==r)throw new db(`Unsupport padding mode: ${r}.`);e*=t}return e}function qk(e,t){return ri((()=>(Gb(t),"channelsFirst"===t?ah(e,[0,2,3,1]):e)))}function Kk(e,t){return ri((()=>(Gb(t),"channelsFirst"===t?ah(e,[0,2,3,4,1]):e)))}function Xk(e,t,n,r=[1,1],a="valid",s,i,o=null){return ri((()=>{if(null==s&&(s="channelsLast"),Gb(s),3!==e.rank&&4!==e.rank)throw new db(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new db(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=qk(e,s);if("causal"===a)throw new hb("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=ch.conv2d({x:l,filter:t,strides:r,pad:"same"===a?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===s&&(l=ah(l,[0,3,1,2])),l}))}Uk.className="Softmax",Cc.registerClass(Uk);var Yk=class e extends sw{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.verifyArgs(n),this.rank=t,Ab(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new hb(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Gk(n.kernelSize,t,"kernelSize"),this.strides=Gk(null==n.strides?1:n.strides,t,"strides"),this.padding=null==n.padding?"valid":n.padding,Hb(this.padding),this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,Gb(this.dataFormat),this.activation=$k(n.activation),this.useBias=null==n.useBias||n.useBias,this.biasInitializer=Gx(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Tw(n.biasConstraint),this.biasRegularizer=Lk(n.biasRegularizer),this.activityRegularizer=Lk(n.activityRegularizer),this.dilationRate=Gk(null==n.dilationRate?1:n.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new db(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new db(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new db(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(gb("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!$b(e.kernelSize,"number",1,3))throw new db(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Ck(this.activation),useBias:this.useBias,biasInitializer:Ux(this.biasInitializer),biasRegularizer:Mk(this.biasRegularizer),activityRegularizer:Mk(this.activityRegularizer),biasConstraint:Sw(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},Zk=class e extends Yk{constructor(t,n){super(t,n),this.kernel=null,e.verifyArgs(n),this.filters=n.filters,Ab(this.filters,"filters"),this.kernelInitializer=Gx(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Tw(n.kernelConstraint),this.kernelRegularizer=Lk(n.kernelRegularizer)}build(e){e=Kx(e);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new db(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return ri((()=>{e=qx(e);let t,n=null==this.bias?null:this.bias.read(),r=Rb(this.activation.getClassName());if(null!=r&&2===this.rank)t=Xk(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=function(e,t,n,r=1,a="valid",s,i=1){return ri((()=>{if(null==s&&(s="channelsLast"),Gb(s),3!==e.shape.length)throw new db(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new db(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new db(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===s&&(e=ah(e,[0,2,1])),"causal"===a)throw new hb("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Sl(e,t,r,"same"===a?"same":"valid","NWC",i);return null!=n&&(o=wx(o,n)),o}))}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=Xk(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new hb("convolutions greater than 3D are not implemented yet.");t=function(e,t,n,r=[1,1,1],a="valid",s,i){return ri((()=>{if(null==s&&(s="channelsLast"),Gb(s),4!==e.rank&&5!==e.rank)throw new db(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new db(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=Kk(e,s);if("causal"===a)throw new hb("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=_l(o,t,r,"same"===a?"same":"valid","NDHWC",i),null!=n&&(o=wx(o,n)),"channelsFirst"===s&&(o=ah(o,[0,4,1,2,3])),o}))}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=Kx(e);let t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let e=0;e<n.length;++e){let r=Hk(n[e],this.kernelSize[e],this.padding,this.strides[e],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[e]);t.push(r)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){let e={filters:this.filters,kernelInitializer:Ux(this.kernelInitializer),kernelRegularizer:Mk(this.kernelRegularizer),kernelConstraint:Sw(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new db(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},Jk=class e extends Zk{constructor(t){super(2,t),e.verifyArgs(t)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!$b(e.kernelSize,"number",1,2))throw new db(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}};Jk.className="Conv2D",Cc.registerClass(Jk);var Qk=class e extends Zk{constructor(t){super(3,t),e.verifyArgs(t)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new db(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}};Qk.className="Conv3D",Cc.registerClass(Qk);var eI=class extends Jk{constructor(e){if(super(e),this.inputSpec=[new ew({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new db(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=Kx(e)).length)throw new db("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new db("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ew({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return ri((()=>{let t=qx(e);if(4!==t.shape.length)throw new db(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n,r,a=t.shape,s=a[0];"channelsFirst"===this.dataFormat?(n=2,r=3):(n=1,r=2);let i=a[n],o=a[r],l=this.kernelSize[0],u=this.kernelSize[1],p=this.strides[0],d=this.strides[1],h=[s,jk(i,p,l,this.padding),jk(o,d,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=ah(t,[0,2,3,1]));let c=Tl(t,this.kernel.read(),h,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(c=ah(c,[0,3,1,2])),null!=this.bias&&(c=wx(c,this.bias.read(),this.dataFormat)),null!=this.activation&&(c=this.activation.apply(c)),c}))}computeOutputShape(e){let t,n,r,a=(e=Kx(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3):(t=3,n=1,r=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return a[t]=this.filters,a[n]=jk(a[n],o,s,this.padding),a[r]=jk(a[r],l,i,this.padding),a}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};eI.className="Conv2DTranspose",Cc.registerClass(eI);var tI=class extends Qk{constructor(e){if(super(e),this.inputSpec=[new ew({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new db(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=Kx(e)).length)throw new db("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new db("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ew({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return ri((()=>{let t=qx(e);if(5!==t.shape.length)throw new db(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n,r,a,s=t.shape,i=s[0];"channelsFirst"===this.dataFormat?(a=2,n=3,r=4):(a=1,n=2,r=3);let o=s[a],l=s[n],u=s[r],p=this.kernelSize[0],d=this.kernelSize[1],h=this.kernelSize[2],c=this.strides[0],f=this.strides[1],m=this.strides[2],g=[i,jk(o,c,p,this.padding),jk(l,f,d,this.padding),jk(u,m,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=ah(t,[0,2,3,4,1]));let y=El(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=ah(y,[0,4,1,2,3])),null!==this.bias&&(y=wx(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y}))}computeOutputShape(e){let t,n,r,a,s=(e=Kx(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3,a=4):(t=4,n=1,r=2,a=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],p=this.strides[1],d=this.strides[2];return s[t]=this.filters,s[n]=jk(s[n],u,i,this.padding),s[r]=jk(s[r],p,o,this.padding),s[a]=jk(s[a],d,l,this.padding),s}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};tI.className="Conv3DTranspose",Cc.registerClass(tI);var nI=class extends Zk{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new db("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new db("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new db(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=Gx(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Lk(t.depthwiseRegularizer),this.depthwiseConstraint=Tw(t.depthwiseConstraint),this.pointwiseInitializer=Gx(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Lk(t.pointwiseRegularizer),this.pointwiseConstraint=Tw(t.pointwiseConstraint)}build(e){if((e=Kx(e)).length<this.rank+2)throw new db(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new db(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let e=0;e<this.rank;++e)a.push(1);a.push(n*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new ew({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return ri((()=>{let t;if(e=qx(e),1===this.rank)throw new hb("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=ah(e,[0,2,3,1])),t=gd(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=wx(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=ah(t,[0,3,1,2])),t}))}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Ux(this.depthwiseInitializer),e.pointwiseInitializer=Ux(this.pointwiseInitializer),e.depthwiseRegularizer=Mk(this.depthwiseRegularizer),e.pointwiseRegularizer=Mk(this.pointwiseRegularizer),e.depthwiseConstraint=Sw(this.depthwiseConstraint),e.pointwiseConstraint=Sw(this.pointwiseConstraint),e}};nI.className="SeparableConv";var rI=class extends nI{constructor(e){super(2,e)}};rI.className="SeparableConv2D",Cc.registerClass(rI);var aI=class e extends Zk{constructor(t){super(1,t),e.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!$b(e.kernelSize,"number",1,1))throw new db(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}};aI.className="Conv1D",Cc.registerClass(aI);var sI=class extends sw{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return ri((()=>{if(e=qx(e),"channelsLast"===this.dataFormat){let t=dx(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return dx(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{let t=dx(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return dx(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};sI.className="Cropping2D",Cc.registerClass(sI);var iI=class extends sw{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Gb(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function(e){Eb(Pb,"InterpolationFormat",e)}(this.interpolation)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){let t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{let t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return ri((()=>{let t=qx(e),n=t.shape;if("channelsFirst"===this.dataFormat){t=ah(t,[0,2,3,1]);let e=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?Ic.resizeNearestNeighbor(t,[e,r]):Ic.resizeBilinear(t,[e,r]);return ah(a,[0,3,1,2])}{let e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?Ic.resizeNearestNeighbor(t,[e,r]):Ic.resizeBilinear(t,[e,r])}}))}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};iI.className="UpSampling2D",Cc.registerClass(iI);var oI=class extends Yk{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=Gx(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Tw(e.depthwiseConstraint),this.depthwiseRegularizer=Lk(e.depthwiseRegularizer)}build(e){if((e=Kx(e)).length<4)throw new db(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new db(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ri((()=>{let t=function(e,t,n=[1,1],r="valid",a,s){return ri((()=>{null==a&&(a="channelsLast"),Gb(a);let i=qk(e,a);if(4!==e.rank)throw new db(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new db(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Ol(i,t,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===a&&(i=ah(i,[0,3,1,2])),i}))}(e=qx(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=wx(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=Kx(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=Hk(t,this.kernelSize[0],this.padding,this.strides[0]),s=Hk(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,a,s]:[e[0],a,s,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Ux(this.depthwiseInitializer),e.depthwiseRegularizer=Mk(this.depthwiseRegularizer),e.depthwiseConstraint=Sw(this.depthwiseRegularizer),e}};function lI(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new db("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=a(t),constants:n=a(n)}}function uI(e,t,n,r=!1,a,s,i=!1,o=!1){return ri((()=>{let l=t.shape.length;if(l<3)throw new db(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(sx(2,l));if(t=ah(t,u),null!=s)throw new hb("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&((a=go(go(a,"bool"),"float32")).rank===l-1&&(a=yu(a,-1)),a=ah(a,u)),r&&(t=ld(t,0),null!=a&&(a=ld(a,0)));let p,d,h,c=[],f=n,m=t.shape[0],g=Jd(t);null!=a&&(d=Jd(a));for(let t=0;t<m;++t){let n=g[t],r=ri((()=>e(n,f)));if(null==a)p=r[0],f=r[1];else{let e=ri((()=>{let e=d[t],n=ju(bp(e),e);return{output:xo(ko(r[0],e),ko(f[0],n)),newStates:f.map(((t,a)=>xo(ko(r[1][a],e),ko(t,n))))}}));p=e.output,f=e.newStates}o&&c.push(p)}return o&&(h=Rd(c,1)),[p,h,f]}))}oI.className="DepthwiseConv2D",Cc.registerClass(oI);var pI=class e extends sw{constructor(e){let t;if(super(e),null==e.cell)throw new db("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new bI({cells:e.cell}):e.cell,null==t.stateSize)throw new db("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new ew({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return sx(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Hx(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n,r=t[0];if(n=this.returnSequences?[e[0],e[1],r]:[e[0],r],this.returnState){let r=[];for(let n of t)r.push([e[0],n]);return[n].concat(r)}return n}computeMask(e,t){return ri((()=>{Array.isArray(t)&&(t=t[0]);let e=this.returnSequences?t:null;if(this.returnState){let t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new hb("Constants support is not implemented in RNN yet.");Hx(e)&&(e=e[0]);let t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new ew({shape:[t,null,...n]});let r,a=[e[0]].concat(e.slice(2));if(this.cell.build(a),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!ka.arraysEqual(this.stateSpec.map((e=>e.shape[e.shape.length-1])),r))throw new db(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map((e=>new ew({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e,t=!1){ri((()=>{if(!this.stateful)throw new ub("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(null==n)throw new db("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>op([n,e]))):this.states_=[op([n,this.cell.stateSize])];else if(null==e)ai(this.states_),null!=this.keptStates&&(ai(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>op([n,e]))):this.states_[0]=op([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new db(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):ai(this.states_);for(let t=0;t<this.states_.length;++t){let r=e[t],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,s=[n,a];if(!ka.arraysEqual(r.shape,s))throw new db(`State ${t} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>si(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=lI(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let s=[],i=[];if(null!=n){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(let e of n)this.stateSpec.push(new ew({shape:e.shape}));i=i.concat(this.stateSpec)}if(null!=r&&(t.constants=r,s=s.concat(r),this.numConstants=r.length),s[0]instanceof tw){let n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;let o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return ri((()=>{let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;e=qx(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));let s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new db(`RNN Layer has ${s} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let i={training:r},o=uI(((e,t)=>{let n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],p=o[2];this.stateful&&this.resetStates(p,r);let d=this.returnSequences?u:l;return this.returnState?[d].concat(p):d}))}getInitialState(e){return ri((()=>{let t=op(e.shape);return t=hu(t,[1,2]),t=lx(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?fx(t,[1,e]):t)):this.cell.stateSize>1?[fx(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(n.numConstants=this.numConstants);let r=this.cell.getConfig();return this.getClassName()===e.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),t),n)}static fromConfig(e,t,n={}){let r=sv(t.cell,n);return new e(Object.assign(t,{cell:r}))}};pI.className="RNN",Cc.registerClass(pI);var dI=class extends sw{},hI=class extends dI{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ab(this.units,"units"),this.activation=$k(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Gx(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Gx(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Gx(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Lk(e.kernelRegularizer),this.recurrentRegularizer=Lk(e.recurrentRegularizer),this.biasRegularizer=Lk(e.biasRegularizer),this.kernelConstraint=Tw(e.kernelConstraint),this.recurrentConstraint=Tw(e.recurrentConstraint),this.biasConstraint=Tw(e.biasConstraint),this.dropout=rx([1,ax([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=rx([1,ax([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Kx(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ri((()=>{if(2!==e.length)throw new db(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=null!=t.training&&t.training;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=xI({ones:()=>bp(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=xI({ones:()=>bp(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a,s=this.dropoutMask,i=this.recurrentDropoutMask;a=gx(null!=s?ko(e,s):e,this.kernel.read()),null!=this.bias&&(a=wx(a,this.bias.read())),null!=i&&(n=ko(n,i));let o=xo(a,gx(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Ck(this.activation),useBias:this.useBias,kernelInitializer:Ux(this.kernelInitializer),recurrentInitializer:Ux(this.recurrentInitializer),biasInitializer:Ux(this.biasInitializer),kernelRegularizer:Mk(this.kernelRegularizer),recurrentRegularizer:Mk(this.recurrentRegularizer),biasRegularizer:Mk(this.biasRegularizer),activityRegularizer:Mk(this.activityRegularizer),kernelConstraint:Sw(this.kernelConstraint),recurrentConstraint:Sw(this.recurrentConstraint),biasConstraint:Sw(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};hI.className="SimpleRNNCell",Cc.registerClass(hI);var cI=class extends pI{constructor(e){e.cell=new hI(e),super(e)}call(e,t){return ri((()=>{null!=this.cell.dropoutMask&&(ai(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ai(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return new e(t)}};cI.className="SimpleRNN",Cc.registerClass(cI);var fI=class extends dI{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new db("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Ab(this.units,"units"),this.activation=$k(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=$k(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Gx(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Gx(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Gx(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Lk(e.kernelRegularizer),this.recurrentRegularizer=Lk(e.recurrentRegularizer),this.biasRegularizer=Lk(e.biasRegularizer),this.kernelConstraint=Tw(e.kernelConstraint),this.recurrentConstraint=Tw(e.recurrentConstraint),this.biasConstraint=Tw(e.biasConstraint),this.dropout=rx([1,ax([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=rx([1,ax([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){let t=(e=Kx(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ri((()=>{if(2!==e.length)throw new db(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=null!=t.training&&t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=xI({ones:()=>bp(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=xI({ones:()=>bp(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let a,s,i,o=this.dropoutMask,l=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=ko(e,o[0]));let u=gx(e,this.kernel.read());this.useBias&&(u=wx(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=ko(r,l[0]));let p=this.recurrentKernel.read(),[d,h]=Ed(p,[2*this.units,this.units],p.rank-1),c=gx(r,d),[f,m,g]=Ed(u,3,u.rank-1),[y,b]=Ed(c,2,c.rank-1);a=this.recurrentActivation.apply(xo(f,y)),s=this.recurrentActivation.apply(xo(m,b));let x=gx(ko(s,r),h);i=this.activation.apply(xo(g,x));let w=xo(ko(a,r),ko(xo(1,Uu(a)),i));return[w,w]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Ck(this.activation),recurrentActivation:Ck(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ux(this.kernelInitializer),recurrentInitializer:Ux(this.recurrentInitializer),biasInitializer:Ux(this.biasInitializer),kernelRegularizer:Mk(this.kernelRegularizer),recurrentRegularizer:Mk(this.recurrentRegularizer),biasRegularizer:Mk(this.biasRegularizer),activityRegularizer:Mk(this.activityRegularizer),kernelConstraint:Sw(this.kernelConstraint),recurrentConstraint:Sw(this.recurrentConstraint),biasConstraint:Sw(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};fI.className="GRUCell",Cc.registerClass(fI);var mI=class extends pI{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new fI(e),super(e)}call(e,t){return ri((()=>{null!=this.cell.dropoutMask&&(ai(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ai(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};mI.className="GRU",Cc.registerClass(mI);var gI=class extends dI{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ab(this.units,"units"),this.activation=$k(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=$k(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Gx(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Gx(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Gx(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Lk(e.kernelRegularizer),this.recurrentRegularizer=Lk(e.recurrentRegularizer),this.biasRegularizer=Lk(e.biasRegularizer),this.kernelConstraint=Tw(e.kernelConstraint),this.recurrentConstraint=Tw(e.recurrentConstraint),this.biasConstraint=Tw(e.biasConstraint),this.dropout=rx([1,ax([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=rx([1,ax([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;let n,r=(e=Kx(e))[e.length-1];if(this.kernel=this.addWeight("kernel",[r,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){let e=this.biasInitializer,r=this.units;n=new((t=class extends Nx{apply(t,n){let a=e.apply([r]),s=(new _x).apply([r]),i=e.apply([2*r]);return cx(cx(a,s),i)}}).className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return ri((()=>{let n=null!=t.training&&t.training;if(3!==e.length)throw new db(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=xI({ones:()=>bp(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=xI({ones:()=>bp(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s,i,o,l,u=this.dropoutMask,p=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=ko(e,u[0]));let d=gx(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=ko(r,p[0])),d=xo(d,gx(r,this.recurrentKernel.read())),this.useBias&&(d=wx(d,this.bias.read()));let[h,c,f,m]=Ed(d,4,d.rank-1);s=this.recurrentActivation.apply(h),i=this.recurrentActivation.apply(c),o=xo(ko(i,a),ko(s,this.activation.apply(f))),l=this.recurrentActivation.apply(m);let g=ko(l,this.activation.apply(o));return[g,g,o]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Ck(this.activation),recurrentActivation:Ck(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ux(this.kernelInitializer),recurrentInitializer:Ux(this.recurrentInitializer),biasInitializer:Ux(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Mk(this.kernelRegularizer),recurrentRegularizer:Mk(this.recurrentRegularizer),biasRegularizer:Mk(this.biasRegularizer),activityRegularizer:Mk(this.activityRegularizer),kernelConstraint:Sw(this.kernelConstraint),recurrentConstraint:Sw(this.recurrentConstraint),biasConstraint:Sw(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};gI.className="LSTMCell",Cc.registerClass(gI);var yI=class extends pI{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new gI(e),super(e)}call(e,t){return ri((()=>{null!=this.cell.dropoutMask&&(ai(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ai(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};yI.className="LSTM",Cc.registerClass(yI);var bI=class extends dI{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return ri((()=>{let n=e.slice(1),r=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();let a,s=[];for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(let e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)}))}build(e){let t;Hx(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{Xb(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){let e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t,n={}){let r=[];for(let e of t.cells)r.push(sv(e,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return Jx(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,a=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],a[e]])}Qx(t)}};function xI(e){let{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=e,i=()=>null!=s?s(t(),n):vx(t(),n),o=()=>kx(i,t,r);return!a||a<=1?si(o().clone()):Array(a).fill(void 0).map(o).map((e=>si(e.clone())))}bI.className="StackedRNNCells",Cc.registerClass(bI);var wI=class extends pI{constructor(e){if(e.unroll)throw new hb("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new hb("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new ew({ndim:5})]}call(e,t){return ri((()=>{if(null!=this.cell.dropoutMask&&(ai(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ai(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new db("ConvRNN2D cell does not support constants");let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return ri((()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=op([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(a):[a]}))}resetStates(e,t=!1){ri((()=>{if(!this.stateful)throw new ub("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new db("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>op(a))):this.states_=[op(a)];else if(null==e)ai(this.states_),null!=this.keptStates&&(ai(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>op(a))):this.states_[0]=op(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new db(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):ai(this.states_);for(let t=0;t<this.states_.length;++t){let n=e[t],r=a;if(!ka.arraysEqual(n.shape,r))throw new db(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>si(e.clone())))}))}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],p=Hk(l,r[0],a,s[0],i[0]),d=Hk(u,r[1],a,s[1],i[1]);return[...e.slice(0,2),...o?[n,p,d]:[p,d,n]]}};wI.className="ConvRNN2D";var vI=class extends gI{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Ab(this.filters,"filters"),this.kernelSize=Gk(n,2,"kernelSize"),this.kernelSize.forEach((e=>Ab(e,"kernelSize"))),this.strides=Gk(r||1,2,"strides"),this.strides.forEach((e=>Ab(e,"strides"))),this.padding=a||"valid",Hb(this.padding),this.dataFormat=s||"channelsLast",Gb(this.dataFormat),this.dilationRate=Gk(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>Ab(e,"dilationRate")))}build(e){var t;e=Kx(e);let n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new db(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){let n=this.biasInitializer,r=this.filters;e=new((t=class extends Nx{apply(e,t){return hx([n.apply([r]),lp([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return ri((()=>{if(3!==e.length)throw new db(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],a=e[1],s=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=xI({ones:()=>bp(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?ko(t[n],e):e,l=o(r,i,0),u=o(r,i,1),p=o(r,i,2),d=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=xI({ones:()=>bp(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let h=this.recurrentDropoutMask,c=o(a,h,0),f=o(a,h,1),m=o(a,h,2),g=o(a,h,3),[y,b,x,w]=Ed(this.kernel.read(),4,3),[v,k,I,S]=this.useBias?Ed(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,v,this.padding),u=this.inputConv(u,b,k,this.padding),p=this.inputConv(p,x,I,this.padding),d=this.inputConv(d,w,S,this.padding);let[N,T,_,C]=Ed(this.recurrentKernel.read(),4,3);c=this.recurrentConv(c,N),f=this.recurrentConv(f,T),m=this.recurrentConv(m,_),g=this.recurrentConv(g,C);let E=this.recurrentActivation.apply(xo(l,c)),$=this.recurrentActivation.apply(xo(u,f)),A=xo(ko($,s),ko(E,this.activation.apply(xo(p,m)))),F=ko(this.recurrentActivation.apply(xo(d,g)),this.activation.apply(A));return[F,F,A]}))}getConfig(){let e=super.getConfig(),{units:t}=e,n=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n}(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){let a=Il(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?wx(a,n,this.dataFormat):a}recurrentConv(e,t){return Il(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}};vI.className="ConvLSTM2DCell",Cc.registerClass(vI);var kI=class extends wI{constructor(e){let t=new vI(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};kI.className="ConvLSTM2D",Cc.registerClass(kI);var II=class extends sw{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;let t=e.shape,n=[];for(let e=0;e<this.noiseShape.length;++e)n.push(null==this.noiseShape[e]?t[e]:this.noiseShape[e]);return n}call(e,t){return ri((()=>{this.invokeCallHook(e,t);let n=qx(e);if(0<this.rate&&this.rate<1){let e=null!=t.training&&t.training,r=this.getNoiseShape(n);return kx((()=>vx(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};II.className="Dropout",Cc.registerClass(II);var SI=class extends II{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};SI.className="SpatialDropout1D",Cc.registerClass(SI);var NI=class extends sw{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Ab(this.units,"units"),this.activation=$k(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=Gx(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Gx(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Tw(e.kernelConstraint),this.biasConstraint=Tw(e.biasConstraint),this.kernelRegularizer=Lk(e.kernelRegularizer),this.biasRegularizer=Lk(e.biasRegularizer),this.activityRegularizer=Lk(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){let t=(e=Kx(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){let t=(e=Kx(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return ri((()=>{this.invokeCallHook(e,t);let n,r=qx(e),a=Rb(this.activation.getClassName());return null!=a?n=gx(r,this.kernel.read(),a,this.bias?this.bias.read():null):(n=gx(r,this.kernel.read()),null!=this.bias&&(n=wx(n,this.bias.read())),null!=this.activation&&(n=this.activation.apply(n))),n}))}getConfig(){let e={units:this.units,activation:Ck(this.activation),useBias:this.useBias,kernelInitializer:Ux(this.kernelInitializer),biasInitializer:Ux(this.biasInitializer),kernelRegularizer:Mk(this.kernelRegularizer),biasRegularizer:Mk(this.biasRegularizer),activityRegularizer:Mk(this.activityRegularizer),kernelConstraint:Sw(this.kernelConstraint),biasConstraint:Sw(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};NI.className="Dense",Cc.registerClass(NI);var TI=class extends sw{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Kx(e);for(let t of e.slice(1))if(null==t)throw new db(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],nx(e,1)]}call(e,t){return ri((()=>{this.invokeCallHook(e,t);let n=qx(e);if("channelsFirst"===this.dataFormat&&n.rank>1){let e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=ah(n,e)}return function(e){if(e.rank<=1)throw new db(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],nx(e.shape,1)];return Zo(e,t)}(n)}))}getConfig(){let e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};TI.className="Flatten",Cc.registerClass(TI);var _I=class extends sw{constructor(e){super(e),this.supportsMasking=!0,this.activation=$k(e.activation)}call(e,t){return ri((()=>{this.invokeCallHook(e,t);let n=qx(e);return this.activation.apply(n)}))}getConfig(){let e={activation:Ck(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};_I.className="Activation",Cc.registerClass(_I);var CI=class extends sw{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return ri((()=>function(e,t){return ri((()=>{if(2!==e.shape.length)throw new db(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return fx(lx(e,1),[1,t,1])}))}(e=qx(e),this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};CI.className="RepeatVector",Cc.registerClass(CI);var EI=class extends sw{constructor(e){super(e),this.targetShape=e.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),a=1,s=null;for(let e=0;e<r.length;++e){let t=r[e];if(this.isUnknown(t)){if(null!==s)throw new db("Can only specifiy one unknown dimension.");s=e}else a*=t}let i=nx(e);if(null!==s){if(0===a||i%a!=0)throw new db(n);r[s]=i/a}else if(i!==a)throw new db(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return ri((()=>{this.invokeCallHook(e,t);let n=qx(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return Zo(n,a)}))}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};EI.className="Reshape",Cc.registerClass(EI);var $I=class extends sw{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=sx(1,e.dims.length+1);if(!ka.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ew({ndim:this.dims.length+1})]}computeOutputShape(e){let t=(e=Kx(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return ah(qx(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};$I.className="Permute",Cc.registerClass($I);var AI=class extends sw{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=qx(e);return Co(gp(n,this.maskValue),-1)}call(e,t){return ri((()=>{this.invokeCallHook(e,t);let n=qx(e),r=Co(gp(n,this.maskValue),-1,!0);return ko(n,go(r,n.dtype))}))}};AI.className="Masking",Cc.registerClass(AI);var FI=class extends sw{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(xb(e.inputLength))}this.inputDim=e.inputDim,Ab(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Ab(this.outputDim,"outputDim"),this.embeddingsInitializer=Gx(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Lk(e.embeddingsRegularizer),this.activityRegularizer=Lk(e.activityRegularizer),this.embeddingsConstraint=Tw(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return ri((()=>this.maskZero?(e=qx(e),gp(e,Hl(e))):null))}computeOutputShape(e){if(e=Kx(e),null==this.inputLength)return[...e,this.outputDim];let t=xb(this.inputLength);if(t.length!==e.length-1)throw new db(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let a=t[r],s=e[r+1];if(null!=a&&null!=s&&a!==s)throw new db(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==a&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return ri((()=>{this.invokeCallHook(e,t);let n=qx(e);"int32"!==n.dtype&&(n=ox(n,"int32"));let r=yx(this.embeddings.read(),Zo(n,[n.size]));return Zo(r,Kx(this.computeOutputShape(n.shape)))}))}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ux(this.embeddingsInitializer),embeddingsRegularizer:Mk(this.embeddingsRegularizer),activityRegularizer:Mk(this.activityRegularizer),embeddingsConstraint:Sw(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};FI.className="Embedding",Cc.registerClass(FI);var RI=class extends sw{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new hb}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let a=e[e.length-t.length+r],s=t[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new db("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Kx(e)]),e.length<2)throw new db(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let n of e)null!=n&&null!==n[0]&&t.push(n[0]);if(t=_b(t),t.length>1)throw new db(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let t=1;t<e.length;++t){let r=null==e[t]?null:e[t].slice(1);n=this.computeElementwiseOpOutputShape(n,r)}let r=e.map((e=>e.length));-1===e.indexOf(null)&&1===_b(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return ri((()=>{if(this.reshapeRequired){let t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){let r=ax(n);for(let n of e){let e=n.rank;for(let t=0;t<r-e;++t)n=lx(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(let r of e){let e=r.rank;if(null==e){let e=r.shape,a=e[0],s=e.slice(1).concat([a]),i=Zo(r,[a].concat(nx(e.slice(1))));i=ah(i,[1,0]),i=Zo(i,s),t.push(i),n=!0}else if(e>1){let a=sx(1,e).concat([0]);t.push(ah(r,a)),n=!0}else t.push(r)}let r=this.mergeFunction(t),a=r.rank;if(n)if(null==a){let e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=Zo(ah(Zo(r,[-1,t]),[1,0]),n)}else if(a>1){let e=[a-1].concat(sx(0,a-1));r=ah(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let n=1;n<e.length;++n){let r=null==e[n]?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let n=[];for(let t of e)null!=t&&null!==t[0]&&n.push(t[0]);return n=_b(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return ri((()=>{if(null==t)return null;if(!Array.isArray(t))throw new db("`mask` should be an Array");if(!Array.isArray(e))throw new db("`inputs` should be an Array");if(t.length!==e.length)throw new db(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:yu(e,0))))[0];for(let e=1;e<t.length-1;++e)n=Xu(n,t[e]);return n}))}},DI=class extends RI{constructor(e){super(e)}mergeFunction(e){return ri((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=xo(t,e[n]);return t}))}};DI.className="Add",Cc.registerClass(DI);var MI=class extends RI{constructor(e){super(e)}mergeFunction(e){return ri((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=ko(t,e[n]);return t}))}};MI.className="Multiply",Cc.registerClass(MI);var OI=class extends RI{constructor(e){super(e)}mergeFunction(e){return ri((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=xo(t,e[n]);return ko(1/e.length,t)}))}};OI.className="Average",Cc.registerClass(OI);var LI=class extends RI{constructor(e){super(e)}mergeFunction(e){return ri((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=sp(t,e[n]);return t}))}};LI.className="Maximum",Cc.registerClass(LI);var zI=class extends RI{constructor(e){super(e)}mergeFunction(e){return ri((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=pp(t,e[n]);return t}))}};zI.className="Minimum",Cc.registerClass(zI);var PI=class extends RI{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new db("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(let n of e)if(null!=n){t=!1;break}if(t)return;let n=[];for(let t=0;t<e.length;++t){let r=e[t].slice();r.splice(this.axis,1);let a=!1;for(let e of n)if(ka.arraysEqual(e,r)){a=!0;break}a||n.push(r)}if(n.length>1)throw new db("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return ri((()=>hx(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new db("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let e of t.slice(1)){if(null==n[r]||null==e[r]){n[r]=null;break}n[r]+=e[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new db("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new db("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new db(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return ri((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;let r=[];for(let n=0;n<e.length;++n)null==t[n]?r.push(go(bp(e[n]),"bool")):t[n].rank<e[n].rank?r.push(yu(t[n],-1)):r.push(t[n]);let a=el(r,this.axis);return _o(a,-1,!1)}))}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function BI(e,t){for(;e<0;)e+=t;return e}PI.className="Concatenate",Cc.registerClass(PI);var WI=class extends RI{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){ka.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new hb("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new db(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new db(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>BI(t,e[n].shape.length))):[BI(this.axes,n.shape.length),BI(this.axes,r.shape.length)],this.normalize&&(n=iv(n,t[0]),r=iv(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new hb("batchDot is not implemented for tensors of 4D or higher rank yet");if(ka.assert(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),ka.assert(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new hb("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,a=t.shape.length;null==n&&(n=[r-1,a-2]);let s=n;return ri((()=>{let n,i;if(r>a){n=r-a;let e=[];for(let t=0;t<n;++t)e.push(1);t=Zo(t,t.shape.concat(e))}else if(a>r){n=a-r;let t=[];for(let e=0;e<n;++e)t.push(1);e=Zo(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=s[0]===s[1]?hu(ko(e,t),s[0]):hu(ko(ah(e,[1,0]),t),s[1]);else{let n=s[0]!==e.shape.length-1,r=s[1]===t.shape.length-1;i=tl(e,t,n,r)}if(n>0){let e;e=r>a?r+a-3:r-1;let t=[];for(let r=e;r<e+n;++r)t.push(r);i=Fd(i,t)}return 1===i.shape.length&&(i=yu(i,1)),i}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[BI(this.axes,e.length),BI(this.axes,t.length)],n}computeOutputShape(e){ka.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new hb("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let a=t.concat(n);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};WI.className="Dot",Cc.registerClass(WI);var VI=class extends sw{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return ri((()=>{this.invokeCallHook(e,t);let n=qx(e);return kx((()=>xo(mx(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}};VI.className="GaussianNoise",Cc.registerClass(VI);var UI=class extends sw{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ri((()=>{this.invokeCallHook(e,t);let n=qx(e);return this.rate>0&&this.rate<1?kx((()=>{let e=Math.sqrt(this.rate/(1-this.rate));return ko(n,mx(n.shape,1,e))}),(()=>n),t.training||!1):n}))}};UI.className="GaussianDropout",Cc.registerClass(UI);var GI=class extends sw{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||qx(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ri((()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return kx((()=>{let t=qx(e),r=-1.7580993408473766,a=Su(td(n),this.rate);a=ox(a,"float32");let s=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-s*r*this.rate,o=xo(ko(t,a),ko(xo(a,-1),r));return xo(ko(o,s),i)}),(()=>qx(e)),t.training||!1)}return e}))}};function HI(e,t,n,r,a,s=.001){let i;if(2===e.rank)i=ul(e,t,n,r,a,s);else if(3===e.rank)i=pl(e,t,n,r,a,s);else{if(4!==e.rank)throw new hb(`batchNormalization is not implemented for array of rank ${e.rank} yet`);i=dl(e,t,n,r,a,s)}return i}function jI(e,t,n,r,a=.001){return ka.arraysEqual(r.slice().sort(),sx(0,e.rank-1))?function(e,t,n,r,a=.001){return ri((()=>{let s=cp(e,r),i=s.mean,o=s.variance;return[HI(e,i,o,n,t,a),i,o]}))}(e,t,n,r,a):function(e,t,n,r,a=.001){return ri((()=>{let s=cp(e,r),i=s.mean,o=s.variance,l=[];for(let t of sx(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);let u=Zo(i,l),p=Zo(o,l),d=null==t?null:Zo(t,l),h=null==n?null:Zo(n,l);return[HI(e,u,p,h,d,a),i,o]}))}(e,t,n,r,a)}GI.className="AlphaDropout",Cc.registerClass(GI);var qI=class extends sw{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Gx(e.betaInitializer||"zeros"),this.gammaInitializer=Gx(e.gammaInitializer||"ones"),this.movingMeanInitializer=Gx(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Gx(e.movingVarianceInitializer||"ones"),this.betaConstraint=Tw(e.betaConstraint),this.gammaConstraint=Tw(e.gammaConstraint),this.betaRegularizer=Lk(e.betaRegularizer),this.gammaRegularizer=Lk(e.gammaRegularizer)}build(e){e=Kx(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new db(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new ew({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return ri((()=>{let n=null!=t.training&&t.training,r=qx(e),a=r.shape,s=a.length,i=sx(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let l=mb(1,s);l[o]=a[o];let u=i.slice();u.sort();let p=!ka.arraysEqual(u,sx(0,s).slice(0,s-1));if(!n)return(()=>{if(p){let e=Zo(this.movingMean.read(),l),t=Zo(this.movingVariance.read(),l),n=this.center?Zo(this.beta.read(),l):null,a=this.scale?Zo(this.gamma.read(),l):null;return HI(r,e,t,n,a,this.epsilon)}return HI(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();let[d,h,c]=jI(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{ri((()=>{let r=1-n,a=e.read(),s=ko(ju(a,t),r);e.write(ju(a,s))}))};return f(this.movingMean,h,this.momentum),f(this.movingVariance,c,this.momentum),d}))}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ux(this.betaInitializer),gammaInitializer:Ux(this.gammaInitializer),movingMeanInitializer:Ux(this.movingMeanInitializer),movingVarianceInitializer:Ux(this.movingVarianceInitializer),betaRegularizer:Mk(this.betaRegularizer),gammaRegularizer:Mk(this.gammaRegularizer),betaConstraint:Sw(this.betaConstraint),gammaConstraint:Sw(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};qI.className="BatchNormalization",Cc.registerClass(qI);var KI=class extends sw{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(let e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Gx(e.betaInitializer||"zeros"),this.gammaInitializer=Gx(e.gammaInitializer||"ones"),this.betaRegularizer=Lk(e.betaRegularizer),this.gammaRegularizer=Lk(e.gammaRegularizer),this.supportsMasking=!0}build(e){let t=(e=Kx(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let e=0;e<this.axis.length;++e)this.axis[e]<0&&(this.axis[e]+=t);for(let e of this.axis)if(e<0||e>=t)throw new Error(`Invalid axis: ${e}`);if(this.axis.length!==_b(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map((t=>e[t]));this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,true):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,true):this.beta=null,this.built=!0}call(e,t){let n=qx(e),r=n.shape,a=r.length;return ri((()=>{let{mean:e,variance:t}=cp(n,this.axis,!0),s=mb(1,a);for(let e of this.axis)s[e]=r[e];let i=e=>null!=e&&e.shape.length!==a?Zo(e,s):e,o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null,u=[],p=[];for(let e=0;e<a;++e)-1!==this.axis.indexOf(e)?(u.push(r[e]),p.push(1)):(u.push(1),p.push(r[e]));return e=xu(e,u),t=xu(t,u),null!=o&&(o=xu(o,p)),null!=l&&(l=xu(l,p)),HI(n,e,t,l,o,this.epsilon)}))}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ux(this.betaInitializer),gammaInitializer:Ux(this.gammaInitializer),betaRegularizer:Mk(this.betaRegularizer),gammaRegularizer:Mk(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};KI.className="LayerNormalization",Cc.registerClass(KI);var XI=class extends sw{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new db(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new db(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new db(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new ew({ndim:4})]}computeOutputShape(e){let t,n;return e=Kx(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return ri((()=>function(e,t,n){return ri((()=>{if(4!==e.rank)throw new db(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new db("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n="channelsLast"),"channelsLast"!==n&&"channelsFirst"!==n)throw new db(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],wp(e,r)}))}(qx(e),this.padding,this.dataFormat)))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};function YI(e,t,n,r,a,s){return ri((()=>{Gb(a),jb(s),Hb(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),e=qk(e,a);let i,o="same"===r?"same":"valid";return i="max"===s?np(e,t,n,o):Jo(e,t,n,o),"channelsFirst"===a&&(i=ah(i,[0,3,1,2])),i}))}function ZI(e,t,n,r,a,s){return ri((()=>{Gb(a),jb(s),Hb(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),e=Kk(e,a);let i,o="same"===r?"same":"valid";return i="max"===s?rp(e,t,n,o):Qo(e,t,n,o),"channelsFirst"===a&&(i=ah(i,[0,4,1,2,3])),i}))}XI.className="ZeroPadding2D",Cc.registerClass(XI);var JI=class extends sw{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new db(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(Ab(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new db(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}Ab(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,Hb(this.padding),this.inputSpec=[new ew({ndim:3})]}computeOutputShape(e){let t=Hk((e=Kx(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return ri((()=>{this.invokeCallHook(e,t),e=lx(qx(e),2);let n=this.poolingFunction(qx(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Fd(n,[2])}))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},QI=class extends JI{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Gb(a),Hb(r),YI(e,t,n,r,a,"max")}};QI.className="MaxPooling1D",Cc.registerClass(QI);var eS=class extends JI{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Gb(a),Hb(r),YI(e,t,n,r,a,"avg")}};eS.className="AveragePooling1D",Cc.registerClass(eS);var tS=class extends sw{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new db(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Ab(this.poolSize,"poolSize"),Ab(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Gb(this.dataFormat),Hb(this.padding),this.inputSpec=[new ew({ndim:4})]}computeOutputShape(e){e=Kx(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=Hk(t,this.poolSize[0],this.padding,this.strides[0]),n=Hk(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return ri((()=>(this.invokeCallHook(e,t),this.poolingFunction(qx(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},nS=class extends tS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Gb(a),Hb(r),YI(e,t,n,r,a,"max")}};nS.className="MaxPooling2D",Cc.registerClass(nS);var rS=class extends tS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Gb(a),Hb(r),YI(e,t,n,r,a,"avg")}};rS.className="AveragePooling2D",Cc.registerClass(rS);var aS=class extends sw{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new db(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Ab(this.poolSize,"poolSize"),Ab(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Gb(this.dataFormat),Hb(this.padding),this.inputSpec=[new ew({ndim:5})]}computeOutputShape(e){e=Kx(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=Hk(t,this.poolSize[0],this.padding,this.strides[0]),n=Hk(n,this.poolSize[1],this.padding,this.strides[1]),r=Hk(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return ri((()=>(this.invokeCallHook(e,t),this.poolingFunction(qx(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},sS=class extends aS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Gb(a),Hb(r),ZI(e,t,n,r,a,"max")}};sS.className="MaxPooling3D",Cc.registerClass(sS);var iS=class extends aS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Gb(a),Hb(r),ZI(e,t,n,r,a,"avg")}};iS.className="AveragePooling3D",Cc.registerClass(iS);var oS=class extends sw{constructor(e){super(e),this.inputSpec=[new ew({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new hb}},lS=class extends oS{constructor(e){super(e||{})}call(e,t){return ri((()=>{let t=qx(e);return ip(t,1)}))}};lS.className="GlobalAveragePooling1D",Cc.registerClass(lS);var uS=class extends oS{constructor(e){super(e||{})}call(e,t){return ri((()=>{let t=qx(e);return iu(t,1)}))}};uS.className="GlobalMaxPooling1D",Cc.registerClass(uS);var pS=class extends sw{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Gb(this.dataFormat),this.inputSpec=[new ew({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new hb}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},dS=class extends pS{call(e,t){return ri((()=>{let t=qx(e);return"channelsLast"===this.dataFormat?ip(t,[1,2]):ip(t,[2,3])}))}};dS.className="GlobalAveragePooling2D",Cc.registerClass(dS);var hS=class extends pS{call(e,t){return ri((()=>{let t=qx(e);return"channelsLast"===this.dataFormat?iu(t,[1,2]):iu(t,[2,3])}))}};hS.className="GlobalMaxPooling2D",Cc.registerClass(hS);var cS=class extends sw{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=sv(t.layer,n);delete t.layer;let a={layer:r};return Object.assign(a,t),new e(a)}},fS=class extends cS{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Kx(e)).length<3)throw new db(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){let t=[(e=Kx(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return ri((()=>uI(((e,n)=>[qx(this.layer.call(e,t)),[]]),e=qx(e),[],!1,null,null,!1,!0)[1]))}};fS.className="TimeDistributed",Cc.registerClass(fS);var mS=class extends cS{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=sv(n),t.goBackwards=!0!==t.goBackwards;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=sv(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function(e){Eb(Vb,"BidirectionalMergeMode",e)}(this.mergeMode),e.weights)throw new hb("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,a=this.forwardLayer.computeOutputShape(e);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState&&(r=a.slice(1)),t=a[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):bb(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=lI(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);let s=[],i=[];if(null!=n){let e=n.length;if(e%2>0)throw new db("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);let r=n.map((e=>new ew({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new hb("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof tw;for(let e of s)if(e instanceof tw!==o)throw new db("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;let o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return ri((()=>{let n,r,a,s,i=t.initialState;if(null==i)n=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{let a=i.slice(0,i.length/2),s=i.slice(i.length/2);n=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:s}))}return this.returnState&&(Array.isArray(n)&&(a=n.slice(1).concat(r.slice(1))),n=n[0],r=r[0]),this.returnSequences&&(r=ld(r,1)),"concat"===this.mergeMode?s=hx([n,r]):"sum"===this.mergeMode?s=xo(n,r):"ave"===this.mergeMode?s=ko(.5,xo(n,r)):"mul"===this.mergeMode?s=ko(n,r):null==this.mergeMode&&(s=[n,r]),this.returnState?null==this.mergeMode?s.concat(a):[s].concat(a):s}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Xb(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),Xb(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){let e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=sv(t.layer);if(delete t.layer,null!=t.numConstants)throw new hb("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};mS.className="Bidirectional",Cc.registerClass(mS);var gS=class extends sw{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ri((()=>("float32"!==(e=qx(e)).dtype&&(e=ox(e,"float32")),xo(ko(e,this.scale),this.offset))))}};gS.className="Rescaling",Cc.registerClass(gS);var{resizeBilinear:yS,cropAndResize:bS}=Ic,xS=class extends sw{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,s,i,o){return ri((()=>{let l,u=!1,p=[t/s,n/i,(r+t)/s,(a+n)/i],d=[];3===e.rank?(u=!0,l=Rd([e])):l=e;for(let e=0;e<l.shape[0];e++)d.push(p);let h=js(d,[d.length,4]),c=rd(0,d.length,1,"int32"),f=bS(l,h,c,[r,a],"nearest");return ox(u?qx(Jd(f)):f,o)}))}upsize(e,t,n,r){return ri((()=>ox(yS(e,[t,n]),r)))}call(e,t){return ri((()=>{let t=qx(e),n=t.dtype,r=t.shape,a=r[r.length-3],s=r[r.length-2],i=0;a!==this.height&&(i=Math.floor((a-this.height)/2));let o=0;return s!==this.width&&(o=Math.floor((s-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,a,s,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){let t=(e=Kx(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};xS.className="CenterCrop",Cc.registerClass(xS);var wS=class extends sw{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=Kx(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return ri((()=>{let n;if("int32"!==(e=qx(e)).dtype&&(e=ox(e,"int32")),void 0!==t.countWeights){if("count"!==this.outputMode)throw new db(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=qx(t.countWeights)}let r=iu(e),a=ou(e),s=Iu(this.numTokens,r).bufferSync().get(0),i=Su(a,0).bufferSync().get(0);if(!s||!i)throw new db(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let a=qx(e);if("int32"!==a.dtype&&(a=ox(a,"int32")),"int"===t)return a;let s=a.shape;if(0===a.rank&&(a=yu(a,-1)),"oneHot"===t&&1!==a.shape[a.shape.length-1]&&(a=yu(a,-1)),a.rank>2)throw new db(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${a.rank}.`);let i,o=["multiHot","oneHot"].includes(t),l=a;if(i=Dl(l,void 0!==r&&"count"===t?r:[],n,o),"tfIdf"!==t)return i;if(r)return ko(i,r);throw new db("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}};wS.className="CategoryEncoding",Cc.registerClass(wS);var vS=new Set(["bilinear","nearest"]),kS=class extends sw{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!vS.has(e.interpolation))throw new db(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){let t=(e=Kx(e))[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ri((()=>{let t=[this.height,this.width];if("bilinear"===this.interpolation)return Ic.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Ic.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...vS]} are supported`)}))}};kS.className="Resizing",Cc.registerClass(kS);var IS=class{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}};IS.className="RandomSeed";var SS=class extends sw{constructor(e){super(e),this.randomGenerator=new IS(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};SS.className="BaseRandomLayer";var NS=new Set(["bilinear","nearest"]),TS=class extends SS{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new db(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new db(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new db(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!NS.has(n))throw new db(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){let t=(e=Kx(e))[2];return[this.imgHeight,-1,t]}call(e,t){return ri((()=>{let t=qx(e);this.imgHeight=t.shape[t.shape.length-3];let n=t.shape[t.shape.length-2];this.widthFactor=td([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);let a=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return Ic.resizeBilinear(e,a);case"nearest":return Ic.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...NS]} are supported`)}}))}};function _S(e){return new ow(e)}function CS(e){return new Wk(e)}function ES(e){return new zk(e)}function $S(e){return new Pk(e)}function AS(e){return new Bk(e)}function FS(e){return new Uk(e)}function RS(e){return new Vk(e)}function DS(e){return new aI(e)}function MS(e){return new Jk(e)}function OS(e){return new eI(e)}function LS(e){return new Qk(e)}function zS(e){return new tI(e)}function PS(e){return new rI(e)}function BS(e){return new sI(e)}function WS(e){return new iI(e)}function VS(e){return new oI(e)}function US(e){return new _I(e)}function GS(e){return new NI(e)}function HS(e){return new II(e)}function jS(e){return new SI(e)}function qS(e){return new TI(e)}function KS(e){return new CI(e)}function XS(e){return new EI(e)}function YS(e){return new $I(e)}function ZS(e){return new FI(e)}function JS(e){return new DI(e)}function QS(e){return new OI(e)}function eN(e){return new PI(e)}function tN(e){return new LI(e)}function nN(e){return new zI(e)}function rN(e){return new MI(e)}function aN(e){return new WI(e)}function sN(e){return new qI(e)}function iN(e){return new KI(e)}function oN(e){return new XI(e)}function lN(e){return new eS(e)}function uN(e){return lN(e)}function pN(e){return lN(e)}function dN(e){return new rS(e)}function hN(e){return dN(e)}function cN(e){return dN(e)}function fN(e){return new iS(e)}function mN(e){return fN(e)}function gN(e){return fN(e)}function yN(e){return new lS(e)}function bN(e){return new dS(e)}function xN(e){return new uS(e)}function wN(e){return new hS(e)}function vN(e){return new QI(e)}function kN(e){return new nS(e)}function IN(e){return new sS(e)}function SN(e){return new mI(e)}function NN(e){return new fI(e)}function TN(e){return new yI(e)}function _N(e){return new gI(e)}function CN(e){return new cI(e)}function EN(e){return new hI(e)}function $N(e){return new kI(e)}function AN(e){return new vI(e)}function FN(e){return new pI(e)}function RN(e){return new bI(e)}function DN(e){return new mS(e)}function MN(e){return new fS(e)}TS.className="RandomWidth",Cc.registerClass(TS);var ON=xN,LN=wN,zN=vN,PN=kN;function BN(e){return new VI(e)}function WN(e){return new UI(e)}function VN(e){return new GI(e)}function UN(e){return new AI(e)}function GN(e){return new gS(e)}function HN(e){return new xS(e)}function jN(e){return new kS(e)}function qN(e){return new wS(e)}function KN(e){return new TS(e)}var XN={};function YN(e,t){return gv(e,t)}function ZN(e,t){return vv(e,t)}function JN(e,t){return kv(e,t)}function QN(e,t){return yv(e,t)}function eT(e,t){return Iv(e,t)}function tT(e,t){return xv(e,t)}function nT(e,t){return wv(e,t)}function rT(e,t){return cv(e,t)}function aT(e,t){return lv(e,t)}function sT(e,t){return uv(e,t)}function iT(e,t){return uv(e,t)}function oT(e,t){return uv(e,t)}function lT(e,t){return ov(e,t)}function uT(e,t){return ov(e,t)}function pT(e,t){return ov(e,t)}function dT(e,t){return function(e,t){return ri((()=>{let n=e.sub(t).square().sum(),r=e.sub(e.mean()).square().sum();return uu(1).sub(n.div(r))}))}(e,t)}g(XN,{MAPE:()=>iT,MSE:()=>uT,binaryAccuracy:()=>YN,binaryCrossentropy:()=>ZN,categoricalAccuracy:()=>QN,categoricalCrossentropy:()=>eT,cosineProximity:()=>rT,mape:()=>oT,meanAbsoluteError:()=>aT,meanAbsolutePercentageError:()=>sT,meanSquaredError:()=>lT,mse:()=>pT,precision:()=>tT,r2Score:()=>dT,recall:()=>nT,sparseCategoricalAccuracy:()=>JN});var hT={};g(hT,{modelFromJSON:()=>ak});var cT={};function fT(e){return new Rk(e)}function mT(e){return function(e){return Ak(e),new Rk({l1:null!=e?e.l1:null,l2:0})}(e)}function gT(e){return function(e){return Ak(e),new Rk({l2:null!=e?e.l2:null,l1:0})}(e)}g(cT,{l1:()=>mT,l1l2:()=>fT,l2:()=>gT});var yT=class extends Zw{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof nk))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function bT(e,t){return e<t}function xT(e,t){return e>t}var wT=class extends yT{constructor(e){if(super(),null==e&&(e={}),e.restoreBestWeights)throw new hb("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=bT:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=xT:this.monitorFunc=bT,this.monitorFunc===bT&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===bT?1/0:-1/0}async onEpochEnd(e,t){await Xw(t);let n=this.getMonitorValue(t);null!=n&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){null==e&&(e={});let t=e[this.monitor];return null==t&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};var vT,kT,IT={earlyStopping:function(e){return new wT(e)}};Pe().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(vT||(vT={})),function(e){let t;var n;(n=t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))[n.LEGACY=0]="LEGACY",n[n.V1=1]="V1",n[n.V2=2]="V2"}(kT||(kT={}));var ST={};function NT(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};ST[e]=n}function TT(e){return ST[e]}function _T(e){delete ST[e]}function CT(e,t,n,r,a){let s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){let e=s.inputIndexStart,i=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===s.type)return ET(t.inputNames[o],n,r,a);if("tensors"===s.type){let s=t.inputs.slice(e,i);return t.inputNames.slice(e,i).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=s[t])||void 0===n?void 0:n.op)})).map((e=>ET(e,n,r,a)))}let l=ET(t.inputNames[o],n,r,a),u=l.dataSync();return"number"===s.type?u[0]:ka.toNestedArray(l.shape,u)}let i=t.attrParams[e];return i&&i.value}function ET(e,t,n,r){let[a,s]=RT(e,n);if(null!=r){let e=r.getHashTableHandleByName(a);if(null!=e)return e}let i=n.currentContextIds.find((e=>!!t[FT(a,e)]));return void 0!==i?t[FT(a,i)][s]:void 0}function $T(e,t,n){return t[FT(e,n.currentContextId)]}function AT(e,t){let[n,r,a]=RT(e,t);return[FT(n,t&&t.currentContextId),r,a]}function FT(e,t){return t?`${e}-${t}`:e}function RT(e,t){if(""===e)return["",0,void 0];let n=null!=t&&null!=t.parseNodeNameCache;if(n){let n=t.parseNodeNameCache.get(e);if(null!=n)return n}let r,a=e.split(":");if(1===a.length)r=[e,0,void 0];else{let e=a[0],t=3===a.length?a[1]:void 0;r=[e,Number(a[a.length-1]),t]}return n&&t.parseNodeNameCache.set(e,r),r}function DT(e,t,n){let r=CT("pad",e,t,n);if("explicit"===r){r=CT("explicitPaddings",e,t,n);let a=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)a[e][0]=r[2*e],a[e][1]=r[2*e+1];return a}return r}function MT(e){return e.kept?e:yo(e)}var OT={};g(OT,{json:()=>LT});var LT=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],zT={};g(zT,{json:()=>PT});var PT=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],BT={};g(BT,{json:()=>WT});var WT=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],VT={};g(VT,{json:()=>UT});var UT=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],GT={};g(GT,{json:()=>HT});var HT=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],jT={};g(jT,{json:()=>qT});var qT=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],KT={};g(KT,{json:()=>XT});var XT=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],YT={};g(YT,{json:()=>ZT});var ZT=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],JT={};g(JT,{json:()=>QT});var QT=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],e_={};g(e_,{json:()=>t_});var t_=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],n_={};g(n_,{json:()=>r_});var r_=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],a_={};g(a_,{json:()=>s_});var s_=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],i_={};g(i_,{json:()=>o_});var o_=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],l_={};g(l_,{json:()=>u_});var u_=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],p_={};g(p_,{json:()=>d_});var d_=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],h_={};g(h_,{json:()=>c_});var c_=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],f_={};g(f_,{json:()=>m_});var m_=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],g_={};g(g_,{json:()=>y_});var y_=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],b_={};g(b_,{json:()=>x_});var x_=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],w_=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[].concat(...[OT,zT,BT,VT,GT,jT,KT,YT,JT,e_,n_,a_,i_,l_,p_,h_,f_,g_,b_].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e,t={}){let n=e.node,r=[],a=[],s=[],i=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?a.push(e[t.name]):(null==t.input||0===t.input.length)&&s.push(e[t.name]),e)),{}),o=[],l=[],u={},p={};null!=t&&(u=this.mapSignatureEntries(t.inputs),p=this.mapSignatureEntries(t.outputs));let d=Object.keys(i);d.forEach((e=>{let t=i[e];t.inputNames.forEach(((e,n)=>{let[r,,a]=AT(e),s=i[r];if(null!=s.outputs){let e=s.outputs.indexOf(a);if(-1!==e){let a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(s),s.children.push(t)}))})),0===Object.keys(p).length?d.forEach((e=>{let t=i[e];0===t.children.length&&l.push(t)})):Object.keys(p).forEach((e=>{let[t]=AT(e),n=i[t];null!=n&&(n.signatureKey=p[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{let[t]=AT(e),n=i[t];n&&(n.signatureKey=u[e],o.push(n))})):o=r;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));let c={nodes:i,inputs:o,outputs:l,weights:a,placeholders:r,signature:t,functions:h};return s.length>0&&(c.initNodes=s),c}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){let t=TT(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{let r,a=n.type;switch(n.type){case"string":r=k_(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=k_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":r=F_(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=F_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":r=S_(e.attr,n.tfName,n.defaultValue||0),void 0===r&&n.tfDeprecatedName&&(r=S_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":r=A_(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=A_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":r=I_(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=I_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":r=D_(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=D_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":r=$_(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=$_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":r=R_(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=R_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":r=__(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=__(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":r=C_(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=C_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":r=T_(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=T_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:r,type:a},t}),{})),n}mapFunction(e){let t=e.nodeDef,n=[],r={};null!=t&&(r=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));let a=[],s=[];e.signature.inputArg.forEach((e=>{let[t]=AT(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:N_(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,a.push(n),r[t]=n})),Object.keys(r).forEach((e=>{let t=r[e];t.inputNames.forEach(((e,n)=>{let[a,,s]=AT(e),i=r[a];if(null!=i.outputs){let e=i.outputs.indexOf(s);if(-1!==e){let r=`${a}:${e}`;t.inputNames[n]=r}}t.inputs.push(i),i.children.push(t)}))}));let i=e.ret;e.signature.outputArg.forEach((e=>{let[t,n]=AT(i[e.name]),a=r[t];null!=a&&(a.defaultOutput=n,s.push(a))}));let o=this.mapArgsToSignature(e);return{nodes:r,inputs:a,outputs:s,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}};function v_(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){let t=Pe().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function k_(e,t,n,r=!1){let a=e[t];return null!=a?v_(a.s,r):n}function I_(e,t,n){let r=e[t];return r?r.b:n}function S_(e,t,n){let r=e[t]||{},a=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof a?a:parseInt(a,10)}function N_(e){switch("string"==typeof e&&(e=vT[e]),e){case vT.DT_FLOAT:case vT.DT_HALF:return"float32";case vT.DT_INT32:case vT.DT_INT64:case vT.DT_INT8:case vT.DT_UINT8:return"int32";case vT.DT_BOOL:return"bool";case vT.DT_DOUBLE:return"float32";case vT.DT_STRING:return"string";case vT.DT_COMPLEX64:case vT.DT_COMPLEX128:return"complex64";default:return null}}function T_(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function __(e,t,n){let r=e[t];return r&&r.type?N_(r.type):n}function C_(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>N_(e))):n}function E_(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function $_(e,t,n){let r=e[t];return r&&r.shape?E_(r.shape):n}function A_(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):n}function F_(e,t,n,r=!1){let a=e[t];return a&&a.list&&a.list.s?a.list.s.map((e=>v_(e,r))):n}function R_(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>E_(e))):n}function D_(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var M_=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return ET(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(null!=n.tensor)return ET(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return S_(this.node.rawAttrs,e,t);if(null!=n.s)return k_(this.node.rawAttrs,e,t);if(null!=n.b)return I_(this.node.rawAttrs,e,t);if(null!=n.shape)return $_(this.node.rawAttrs,e,t);if(null!=n.type)return __(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return A_(this.node.rawAttrs,e,t);if(null!=n.list.s)return F_(this.node.rawAttrs,e,t);if(null!=n.list.shape)return R_(this.node.rawAttrs,e,t);if(null!=n.list.b)return D_(this.node.rawAttrs,e,t);if(null!=n.list.type)return C_(this.node.rawAttrs,e,t)}return t}},O_={};g(O_,{OP_SCOPE_SUFFIX:()=>Vs,abs:()=>Io,acos:()=>So,acosh:()=>No,add:()=>xo,addN:()=>To,all:()=>_o,any:()=>Co,argMax:()=>Eo,argMin:()=>$o,asin:()=>Ao,asinh:()=>Fo,atan:()=>Ro,atan2:()=>Do,atanh:()=>Mo,avgPool:()=>Jo,avgPool3d:()=>Qo,basicLSTMCell:()=>sl,batchNorm:()=>ll,batchNorm2d:()=>ul,batchNorm3d:()=>pl,batchNorm4d:()=>dl,batchToSpaceND:()=>il,bincount:()=>hl,bitwiseAnd:()=>cl,booleanMaskAsync:()=>rh,broadcastArgs:()=>fl,broadcastTo:()=>ml,buffer:()=>mo,cast:()=>go,ceil:()=>gl,clipByValue:()=>bl,clone:()=>yo,complex:()=>Gs,concat:()=>el,concat1d:()=>xl,concat2d:()=>wl,concat3d:()=>vl,concat4d:()=>kl,conv1d:()=>Sl,conv2d:()=>Il,conv2dTranspose:()=>Tl,conv3d:()=>_l,conv3dTranspose:()=>El,cos:()=>$l,cosh:()=>Al,cosineWindow:()=>dh,cumprod:()=>Fl,cumsum:()=>Rl,denseBincount:()=>Dl,depthToSpace:()=>Ml,depthwiseConv2d:()=>Ol,diag:()=>Ll,dilation2d:()=>zl,div:()=>vo,divNoNan:()=>jl,dot:()=>ql,dropout:()=>uh,einsum:()=>Kl,elu:()=>Xl,enclosingPowerOfTwo:()=>ph,ensureShape:()=>Yl,equal:()=>Ul,erf:()=>Zl,euclideanNorm:()=>mu,exp:()=>gu,expandDims:()=>yu,expm1:()=>bu,eye:()=>wu,fft:()=>Td,fill:()=>yl,floor:()=>vu,floorDiv:()=>wo,fused:()=>ch,gather:()=>ku,gatherND:()=>lh,greater:()=>Iu,greaterEqual:()=>Su,ifft:()=>_d,imag:()=>Nu,image:()=>Ic,inTopKAsync:()=>hh,irfft:()=>Cd,isFinite:()=>Tu,isInf:()=>_u,isNaN:()=>Cu,leakyRelu:()=>Eu,less:()=>$u,lessEqual:()=>Au,linalg:()=>Sc,linspace:()=>Fu,localResponseNormalization:()=>Ru,log:()=>Du,log1p:()=>Mu,logSigmoid:()=>Hu,logSoftmax:()=>qu,logSumExp:()=>Ku,logicalAnd:()=>Xu,logicalNot:()=>Yu,logicalOr:()=>Zu,logicalXor:()=>Ju,losses:()=>Nc,lowerBound:()=>tp,matMul:()=>tl,max:()=>iu,maxPool:()=>np,maxPool3d:()=>rp,maxPoolWithArgmax:()=>ap,maximum:()=>sp,mean:()=>ip,meshgrid:()=>up,min:()=>ou,minimum:()=>pp,mirrorPad:()=>dp,mod:()=>hp,moments:()=>cp,movingAverage:()=>sh,mul:()=>ko,multiRNNCell:()=>fp,multinomial:()=>mp,neg:()=>Uu,norm:()=>fu,notEqual:()=>gp,oneHot:()=>yp,ones:()=>lp,onesLike:()=>bp,op:()=>Us,outerProduct:()=>xp,pad:()=>wp,pad1d:()=>vp,pad2d:()=>kp,pad3d:()=>Ip,pad4d:()=>Sp,pool:()=>Tp,pow:()=>lu,prelu:()=>_p,print:()=>bo,prod:()=>Cp,raggedGather:()=>Ep,raggedRange:()=>$p,raggedTensorToTensor:()=>Ap,rand:()=>Fp,randomGamma:()=>Jp,randomNormal:()=>Qp,randomStandardNormal:()=>ed,randomUniform:()=>td,randomUniformInt:()=>nd,range:()=>rd,real:()=>ad,reciprocal:()=>sd,relu:()=>id,relu6:()=>od,reshape:()=>Zo,reverse:()=>ld,reverse1d:()=>ud,reverse2d:()=>pd,reverse3d:()=>dd,reverse4d:()=>hd,rfft:()=>$d,round:()=>cd,rsqrt:()=>fd,scalar:()=>uu,scatterND:()=>ih,searchSorted:()=>ep,selu:()=>md,separableConv2d:()=>gd,setdiff1dAsync:()=>yd,sigmoid:()=>nl,sign:()=>bd,signal:()=>kc,sin:()=>xd,sinh:()=>wd,slice:()=>rl,slice1d:()=>vd,slice2d:()=>kd,slice3d:()=>Id,slice4d:()=>Sd,softmax:()=>Nd,softplus:()=>Gu,spaceToBatchND:()=>Np,sparse:()=>Tc,sparseToDense:()=>oh,spectral:()=>vc,split:()=>Ed,sqrt:()=>pu,square:()=>du,squaredDifference:()=>Ad,squeeze:()=>Fd,stack:()=>Rd,step:()=>Dd,stridedSlice:()=>Md,string:()=>_c,sub:()=>ju,sum:()=>hu,tan:()=>Od,tanh:()=>al,tensor:()=>js,tensor1d:()=>Ld,tensor2d:()=>zd,tensor3d:()=>Pd,tensor4d:()=>Bd,tensor5d:()=>Wd,tensor6d:()=>Vd,tensorScatterUpdate:()=>qd,tile:()=>xu,topk:()=>Kd,transpose:()=>ah,truncatedNormal:()=>Xd,unique:()=>Yd,unsortedSegmentSum:()=>Zd,unstack:()=>Jd,upperBound:()=>Qd,variable:()=>eh,where:()=>Gl,whereAsync:()=>nh,zeros:()=>op,zerosLike:()=>Hl});function L_(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){ka.assert(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){let a=e[r],s=t[r];ka.assert(a<0||s<0||a===s,(()=>n+` Shapes ${e} and ${t} must match`))}}}function z_(e){return!("number"==typeof e||e.some((e=>e<0)))}function P_(e,t,n){let r=B_(e,n),a=!z_(r);if(a&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach((e=>{r=B_(e.shape,r)})),!z_(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function B_(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let a=e[r],s=t[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:s}return n}var W_=class{constructor(e,t,n,r,a,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=uu(0),si(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{(null==e||!e.has(t.tensor.id))&&t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=t.shape),L_(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,si(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return js([],[0].concat(this.elementShape));let n=this.readMany(e);return L_(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Rd(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return js([],[0].concat(this.elementShape));let t=[];for(let e=0;e<this.size();e++)t.push(e);let n=this.readMany(t);return L_(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),el(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Jd(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let a=0===n?0:t.size/n,s=[];ri((()=>{t=Zo(t,[1,n,a]);for(let n=0;n<e.length;++n){let i=[0,0===n?0:r[n-1],0],o=[1,e[n],a];s[n]=Zo(rl(t,i,o),this.elementShape)}return s}));let i=[];for(let t=0;t<e.length;t++)i[t]=t;this.writeMany(i,s)}},V_=class e{get id(){return this.idTensor.id}constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);L_(t,e.shape,"TensorList shape mismatch: "),si(e)})),this.idTensor=uu(0),this.maxNumElements=r,si(this.idTensor)}copy(){return new e([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{(null==e||!e.has(t.id))&&t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);L_(e,this.elementShape,"TensorList shape mismatch: ");let r=P_(this.elementShape,this.tensors,e);return ri((()=>{let e=this.tensors.map((e=>Zo(e,r)));return Rd(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");let n=P_(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,L_(r.shape,e,"TensorList shape mismatch: "),Zo(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(L_(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");si(e),this.tensors.push(e)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new e([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let e=0;e<Math.min(this.tensors.length,t);++e)n.tensors[e]=this.tensors[e];return n}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);L_(this.tensors[e].shape,t,"TensorList shape mismatch: ");let r=P_(this.elementShape,this.tensors,t);return Zo(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);L_(this.elementShape,t.shape,"TensorList shape mismatch: "),si(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);L_(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let r=P_(this.elementShape,this.tensors,n);return 0===e.length?js([],[0].concat(r)):ri((()=>{let t=e.map((e=>Zo(this.tensors[e],r)));return Rd(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);L_(this.elementShape,t,"TensorList shape mismatch: ");let n=P_(this.elementShape,this.tensors,t);return 0===this.size()?js([],[0].concat(n)):ri((()=>{let e=this.tensors.map((e=>Zo(e,n)));return el(e,0)}))}};var U_=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=CT("thenBranch",e,t,n),a=CT("elseBranch",e,t,n),s=CT("cond",e,t,n),i=CT("args",e,t,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=CT("body",e,t,n),a=CT("cond",e,t,n),s=CT("args",e,t,n),i=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map((e=>e.id)),l=await i[0].data();i.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&e.dispose()}));let u=s;for(;l[0];){let e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let t=u.map((e=>e.id));e.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()}));let s=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await s[0].data(),s.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()}))}return u}case"LoopCond":return[MT(CT("pred",e,t,n))];case"Switch":{let r=CT("pred",e,t,n),a=CT("data",e,t,n);return a.kept||(a=MT(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{let r=e.inputNames.find((e=>void 0!==ET(e,t,n)));if(r){return[MT(ET(r,t,n))]}return}case"Enter":{let r=CT("frameName",e,t,n),a=CT("tensor",e,t,n);return n.enterFrame(r),[MT(a)]}case"Exit":{let r=CT("tensor",e,t,n);return n.exitFrame(),[MT(r)]}case"NextIteration":{let r=CT("tensor",e,t,n);return n.nextIteration(),[MT(r)]}case"TensorArrayV3":{let r=CT("size",e,t,n),a=CT("dtype",e,t,n),s=CT("elementShape",e,t,n),i=CT("dynamicSize",e,t,n),o=CT("clearAfterRead",e,t,n),l=CT("identicalElementShapes",e,t,n),u=CT("name",e,t,n),p=new W_(u,a,r,s,l,i,o);return n.addTensorArray(p),[p.idTensor,uu(1)]}case"TensorArrayWriteV3":{let r=CT("tensorArrayId",e,t,n),a=CT("index",e,t,n),s=CT("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(a,s),[i.idTensor]}case"TensorArrayReadV3":{let r=CT("tensorArrayId",e,t,n),a=CT("index",e,t,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{let r=CT("tensorArrayId",e,t,n),a=CT("indices",e,t,n),s=CT("dtype",e,t,n);return[n.getTensorArray(r.id).gather(a,s)]}case"TensorArrayScatterV3":{let r=CT("tensorArrayId",e,t,n),a=CT("indices",e,t,n),s=CT("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(a,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=CT("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),s=CT("dtype",e,t,n);return[a.concat(s)]}case"TensorArraySplitV3":{let r=CT("tensorArrayId",e,t,n),a=CT("tensor",e,t,n),s=CT("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(s,a),[i.idTensor]}case"TensorArraySizeV3":{let r=CT("tensorArrayId",e,t,n);return[uu(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{let r=CT("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{let r=CT("tensorListId",e,t,n),a=CT("index",e,t,n),s=CT("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(a,s),[i.idTensor]}case"TensorListGetItem":{let r=CT("tensorListId",e,t,n),a=CT("index",e,t,n),s=CT("elementShape",e,t,n),i=CT("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(a,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=CT("indices",e,t,n),a=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let a=Math.max(...t);if(null!=r&&-1!==r&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);let s=new V_([],n,e.dtype,r),i=Jd(e,0);return t.forEach(((e,t)=>{s.setItem(e,i[t])})),s}(CT("tensor",e,t,n),r,CT("elementShape",e,t,n),CT("numElements",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r,a=CT("elementShape",e,t,n),s=CT("elementDType",e,t,n);r="TensorListReserve"===e.op?"numElements":"maxNumElements";let i=CT(r,e,t,n),o=function(e,t,n,r){return new V_([],e,t,r)}(a,s,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{let r=CT("tensorListId",e,t,n),a=CT("indices",e,t,n),s=CT("elementShape",e,t,n),i=CT("elementDType",e,t,n);return[n.getTensorList(r.id).gather(a,i,s)]}case"TensorListStack":{let r=CT("tensorListId",e,t,n),a=CT("elementShape",e,t,n),s=CT("elementDType",e,t,n),i=CT("numElements",e,t,n);return[n.getTensorList(r.id).stack(a,s,i)]}case"TensorListFromTensor":{let r=function(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);L_(e.shape.slice(1),t,"TensorList shape mismatch: ");let a=Jd(e);return new V_(a,t,r)}(CT("tensor",e,t,n),CT("elementShape",e,t,n),CT("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=CT("tensorListId",e,t,n),a=n.getTensorList(r.id),s=CT("dtype",e,t,n),i=CT("elementShape",e,t,n);return[a.concat(s,i)]}case"TensorListPushBack":{let r=CT("tensorListId",e,t,n),a=CT("tensor",e,t,n),s=n.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{let r=CT("tensorListId",e,t,n),a=CT("elementShape",e,t,n),s=CT("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(a,s)]}case"TensorListSplit":{let r=CT("tensor",e,t,n),a=CT("elementShape",e,t,n),s=function(e,t,n){let r=0,a=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);let s=B_(e.shape.slice(1),n),i=0===r?0:e.size/r,o=ri((()=>{let n=[];e=Zo(e,[1,r,i]);for(let r=0;r<t.length;++r){let o=[0,0===r?0:a[r-1],0],l=[1,t[r],i];n[r]=Zo(rl(e,o,l),s)}return e.dispose(),n})),l=new V_([],n,e.dtype,t.length);for(let e=0;e<o.length;e++)l.setItem(e,o[e]);return l}(r,CT("lengths",e,t,n),a);return n.addTensorList(s),[s.idTensor]}case"TensorListLength":{let r=CT("tensorListId",e,t,n);return[uu(n.getTensorList(r.id).size(),"int32")]}case"TensorListResize":{let r=CT("tensorListId",e,t,n),a=CT("size",e,t,n),s=n.getTensorList(r.id).resize(a);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function G_(e,t,n){let[r,a]=CT("fusedOps",e,t,n),s="biasadd"===r,i=!s,o="prelu"===a,l="fusedbatchnorm"===r,u=CT("numArgs",e,t,n);if(s){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let p=CT("strides",e,t,n),d=DT(e,t,n),h=CT("dataFormat",e,t,n).toUpperCase(),c=CT("dilations",e,t,n),[f,m]=CT("args",e,t,n);return i&&(m=f,f=void 0),{stride:p,pad:d,dataFormat:h,dilations:c,biasArg:f,preluArg:m,activationFunc:a,leakyreluAlpha:CT("leakyreluAlpha",e,t,n)}}function H_(e,t,n){return{boxes:CT("boxes",e,t,n),scores:CT("scores",e,t,n),maxOutputSize:CT("maxOutputSize",e,t,n),iouThreshold:CT("iouThreshold",e,t,n),scoreThreshold:CT("scoreThreshold",e,t,n),softNmsSigma:CT("softNmsSigma",e,t,n)}}var j_=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=uu(0),this.tensorMap=new Map,si(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return uu(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),ri((()=>{let e=Jd(t),r=n.length,a=e.length;ka.assert(r===a,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${a} elements.`));for(let t=0;t<r;t++){let r=n[t],a=e[t];si(a),this.tensorMap.set(r,a)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return ri((()=>{let e=[];for(let r=0;r<n.length;r++){let a=n[r],s=this.findWithDefault(a,t);e.push(s)}return Rd(e)}))}findWithDefault(e,t){let n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}};function q_(e,t,n,r,a=ri){let s=((e,t,n)=>{switch(e.category){case"arithmetic":return a((()=>((e,t,n,r=O_)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(CT("a",e,t,n),CT("b",e,t,n))];case"AddN":return[r.addN(CT("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(CT("a",e,t,n),CT("b",e,t,n))];case"Mul":return[r.mul(CT("a",e,t,n),CT("b",e,t,n))];case"RealDiv":case"Div":return[r.div(CT("a",e,t,n),CT("b",e,t,n))];case"DivNoNan":return[r.divNoNan(CT("a",e,t,n),CT("b",e,t,n))];case"FloorDiv":return[r.floorDiv(CT("a",e,t,n),CT("b",e,t,n))];case"Sub":return[r.sub(CT("a",e,t,n),CT("b",e,t,n))];case"Minimum":return[r.minimum(CT("a",e,t,n),CT("b",e,t,n))];case"Maximum":return[r.maximum(CT("a",e,t,n),CT("b",e,t,n))];case"Pow":return[r.pow(CT("a",e,t,n),CT("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(CT("a",e,t,n),CT("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"basic_math":return a((()=>((e,t,n,r=O_)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(CT("x",e,t,n))];case"Acos":return[r.acos(CT("x",e,t,n))];case"Acosh":return[r.acosh(CT("x",e,t,n))];case"Asin":return[r.asin(CT("x",e,t,n))];case"Asinh":return[r.asinh(CT("x",e,t,n))];case"Atan":return[r.atan(CT("x",e,t,n))];case"Atan2":return[r.atan2(CT("x",e,t,n),CT("y",e,t,n))];case"Atanh":return[r.atanh(CT("x",e,t,n))];case"Ceil":return[r.ceil(CT("x",e,t,n))];case"Complex":return[r.complex(CT("real",e,t,n),CT("imag",e,t,n))];case"Cos":return[r.cos(CT("x",e,t,n))];case"Cosh":return[r.cosh(CT("x",e,t,n))];case"Elu":return[r.elu(CT("x",e,t,n))];case"Erf":return[r.erf(CT("x",e,t,n))];case"Exp":return[r.exp(CT("x",e,t,n))];case"Expm1":return[r.expm1(CT("x",e,t,n))];case"Floor":return[r.floor(CT("x",e,t,n))];case"Log":return[r.log(CT("x",e,t,n))];case"Log1p":return[r.log1p(CT("x",e,t,n))];case"Imag":return[r.imag(CT("x",e,t,n))];case"Neg":return[r.neg(CT("x",e,t,n))];case"Reciprocal":return[r.reciprocal(CT("x",e,t,n))];case"Real":return[r.real(CT("x",e,t,n))];case"Relu":return[r.relu(CT("x",e,t,n))];case"Round":return[r.round(CT("x",e,t,n))];case"Selu":return[r.selu(CT("x",e,t,n))];case"Sigmoid":return[r.sigmoid(CT("x",e,t,n))];case"Sin":return[r.sin(CT("x",e,t,n))];case"Sign":return[r.sign(CT("x",e,t,n))];case"Sinh":return[r.sinh(CT("x",e,t,n))];case"Softplus":return[r.softplus(CT("x",e,t,n))];case"Sqrt":return[r.sqrt(CT("x",e,t,n))];case"Square":return[r.square(CT("x",e,t,n))];case"Tanh":return[r.tanh(CT("x",e,t,n))];case"Tan":return[r.tan(CT("x",e,t,n))];case"ClipByValue":return[r.clipByValue(CT("x",e,t,n),CT("clipValueMin",e,t,n),CT("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(CT("x",e,t,n))];case"Rsqrt":return[r.rsqrt(ET(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(CT("x",e,t,n),CT("alpha",e,t,n))];case"Prelu":return[r.prelu(CT("x",e,t,n),CT("alpha",e,t,n))];case"IsNan":return[r.isNaN(ET(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(ET(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(ET(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"control":return U_(e,t,n);case"convolution":return a((()=>((e,t,n,r=O_)=>{switch(e.op){case"Conv1D":{let a=CT("stride",e,t,n),s=CT("pad",e,t,n),i=CT("dataFormat",e,t,n).toUpperCase(),o=CT("dilation",e,t,n);return[r.conv1d(CT("x",e,t,n),CT("filter",e,t,n),a,s,i,o)]}case"Conv2D":{let a=CT("strides",e,t,n),s=DT(e,t,n),i=CT("dataFormat",e,t,n).toUpperCase(),o=CT("dilations",e,t,n);return[r.conv2d(CT("x",e,t,n),CT("filter",e,t,n),[a[1],a[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:p,leakyreluAlpha:d}=G_(e,t,n);return[r.fused.conv2d({x:CT("x",e,t,n),filter:CT("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:p,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:p,leakyreluAlpha:d}=G_(e,t,n);return[r.fused.depthwiseConv2d({x:CT("x",e,t,n),filter:CT("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:p,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let a=CT("outputShape",e,t,n),s=CT("strides",e,t,n),i=DT(e,t,n);return[r.conv2dTranspose(CT("x",e,t,n),CT("filter",e,t,n),a,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let a=CT("strides",e,t,n),s=DT(e,t,n),i=CT("dilations",e,t,n),o=CT("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(CT("input",e,t,n),CT("filter",e,t,n),[a[1],a[2]],s,o,[i[1],i[2]])]}case"Conv3D":{let a=CT("strides",e,t,n),s=CT("pad",e,t,n),i=CT("dataFormat",e,t,n).toUpperCase(),o=CT("dilations",e,t,n);return[r.conv3d(CT("x",e,t,n),CT("filter",e,t,n),[a[1],a[2],a[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{let a=CT("strides",e,t,n),s=CT("pad",e,t,n),i=CT("kernelSize",e,t,n);return[r.avgPool(CT("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPool":{let a=CT("strides",e,t,n),s=CT("pad",e,t,n),i=CT("kernelSize",e,t,n);return[r.maxPool(CT("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{let a=CT("strides",e,t,n),s=CT("pad",e,t,n),i=CT("kernelSize",e,t,n),o=CT("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(CT("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s,o);return[l,u]}case"AvgPool3D":{let a=CT("strides",e,t,n),s=CT("pad",e,t,n),i=CT("kernelSize",e,t,n);return[r.avgPool3d(CT("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{let a=CT("strides",e,t,n),s=CT("pad",e,t,n),i=CT("kernelSize",e,t,n);return[r.maxPool3d(CT("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{let a=CT("strides",e,t,n),s=CT("pad",e,t,n),i=CT("dilations",e,t,n),o=a[1],l=a[2],u=i[1],p=i[2];return[r.dilation2d(CT("x",e,t,n),CT("filter",e,t,n),[o,l],s,[u,p],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"creation":return a((()=>((e,t,n,r=O_)=>{switch(e.op){case"Fill":{let a=CT("shape",e,t,n),s=CT("dtype",e,t,n),i=CT("value",e,t,n);return[r.fill(a,i,s)]}case"LinSpace":{let a=CT("start",e,t,n),s=CT("stop",e,t,n),i=CT("num",e,t,n);return[r.linspace(a,s,i)]}case"Multinomial":{let a=CT("logits",e,t,n),s=CT("numSamples",e,t,n),i=CT("seed",e,t,n);return[r.multinomial(a,s,i)]}case"OneHot":{let a=CT("indices",e,t,n),s=CT("depth",e,t,n),i=CT("onValue",e,t,n),o=CT("offValue",e,t,n),l=CT("dtype",e,t,n);return[r.oneHot(a,s,i,o,l)]}case"Ones":return[r.ones(CT("shape",e,t,n),CT("dtype",e,t,n))];case"OnesLike":return[r.onesLike(CT("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(CT("shape",e,t,n),CT("dtype",e,t,n),CT("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(CT("shape",e,t,n),CT("minval",e,t,n),CT("maxval",e,t,n),CT("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(CT("shape",e,t,n),CT("minval",e,t,n),CT("maxval",e,t,n),CT("seed",e,t,n))];case"Range":{let a=CT("start",e,t,n),s=CT("stop",e,t,n),i=CT("step",e,t,n);return[r.range(a,s,i,CT("dtype",e,t,n))]}case"TruncatedNormal":{let a=CT("shape",e,t,n),s=CT("mean",e,t,n),i=CT("stdDev",e,t,n),o=CT("seed",e,t,n);return[r.truncatedNormal(a,s,i,CT("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(CT("shape",e,t,n),CT("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(CT("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"dynamic":return(async(e,t,n,r,a=O_)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=H_(e,t,n),p=await a.image.nonMaxSuppressionWithScoreAsync(r,s,i,o,l,u);return[p.selectedIndices,p.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=H_(e,t,n),u=CT("padToMaxOutputSize",e,t,n),p=await a.image.nonMaxSuppressionPaddedAsync(r,s,i,o,l,u);return[p.selectedIndices,p.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=H_(e,t,n);return[await a.image.nonMaxSuppressionAsync(r,s,i,o,l)]}case"Where":{let r=a.cast(CT("condition",e,t,n),"bool"),s=[await a.whereAsync(r)];return r.dispose(),s}case"ListDiff":return a.setdiff1dAsync(CT("x",e,t,n),CT("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n);case"evaluation":return a((()=>((e,t,n,r=O_)=>{switch(e.op){case"LowerBound":{let a=CT("sortedSequence",e,t,n),s=CT("values",e,t,n);return[r.lowerBound(a,s)]}case"TopKV2":{let a=CT("x",e,t,n),s=CT("k",e,t,n),i=CT("sorted",e,t,n),o=r.topk(a,s,i);return[o.values,o.indices]}case"UpperBound":{let a=CT("sortedSequence",e,t,n),s=CT("values",e,t,n);return[r.upperBound(a,s)]}case"Unique":{let a=CT("x",e,t,n),s=r.unique(a);return[s.values,s.indices]}case"UniqueV2":{let a=CT("x",e,t,n),s=CT("axis",e,t,n),i=r.unique(a,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"image":return a((()=>((e,t,n,r=O_)=>{switch(e.op){case"ResizeBilinear":{let a=CT("images",e,t,n),s=CT("size",e,t,n),i=CT("alignCorners",e,t,n),o=CT("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{let a=CT("images",e,t,n),s=CT("size",e,t,n),i=CT("alignCorners",e,t,n),o=CT("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[s[0],s[1]],i,o)]}case"CropAndResize":{let a=CT("image",e,t,n),s=CT("boxes",e,t,n),i=CT("boxInd",e,t,n),o=CT("cropSize",e,t,n),l=CT("method",e,t,n),u=CT("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,s,i,o,l,u)]}case"ImageProjectiveTransformV3":{let a=CT("images",e,t,n),s=CT("transforms",e,t,n),i=CT("outputShape",e,t,n),o=CT("fillValue",e,t,n),l=CT("interpolation",e,t,n),u=CT("fillMode",e,t,n);return[r.image.transform(a,s,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"graph":return a((()=>((e,t,n,r=O_)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let a=CT("default",e,t,n);return[ET(e.name,t,n)||a];case"Placeholder":return[ET(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[MT(CT("x",e,t,n))];case"IdentityN":return CT("x",e,t,n).map((e=>MT(e)));case"Shape":return[r.tensor1d(CT("x",e,t,n).shape,"int32")];case"ShapeN":return CT("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(CT("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(CT("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let s=CT("x",e,t,n),i=CT("data",e,t,n),o=CT("message",e,t,n),l=CT("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,l));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"logical":return a((()=>((e,t,n,r=O_)=>{switch(e.op){case"Equal":return[r.equal(CT("a",e,t,n),CT("b",e,t,n))];case"NotEqual":return[r.notEqual(CT("a",e,t,n),CT("b",e,t,n))];case"Greater":return[r.greater(CT("a",e,t,n),CT("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(CT("a",e,t,n),CT("b",e,t,n))];case"Less":return[r.less(CT("a",e,t,n),CT("b",e,t,n))];case"LessEqual":return[r.lessEqual(CT("a",e,t,n),CT("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(CT("a",e,t,n),CT("b",e,t,n))];case"LogicalNot":return[r.logicalNot(CT("a",e,t,n))];case"LogicalOr":return[r.logicalOr(CT("a",e,t,n),CT("b",e,t,n))];case"Select":case"SelectV2":return[r.where(CT("condition",e,t,n),CT("a",e,t,n),CT("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(CT("a",e,t,n),CT("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"matrices":return a((()=>((e,t,n,r=O_)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(CT("a",e,t,n),CT("b",e,t,n),CT("transposeA",e,t,n),CT("transposeB",e,t,n))];case"Einsum":return[r.einsum(CT("equation",e,t,n),...CT("tensors",e,t,n))];case"Transpose":return[r.transpose(CT("x",e,t,n),CT("perm",e,t,n))];case"_FusedMatMul":let[a,s]=CT("fusedOps",e,t,n),i="biasadd"===a,o="prelu"===s,l=CT("numArgs",e,t,n),u=CT("leakyreluAlpha",e,t,n);if(i){if(o&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[p,d]=CT("args",e,t,n);return[r.fused.matMul({a:CT("a",e,t,n),b:CT("b",e,t,n),transposeA:CT("transposeA",e,t,n),transposeB:CT("transposeB",e,t,n),bias:p,activation:s,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(CT("a",e,t,n),CT("numLower",e,t,n),CT("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"normalization":return a((()=>((e,t,n,r=O_)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(CT("x",e,t,n),CT("axis",e,t,n),CT("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(CT("x",e,t,n),CT("mean",e,t,n),CT("variance",e,t,n),CT("offset",e,t,n),CT("scale",e,t,n),CT("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(CT("x",e,t,n),CT("radius",e,t,n),CT("bias",e,t,n),CT("alpha",e,t,n),CT("beta",e,t,n))];case"Softmax":return[r.softmax(CT("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(CT("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"ragged":return a((()=>((e,t,n,r=O_)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:a,outputDenseValues:s}=r.raggedGather(CT("paramsNestedSplits",e,t,n),CT("paramsDenseValues",e,t,n),CT("indices",e,t,n),CT("outputRaggedRank",e,t,n));return a.concat(s)}case"RaggedRange":{let{rtNestedSplits:a,rtDenseValues:s}=r.raggedRange(CT("starts",e,t,n),CT("limits",e,t,n),CT("splits",e,t,n));return[a,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(CT("shape",e,t,n),CT("values",e,t,n),CT("defaultValue",e,t,n),CT("rowPartitionTensors",e,t,n),CT("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"reduction":return a((()=>((e,t,n,r=O_)=>{switch(e.op){case"Max":{let a=CT("axis",e,t,n),s=CT("keepDims",e,t,n);return[r.max(CT("x",e,t,n),a,s)]}case"Mean":{let a=CT("axis",e,t,n),s=CT("keepDims",e,t,n);return[r.mean(CT("x",e,t,n),a,s)]}case"Min":{let a=CT("axis",e,t,n),s=CT("keepDims",e,t,n);return[r.min(CT("x",e,t,n),a,s)]}case"Sum":{let a=CT("axis",e,t,n),s=CT("keepDims",e,t,n);return[r.sum(CT("x",e,t,n),a,s)]}case"All":{let a=CT("axis",e,t,n),s=CT("keepDims",e,t,n);return[r.all(CT("x",e,t,n),a,s)]}case"Any":{let a=CT("axis",e,t,n),s=CT("keepDims",e,t,n);return[r.any(CT("x",e,t,n),a,s)]}case"ArgMax":{let a=CT("axis",e,t,n);return[r.argMax(CT("x",e,t,n),a)]}case"ArgMin":{let a=CT("axis",e,t,n);return[r.argMin(CT("x",e,t,n),a)]}case"Prod":{let a=CT("axis",e,t,n),s=CT("keepDims",e,t,n);return[r.prod(CT("x",e,t,n),a,s)]}case"Cumprod":{let a=CT("axis",e,t,n),s=CT("exclusive",e,t,n),i=CT("reverse",e,t,n);return[r.cumprod(CT("x",e,t,n),a,s,i)]}case"Cumsum":{let a=CT("axis",e,t,n),s=CT("exclusive",e,t,n),i=CT("reverse",e,t,n);return[r.cumsum(CT("x",e,t,n),a,s,i)]}case"Bincount":let a=CT("x",e,t,n),s=CT("weights",e,t,n),i=CT("size",e,t,n);return[r.bincount(a,s,i)];case"DenseBincount":{let a=CT("x",e,t,n),s=CT("weights",e,t,n),i=CT("size",e,t,n),o=CT("binaryOutput",e,t,n);return[r.denseBincount(a,s,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"slice_join":return a((()=>((e,t,n,r=O_)=>{switch(e.op){case"ConcatV2":case"Concat":{let a=CT("n",e,t,n),s=CT("axis",e,t,n),i=CT("tensors",e,t,n);return i=i.slice(0,a),[r.concat(i,s)]}case"Gather":{let a=CT("x",e,t,n),s=CT("indices",e,t,n);return[r.gather(a,r.cast(s,"int32"),0)]}case"GatherV2":{let a=CT("axis",e,t,n),s=CT("batchDims",e,t,n),i=CT("x",e,t,n),o=CT("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),a,s)]}case"Reverse":{let a=CT("dims",e,t,n),s=[];for(let e=0;e<a.length;e++)a[e]&&s.push(e);let i=CT("x",e,t,n);return[r.reverse(i,s)]}case"ReverseV2":{let a=CT("axis",e,t,n),s=CT("x",e,t,n);return[r.reverse(s,a)]}case"Slice":{let a=CT("begin",e,t,n),s=CT("size",e,t,n);return[r.slice(CT("x",e,t,n),a,s)]}case"StridedSlice":{let a=CT("begin",e,t,n),s=CT("end",e,t,n),i=CT("strides",e,t,n),o=CT("beginMask",e,t,n),l=CT("endMask",e,t,n),u=CT("ellipsisMask",e,t,n),p=CT("newAxisMask",e,t,n),d=CT("shrinkAxisMask",e,t,n),h=CT("x",e,t,n);return[r.stridedSlice(h,a,s,i,o,l,u,p,d)]}case"Pack":return ri((()=>{let a=CT("axis",e,t,n),s=CT("tensors",e,t,n),i=s[0].shape,o=r.squeeze(s[0]).shape,l=s.map((e=>{let t=ka.arraysEqual(e.shape,i);if(!t&&!ka.arraysEqual(r.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,i)}));return[r.stack(l,a)]}));case"Unpack":{let a=CT("axis",e,t,n),s=CT("tensor",e,t,n);return r.unstack(s,a)}case"Tile":{let a=CT("reps",e,t,n);return[r.tile(CT("x",e,t,n),a)]}case"Split":case"SplitV":{let a=CT("axis",e,t,n),s=CT("numOrSizeSplits",e,t,n),i=CT("x",e,t,n);return r.split(i,s,a)}case"ScatterNd":{let a=CT("indices",e,t,n),s=CT("values",e,t,n),i=CT("shape",e,t,n);return[r.scatterND(a,s,i)]}case"GatherNd":{let a=CT("x",e,t,n),s=CT("indices",e,t,n);return[r.gatherND(a,s)]}case"SparseToDense":{let a=CT("sparseIndices",e,t,n),s=CT("outputShape",e,t,n),i=CT("sparseValues",e,t,n),o=CT("defaultValue",e,t,n);return[r.sparseToDense(a,i,s,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{let a=CT("indices",e,t,n),s=CT("values",e,t,n),i=CT("tensor",e,t,n);return[r.tensorScatterUpdate(i,a,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"sparse":return a((()=>((e,t,n,r=O_)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:a,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(CT("indices",e,t,n),CT("values",e,t,n),CT("denseShape",e,t,n),CT("defaultValue",e,t,n));return[a,s,i,o]}case"SparseReshape":{let{outputIndices:a,outputShape:s}=r.sparse.sparseReshape(CT("inputIndices",e,t,n),CT("inputShape",e,t,n),CT("newShape",e,t,n));return[a,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(CT("data",e,t,n),CT("indices",e,t,n),CT("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(CT("data",e,t,n),CT("indices",e,t,n),CT("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"spectral":return a((()=>((e,t,n,r=O_)=>{switch(e.op){case"FFT":return[r.fft(CT("x",e,t,n))];case"IFFT":return[r.ifft(CT("x",e,t,n))];case"RFFT":return[r.rfft(CT("x",e,t,n))];case"IRFFT":return[r.irfft(CT("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"string":return a((()=>((e,t,n,r=O_)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(CT("input",e,t,n),CT("pattern",e,t,n),CT("rewrite",e,t,n),CT("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:a,nGramsSplits:s}=r.string.stringNGrams(CT("data",e,t,n),CT("dataSplits",e,t,n),CT("separator",e,t,n),CT("nGramWidths",e,t,n),CT("leftPad",e,t,n),CT("rightPad",e,t,n),CT("padWidth",e,t,n),CT("preserveShortSequences",e,t,n));return[a,s]}case"StringSplit":{let{indices:a,values:s,shape:i}=r.string.stringSplit(CT("input",e,t,n),CT("delimiter",e,t,n),CT("skipEmpty",e,t,n));return[a,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(CT("input",e,t,n),CT("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"transformation":return a((()=>((e,t,n,r=O_)=>{switch(e.op){case"Cast":return[r.cast(CT("x",e,t,n),CT("dtype",e,t,n))];case"ExpandDims":{let a=CT("axis",e,t,n);return[r.expandDims(CT("x",e,t,n),a)]}case"Squeeze":{let a=CT("axis",e,t,n);return[r.squeeze(CT("x",e,t,n),a)]}case"Reshape":return[r.reshape(CT("x",e,t,n),CT("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(CT("x",e,t,n),CT("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(CT("x",e,t,n),CT("padding",e,t,n),CT("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(CT("x",e,t,n),CT("padding",e,t,n),CT("constantValue",e,t,n))];case"SpaceToBatchND":{let a=CT("blockShape",e,t,n),s=CT("paddings",e,t,n);return[r.spaceToBatchND(CT("x",e,t,n),a,s)]}case"BatchToSpaceND":{let a=CT("blockShape",e,t,n),s=CT("crops",e,t,n);return[r.batchToSpaceND(CT("x",e,t,n),a,s)]}case"DepthToSpace":{let a=CT("blockSize",e,t,n),s=CT("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(CT("x",e,t,n),a,s)]}case"BroadcastTo":return[r.broadcastTo(CT("x",e,t,n),CT("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(CT("s0",e,t,n),CT("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let a=r.getHashTableHandleByName(e.name);if(null!=a)return[a];{let a=CT("keyDType",e,t,n),s=CT("valueDType",e,t,n),i=new j_(a,s);return r.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let a=CT("tableHandle",e,t,n,r),s=CT("keys",e,t,n),i=CT("values",e,t,n);return[await r.getHashTableById(a.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let a=CT("tableHandle",e,t,n,r),s=CT("keys",e,t,n),i=CT("defaultValue",e,t,n);return[await r.getHashTableById(a.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let a=CT("tableHandle",e,t,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,r);case"custom":let s=TT(e.op);if(s&&s.customExecutor)return s.customExecutor(new M_(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return ka.isPromise(s)?s.then((e=>[].concat(e))):[].concat(s)}var K_=class{constructor(e={},t={},n={},r={},a){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function X_(e,t,n,r){let a=new Set,s=[],i=null,o=null,l=new Set,u=new Set(Object.keys(e).map((e=>RT(e)[0])));r=r||[];let p=new Set(r.map((e=>RT(e.name)[0]))),d=[...t];for(;d.length>0;){let e=d.pop();if((tC(e)||nC(e)||rC(e))&&null==i&&(i=e,o=i.children.map((e=>e.name)).filter((e=>a.has(e)))),a.add(e.name),null==n[e.name]&&!u.has(e.name)&&!p.has(e.name)){if(0===e.inputs.length){s.push(e.name);continue}e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),d.push(e))}))}}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:i,syncInputs:o}}function Y_(e,t){let{usedNodes:n,inputs:r}=t,a=Object.keys(r).map((e=>RT(e)[0])).map((t=>e.nodes[t])),s=e.initNodes||[],i=e=>n.has("string"==typeof e?e:e.name);function o(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}let l=o([...a,...e.weights,...s]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),p=new Map(u.map((e=>[e.name,e]))),d={};for(let e of u){d[e.name]=d[e.name]||0;for(let t of e.children)i(t)||(d[t.name]=Number.POSITIVE_INFINITY),d[t.name]=(d[t.name]||0)+1}let h=Object.entries(d).filter((([,e])=>0===e)).map((([e])=>e)),c=[...h];for(;h.length>0;){let e=h.pop(),t=p.get(e);for(let e of t.children.filter(i))0==--d[e.name]&&(c.push(e.name),h.push(e.name))}let f=function(e,t){let n=new Map(e.map((e=>[e.name,e]))),r=t.map((e=>e.name)),a=new Set(r);for(;r.length>0;){let e=r.pop(),t=n.get(e);for(let e of t.children)!n.has(e.name)||a.has(e.name)||(a.add(e.name),r.push(e.name))}return e.filter((e=>a.has(e.name)))}(c.map((e=>p.get(e))),l);return function(e,t){let n=new Map(e.map(((e,t)=>[e.name,t]))),r=new Set(t.map((e=>e.name))),a=e=>r.has("string"==typeof e?e:e.name),s=new Set(e.map((e=>e.name))),i=e=>s.has("string"==typeof e?e:e.name);for(let t of e){for(let e of t.children.filter(i)){if(!n.has(e.name))throw new Z_(`Child ${e.name} of node ${t.name} is unreachable.`);if(n.get(t.name)>n.get(e.name))throw new Z_(`Node ${t.name} is scheduled to run after its child ${e.name}.`)}if(!a(t))for(let e of t.inputs){if(!n.has(e.name))throw new Z_(`Input ${e.name} of node ${t.name} is unreachable.`);if(n.get(e.name)>n.get(t.name))throw new Z_(`Node ${t.name} is scheduled to run before its input ${e.name}.`)}}}(f,l),f}var Z_=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};var J_=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Q_=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),eC=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function tC(e){return J_.has(e.op)}function nC(e){return Q_.has(e.op)}function rC(e){return eC.has(e.op)}var aC=class e{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach((n=>{this._functionExecutorMap[n]=new e(t.functions[n],this)}))}getCompilationKey(e,t){let n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){let n=X_(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:s}=n;if(null!=a)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(r.length>0){let n=t.map((e=>e.name)),a=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${a}]. Missing the following inputs: [${r}]`)}let i=Y_(this.graph,n),o=function(e){let t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,r=e.map(((e,t)=>tC(e)?n:t)),a=e=>{let n=r[t.get(e.name)];return null==n?-1:n},s=e.map(((e,t)=>e.children.map(a).reduce(((e,t)=>Math.max(e,t)),r[t]))),i=new Map;for(let t=0;t<e.length;++t){let r=s[t];if(r===n)continue;let a=e[t],o=e[r];i.has(o.name)||i.set(o.name,[]),i.get(o.name).push(a)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;let t=e.clone();return si(t),t}cloneTensorList(e){return e?e.map((e=>this.cloneAndKeepTensor(e))):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((([e,t])=>[e,this.cloneTensorList(t)])))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let r=n.map((e=>this.graph.nodes[RT(e)[0]])),a=t.map((e=>RT(e)[0])),s=new Set(a),i=a.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);let o=this.getCompilationKey(r,i),l=this.compiledMap.get(o);null==l&&(l=this.compile(e,i),this.compiledMap.set(o,l));try{this.keepIntermediateTensors=Pe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){this.keepIntermediateTensors=!1,console.warn(e.message)}let u={},p={};return ri((()=>{let n=new K_(this.weightMap,u,p,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{let[a,s]=RT(t,n),i=[];i[s]=e[t],r[a]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[a]=this.cloneTensorList(i))}));let a=this.getFrozenTensorIds(r),{orderedNodes:i,nodeLiveUntilMap:o}=l;for(let e of i){if(r[e.name])continue;let t=q_(e,r,n,this._resourceManager);if(ka.isPromise(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,a,s,o.get(e.name))}return null==this.parent&&n.dispose(a),t.map((e=>ET(e,r,n)))}))}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,a,s,i){if(!tC(t)&&!s.has(e)){for(let r of n[e])null!=r&&(i[r.id]=(i[r.id]||0)+t.children.length);for(let e of t.inputs){if(tC(e))continue;let t=$T(e.name,n,r);if(null!=t)for(let e of t){if(!e||e.kept||a.has(e.id))continue;let t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,a,s){function i(e){return tC(e)||a.has(e.name)}if(!tC(e)&&null!=s)for(let e of s){if(i(e))continue;let a=$T(e.name,t,n);for(let e of a)!e||e.kept||r.has(e.id)||e.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,r={},a={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=Pe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){this.keepIntermediateTensors=!1,console.warn(e.message)}let s=new K_(this.weightMap,r,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let i=await this.executeWithControlFlow(e,s,t,n),o=t.map((e=>ET(e,i,s))),l=o.map((e=>e.id)),u=Object.keys(e).map((t=>e[t].id)),p=new Set([...l,...u,...this.weightIds]);return Object.values(i).forEach((e=>{e.forEach((e=>{e&&!e.isDisposed&&!p.has(e.id)&&e.dispose()}))})),null==this.parent&&s.dispose(p),o}async executeFunctionAsync(e,t,n){let r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){let a=Object.keys(e),s=a.map((e=>this.graph.nodes[RT(e)[0]])),i=n.map((e=>RT(e)[0])),o=new Set(i),l=i.map((e=>this.graph.nodes[e]));0===l.length&&(l=this._outputs);let{usedNodes:u,missingInputs:p,dynamicNode:d,syncInputs:h}=X_(e,l,this.weightMap,this._initNodes),c=[...s,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{let[n,r]=RT(t),a=[];a[r]=e[t],f[n]=a}));let m={},g=this.getFrozenTensorIds(f),y={};for(;c.length>0;){let e=this.processStack(s,c,t,f,y,g,o,m,u);await Promise.all(e)}null==d&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let b=l.filter((e=>!tC(e)&&!ET(e.name,f,t))).map((e=>e.name));if(b.length>0){let e="";throw null!=d&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${a}]. Consider providing the following inputs: [${p}]. ${e}`)}return f}processStack(e,t,n,r,a,s,i,o,l){let u=[];for(;t.length>0;){let e=t.pop();n.currentContext=e.contexts;let p="";if("Enter"===e.node.op&&CT("isConstant",e.node,r,n)&&([p]=AT(e.node.name,n)),null==r[e.node.name]){let d=q_(e.node,r,n,this._resourceManager);p||([p]=AT(e.node.name,n));let h=n.currentContext;ka.isPromise(d)?u.push(d.then((u=>(r[p]=u,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(u)),n.currentContext=h,this.checkTensorForDisposal(p,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l),u)))):(r[p]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(d)),this.checkTensorForDisposal(p,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l))}else this.processChildNodes(e.node,t,n,r,a,l)}return u}processChildNodes(e,t,n,r,a,s){e.children.forEach((e=>{let[i]=AT(e.name,n);a[i]||!s.has(e.name)||("Merge"===e.op?e.inputNames.some((e=>!!ET(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!ET(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{let n=e[t],[r]=RT(t),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){let e=a.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t));ka.assert(t,(()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}a.attrParams.dtype&&a.attrParams.dtype.value&&ka.assert(n.dtype===a.attrParams.dtype.value,(()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){var t,n;let r={};for(let a in e){let s=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[a];null!=s?r[s.name]=e[a]:r[a]=e[a]}return r}checkInputs(e){let t=Object.keys(e).filter((e=>{let[t]=RT(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{var t,n;let r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e}),{})}checkOutputs(e){e.forEach((e=>{let[t]=RT(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}},sC=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},iC="?tfjs-format=file",oC="model.json",lC=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=Gc){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new sC}findIOHandler(){let e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return ka.isPromise(e)?e.then((e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e))):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");let t=await Ii(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){let e=this.artifacts.userDefinedMetadata;null!=e.signature&&(r=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new aC(w_.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){let t=w_.Instance.transformGraph(e.modelInitializer);this.initializer=new aC(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"==typeof e){let t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t={};return(e instanceof is?[e]:e).forEach(((e,n)=>t[this.structuredOutputKeys[n]]=e)),t}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof is||Array.isArray(e))){let n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(let t in n){let r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce(((t,n)=>{var a,s,i;let o=null===(i=null===(s=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===s?void 0:s[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[r++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){let a=t[n[r]];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&ai(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function uC(e,t={},n=Gc){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&(e=function(e){return e.endsWith("/")||(e+="/"),`${e}${oC}${iC}`}(e));let r=new lC(e,t,n);return await r.load(),r}function pC(e){if(null==e)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[n,r]=e;if(!n)throw new Error("modelJSON must be the first element of the array");if(!(r&&r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in n))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in n))throw new Error("Model JSON is missing 'weightsManifest'");let a=Gc.getWeightSpecs(n.weightsManifest),s=Gc.getModelArtifactsForJSONSync(n,a,r);t=Gc.fromMemorySync(s)}else if("load"in e)t=e;else{if(!("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e))throw new Error("Unknown model format");t=Gc.fromMemorySync(e)}let n=new lC(t);return n.load(),n}var dC="4.22.0",hC={};g(hC,{CSVDataset:()=>aE,Dataset:()=>HC,FileDataSource:()=>yE,TextLineDataset:()=>ZC,URLDataSource:()=>bE,array:()=>qC,csv:()=>xE,func:()=>wE,generator:()=>vE,microphone:()=>IE,version_data:()=>SE,webcam:()=>kE,zip:()=>KC});var cC=y(E()),fC=y(E());function mC(e,t,n=new Map,r=new Set){if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(wC(e)){let a=Array.isArray(e)?[]:{};r.add(e);for(let s in e){let i=mC(e[s],t,n,r);a[s]=i}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,a.value),a.value}function gC(e,t=bC){return yC(e,t)}function yC(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(wC(r)){let a=Array.isArray(r)?[]:{};n.add(r);for(let s in r){let r=yC(e.map((e=>e[s])),t,n);a[s]=r}return n.delete(r),a}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return a.value}function bC(e){return null===e?null:wC(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function xC(e,t){let n=new Map;mC(e,t,n);for(let e of Array.from(n.keys())){let t=n.get(e);if(ka.isPromise(t)){let r=await t;n.set(e,r)}}return mC(e,t,n)}function wC(e){let t=!1;if(Pe().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=$();t=e instanceof n}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof is)&&!(e instanceof Promise)&&!t)}function vC(e){return function(e,t){return mC(e,t)}(e,kC)}function kC(e){return e instanceof is?{value:e.clone(),recurse:!1}:wC(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var IC=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},SC=class e extends IC{constructor(){super(e.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=2*this.capacity,t=new Array(e),n=this.length();for(let e=0;e<n;e++)t[e]=this.get(this.wrap(this.begin+e));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};function NC(e){return new EC(e)}function TC(e){return new $C(e)}SC.INITIAL_CAPACITY=32;var _C,CC=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new LC(this,e)}filter(e){return new MC(this,e)}map(e){return new OC(this,e)}mapAsync(e){return new zC(this,e)}serialMapAsync(e){return new zC(this,e).serial()}flatmap(e){return new BC(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e,t=!0){return new DC(this,e,t)}columnMajorBatch(e,t=!0,n=bC){return this.rowMajorBatch(e,t).map((e=>gC(e,n)))}concatenate(e,t){return new WC(NC([this,e]),t)}take(e){return e<0||null==e?this:new RC(this,e)}skip(e){return e<0||null==e?this:new FC(this,e)}prefetch(e){return new UC(this,e)}shuffle(e,t){return new GC(this,e,t)}serial(){return new AC(this)}},EC=class extends CC{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:vC(e),done:!1}}},$C=class extends CC{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},AC=class extends CC{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}},FC=class extends CC{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;ai(e.value)}return this.upstream.next()}},RC=class extends CC{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},DC=class extends CC{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},MC=class extends CC{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;ai(e.value)}}},OC=class extends CC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=fs.getTensorsInContainer(e.value),n=this.transform(e.value),r=fs.getTensorsInContainer(n);for(let e of t)fs.isTensorInList(e,r)||e.dispose();return{value:n,done:!1}}},LC=class extends CC{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},zC=class extends CC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=fs.getTensorsInContainer(e.value),n=await this.transform(e.value),r=fs.getTensorsInContainer(n);for(let e of t)fs.isTensorInList(e,r)||e.dispose();return{value:n,done:!1}}},PC=class extends CC{constructor(){super(),this.outputQueue=new SC,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},BC=class extends PC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=fs.getTensorsInContainer(e.value),n=this.transform(e.value),r=fs.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let e of t)fs.isTensorInList(e,r)||e.dispose();return!0}},WC=class extends CC{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){let e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}};!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(_C||(_C={}));var VC=class extends CC{constructor(e,t=_C.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;let r=await xC(this.iterators,(function(e){return e instanceof CC?{value:e.next().then((e=>(t++,e.done&&n++,e.value))),recurse:!1}:{value:null,recurse:!0}}));if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case _C.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case _C.SHORTEST:return{value:null,done:!0};case _C.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},UC=class extends CC{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new IC(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},GC=class extends UC{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=fC.alea(n||ka.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}},HC=class{constructor(){this.size=null}batch(e,t=!0){let n,r=this;return ka.assert(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),n=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),jC((async()=>(await r.iterator()).columnMajorBatch(e,t,XC)),n)}concatenate(e){let t,n=this;return t=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,jC((async()=>(await n.iterator()).concatenate(await e.iterator())),t)}filter(e){let t,n=this;return t=this.size===1/0?1/0:null,jC((async()=>(await n.iterator()).filter((t=>ri((()=>e(t)))))),t)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return jC((async()=>(await t.iterator()).map((t=>ri((()=>e(t)))))),this.size)}mapAsync(e){let t=this;return jC((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return jC((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){let t,n=this;return t=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,jC((async()=>function(e,t){return new WC(e,t)}(TC((async()=>({value:await n.iterator(),done:!1}))).take(e))),t)}skip(e){let t,n=this;return t=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,jC((async()=>(await n.iterator()).skip(e)),t)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,a=cC.alea(t||ka.now().toString());return jC((async()=>{let t=a.int32();return n&&(t+=a.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){let t,n=this;return t=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,jC((async()=>(await n.iterator()).take(e)),t)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};function jC(e,t=null){return new class extends HC{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function qC(e){return jC((async()=>NC(e)),e.length)}function KC(e){if(!wC(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return jC((async()=>function(e,t=_C.FAIL){return new VC(e,t)}(await xC(e,(e=>{if(e instanceof HC)return{value:e.iterator(),recurse:!1};if(wC(e))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")})),_C.SHORTEST)),t)}function XC(e){if(null===e)return null;return function(e){return null==e||function(e){return null===e||"object"!=typeof e&&"function"!=typeof e}(e)||Array.isArray(e)||"object"==typeof e&&e instanceof is||ka.isTypedArray(e)}(e[0])?{value:YC(e),recurse:!1}:{value:null,recurse:!0}}function YC(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof is?Rd(e):js(e)}HC.MAX_BUFFER_SIZE=1e4;var ZC=class extends HC{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map((e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e)))}},JC='"',QC=Symbol("out"),eE=Symbol("field"),tE=Symbol("quote"),nE=Symbol("quoteafterquote"),rE=Symbol("quoteinquote"),aE=class extends HC{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&ka.assert(e.length===this.fullColumnNames.length,(()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+").")),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce(((e,t)=>(e[t]=e[t]+1||1,e)),{}),n=Object.keys(t).filter((e=>t[e]>1));if(ka.assert(0===n.length,(()=>"Duplicate column names found: "+n.toString())),this.columnConfigs)for(let e of Object.keys(this.columnConfigs))if(-1===this.fullColumnNames.indexOf(e))throw new Error('The key "'+e+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new ZC(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(ka.assert(null==t.delimiter,(()=>"Delimiter should not be provided when delimWhitespace is true.")),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map((e=>this.makeDataElement(e)))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let a=0;a<this.fullColumnNames.length;a++){let s=this.fullColumnNames[a],i=this.columnConfigs?this.columnConfigs[s]:null;if(!this.configuredColumnsOnly||i){let o=t[a],l=null;if(""===o)if(i&&void 0!==i.default)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{let e=Number(o);if(isNaN(e))l=i&&"bool"===i.dtype?this.getBoolean(o):o;else if(i&&i.dtype)switch(i.dtype){case"float32":default:l=e;break;case"int32":l=Math.floor(e);break;case"bool":l=this.getBoolean(o)}else l=e}i&&i.isLabel?r[s]=l:n[s]=l}}return 0===Object.keys(r).length?n:{xs:n,ys:r}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e,t=!0){let n=[],r=0,a=e.length,s=QC;for(let t=0;t<a;t++)switch(s){case QC:switch(e.charAt(t)){case JC:r=t+1,s=tE;break;case this.delimiter:if(r=t+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),s=QC;break;default:s=eE,r=t}break;case eE:if(e.charAt(t)===this.delimiter)n.push(e.substring(r,t)),s=QC,r=t+1;break;case tE:if(e.charAt(t)===JC)s=nE;break;case nE:switch(e.charAt(t)){case this.delimiter:n.push(e.substring(r,t-1)),s=QC,r=t+1;break;case JC:s=tE;break;default:s=rE}break;case rE:if(e.charAt(t)===JC)s=tE}if(s===nE?n.push(e.substring(r,a-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},sE=class e extends CC{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!Pe().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new e(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(e){throw new Error(`Error thrown while initializing video stream: ${e.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise((r=>{let a=setInterval((()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(a),r({freqDataQueue:e,timeDataQueue:t}))}),this.fftSize/this.sampleRateHz*1e3)}))}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach(((e,r)=>n.set(e,r*t))),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(ka.sizeFromShape(t));return n.set(e,n.length-e.length),js(n,t)}},iE=class e extends CC{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Ld([0],"int32"),this.webcamConfig.centerCrop){let e=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,n=(1-e)/2,r=(1-t)/2,a=n+e,s=t+r;this.cropBox=zd([r,n,s,a],[1,4])}else this.cropBox=zd([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,n={}){if(!Pe().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let r=new e(t,n);return await r.start(),r}async start(){this.webcamConfig.facingMode&&ka.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,(()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`));try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise((e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}}))}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=ff.fromPixels(this.webcamVideoElement)}catch(e){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`)}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(e){throw new Error(`Error thrown cropping the video: ${e.message}`)}finally{e.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return ri((()=>{let t,n=yu(go(e,"float32"),0);t=Ic.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=t.shape;return Zo(t,r.slice(1))}))}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach((e=>e.stop()));try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},oE=class{},lE=class extends CC{split(e){return new uE(this,e)}},uE=class extends lE{constructor(e,t){super(),this.upstream=e,this.impl=new pE(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},pE=class extends PC{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let e of t.slice(0,-1))this.outputQueue.push(e);return this.carryover=t[t.length-1],!0}},dE=class extends CC{decodeUTF8(){return new hE(this)}},hE=class extends lE{constructor(e){super(),this.upstream=e,this.impl=new cE(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},cE=class extends PC{constructor(e){if(super(),this.upstream=e,Pe().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:e}=$();this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e,t,n=await this.upstream.next();return!n.done&&(e=n.value,t=Pe().get("IS_BROWSER")?this.decoder.decode(e,{stream:!0}):this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(t),!0)}},fE=class extends dE{constructor(e,t={}){super(),this.file=e,this.options=t,ka.assert(e instanceof Uint8Array||!!Pe().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),(()=>"FileChunkIterator only supports File, Blob and Uint8Array right now.")),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise(((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=n=>{let a=r.result;if(a instanceof ArrayBuffer&&(a=new Uint8Array(a)),!(a instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(a)},r.onabort=e=>t(new Error("Aborted")),r.onerror=e=>t(new Error(e.type));let a=this.file.slice(this.offset,n);r.readAsArrayBuffer(a)}this.offset=n})),done:!1}}};var mE=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function gE(e){return"string"==typeof e&&"file://"===e.slice(0,7)}var yE=class extends oE{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(gE(this.input)&&Pe().get("IS_NODE")){let e=A();this.input=e.readFileSync(this.input.slice(7))}return new fE(this.input,this.options)}},bE=class extends oE{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return gE(this.url)?new yE(this.url,this.fileOptions).iterator():async function(e,t={},n){let r,a;"string"==typeof e?r=e:(r=e.url,a=mE(e));let s=await(n||ka.fetch)(r,a);if(s.ok){let e=new Uint8Array(await s.arrayBuffer());return new fE(e,t)}throw new Error(s.statusText)}(this.url,this.fileOptions)}};function xE(e,t={}){return new aE(new bE(e),t)}function wE(e){let t=TC(e);return jC((async()=>t))}function vE(e){return jC((async()=>{let t=await e();return TC((()=>t.next()))}))}async function kE(e,t){return iE.create(e,t)}async function IE(e){return sE.create(e)}var SE="4.22.0";function NE(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&ka.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}var TE=ag.whereImpl,_E=class e extends B{nextDataId(){return e.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new P(this,ei())}write(e,t,n){this.firstUse&&(this.firstUse=!1,Pe().get("IS_NODE")&&Jf.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));let r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&ka.isString(n[0])){let a=n.map((e=>ka.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){let e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return Jf.mergeRealAndImagArrays(e,t)}return ka.convertBackendValuesAndArrayBuffer(this.data.get(e).values,t)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map((e=>ka.decodeString(e)));return mo(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return mo(e.shape,e.dtype,t)}makeOutput(e,t,n){return ei().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=ka.now();return e(),{kernelMs:ka.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){NE([e],"where");let t=this.readSync(e.dataId);return TE(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};_E.nextDataId=0;var CE={};function EE(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}g(CE,{addImpl:()=>GE,bincountImpl:()=>KE,bincountReduceImpl:()=>XE,bitwiseAndImpl:()=>YE,castImpl:()=>PE,ceilImpl:()=>n$,concatImpl:()=>s$,equalImpl:()=>i$,expImpl:()=>u$,expm1Impl:()=>h$,floorDivImpl:()=>b$,floorImpl:()=>m$,gatherNdImpl:()=>v$,gatherV2Impl:()=>k$,greaterEqualImpl:()=>T$,greaterImpl:()=>I$,lessEqualImpl:()=>F$,lessImpl:()=>E$,linSpaceImpl:()=>M$,logImpl:()=>O$,maxImpl:()=>P$,maximumImpl:()=>B$,minimumImpl:()=>U$,multiplyImpl:()=>j$,negImpl:()=>Y$,notEqualImpl:()=>J$,prodImpl:()=>aA,raggedGatherImpl:()=>uA,raggedRangeImpl:()=>dA,raggedTensorToTensorImpl:()=>gA,rangeImpl:()=>yA,rsqrtImpl:()=>bA,scatterImpl:()=>vA,sigmoidImpl:()=>kA,simpleAbsImpl:()=>EE,sliceImpl:()=>NA,sparseFillEmptyRowsImpl:()=>CA,sparseReshapeImpl:()=>EA,sparseSegmentReductionImpl:()=>$A,sqrtImpl:()=>AA,squaredDifferenceImpl:()=>DA,staticRegexReplaceImpl:()=>LA,stridedSliceImpl:()=>BA,stringNGramsImpl:()=>VA,stringSplitImpl:()=>GA,stringToHashBucketFastImpl:()=>HA,subImpl:()=>jA,tileImpl:()=>YA,topKImpl:()=>QA,transposeImpl:()=>tA,uniqueImpl:()=>eF});var $E={kernelName:Ge,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,n=e.backend;NE(t,"abs");let r=new Float32Array(ka.sizeFromShape(t.shape));return r=EE(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}};function AE(e){return(t,n,r,a,s)=>{let i=Jf.assertAndGetBroadcastShape(t,n),o=i.length,l=ka.computeStrides(i),u=ka.sizeFromShape(i),p=ka.getTypedArrayFromDType(s,u),d=t.length,h=n.length,c=ka.computeStrides(t),f=ka.computeStrides(n),m=Jf.getBroadcastDims(t,i),g=Jf.getBroadcastDims(n,i);if(m.length+g.length===0)for(let t=0;t<p.length;++t)p[t]=e(r[t%r.length],a[t%a.length]);else for(let t=0;t<p.length;++t){let n=ka.indexToLoc(t,o,l),s=n.slice(-d);m.forEach((e=>s[e]=0));let i=ka.locToIndex(s,d,c),u=n.slice(-h);g.forEach((e=>u[e]=0));let y=ka.locToIndex(u,h,f);p[t]=e(r[i],a[y])}return[p,i]}}function FE(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",i)},o}var RE={kernelName:yt,backendName:"cpu",kernelFunc:FE};function DE(e,t,n="float32"){if("complex64"===n){return FE({inputs:{real:DE(e,t,"float32"),imag:DE(e,t,"float32")},backend:e})}let r=ka.makeZerosTypedArray(ka.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function ME(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var OE={kernelName:on,backendName:"cpu",kernelFunc:ME};function LE(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var zE={kernelName:sr,backendName:"cpu",kernelFunc:LE};function PE(e,t,n,r){if("int32"===r){return[t,"int32",Int32Array.from(e)]}if("bool"===r){let r=ka.toTypedArray([0],n),[a,s]=AE(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[s,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function BE(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return ME({inputs:{x:a},backend:n});let e=DE(n,a.shape,a.dtype),t=BE({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=FE({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){let e=LE({inputs:{input:a},backend:n}),t=BE({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!ka.hasEncodingLoss(a.dtype,s)){let e=ME({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}let i=n.data.get(a.dataId).values,[o,l,u]=PE(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,u)}var WE={kernelName:ft,backendName:"cpu",kernelFunc:BE};function VE(e,t,n,r){return null==n?({inputs:n,backend:a})=>{let{a:s,b:i}=n,o=a;NE([s,i],e);let l=o.data.get(s.dataId).values,u=o.data.get(i.dataId).values,p="string"===s.dtype?Jf.fromUint8ToStringArray(l):l,d="string"===s.dtype?Jf.fromUint8ToStringArray(u):u,h=r||s.dtype,[c,f]=t(s.shape,i.shape,p,d,h);return o.makeTensorInfo(f,h,c)}:({inputs:e,backend:a})=>{let{a:s,b:i}=e,o=a;if("complex64"===s.dtype||"complex64"===i.dtype){let e=BE({inputs:{x:s},backend:o,attrs:{dtype:"complex64"}}),t=o.data.get(e.dataId),r=t.complexTensorInfos.real,a=t.complexTensorInfos.imag,l=o.data.get(r.dataId).values,u=o.data.get(a.dataId).values,p=BE({inputs:{x:i},backend:o,attrs:{dtype:"complex64"}}),d=o.data.get(p.dataId),h=d.complexTensorInfos.real,c=d.complexTensorInfos.imag,f=o.data.get(h.dataId).values,m=o.data.get(c.dataId).values,[g,y,b]=n(s.shape,i.shape,l,u,f,m),x=o.makeTensorInfo(b,"float32",g),w=o.makeTensorInfo(b,"float32",y),v=FE({inputs:{real:x,imag:w},backend:o});return o.disposeIntermediateTensorInfo(e),o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(w),v}{let e=o.data.get(s.dataId).values,n=o.data.get(i.dataId).values,a=r||s.dtype,[l,u]=t(s.shape,i.shape,e,n,a);return o.makeTensorInfo(u,a,l)}}}function UE(e){return(t,n,r,a,s,i)=>{let o=Jf.assertAndGetBroadcastShape(t,n),l=ka.sizeFromShape(o),u=o.length,p=ka.computeStrides(o),d=ka.getTypedArrayFromDType("float32",l),h=ka.getTypedArrayFromDType("float32",l),c=Jf.getBroadcastDims(t,o),f=Jf.getBroadcastDims(n,o),m=Jf.mergeRealAndImagArrays(r,a),g=Jf.mergeRealAndImagArrays(s,i),y=t.length,b=ka.computeStrides(t),x=n.length,w=ka.computeStrides(n);if(c.length+f.length===0)for(let t=0;t<d.length;t++){let n=t%m.length,r=t%g.length,a=e(m[2*n],m[2*n+1],g[2*r],g[2*r+1]);d[t]=a.real,h[t]=a.imag}else for(let t=0;t<d.length;t++){let n=ka.indexToLoc(t,u,p),r=n.slice(-y);c.forEach((e=>r[e]=0));let a=ka.locToIndex(r,y,b),s=n.slice(-x);f.forEach((e=>s[e]=0));let i=ka.locToIndex(s,x,w),o=e(m[2*a],m[2*a+1],g[2*i],g[2*i+1]);d[t]=o.real,h[t]=o.imag}return[d,h,o]}}var GE=AE(((e,t)=>e+t)),HE=UE(((e,t,n,r)=>({real:e+n,imag:t+r}))),jE=VE(qe,GE,HE),qE={kernelName:qe,backendName:"cpu",kernelFunc:jE};function KE(e,t,n,r,a){let s=ka.sizeFromShape(r),i=ka.makeZerosTypedArray(a,n);for(let n=0;n<e.length;n++){let r=e[n];if(r<0)throw new Error("Input x must be non-negative!");r>=a||(i[r]+=s>0?t[n]:1)}return i}function XE(e,t,n,r=!1){let a=e.shape[0],s=e.shape[1],i=mo([a,n],t.dtype);for(let o=0;o<a;o++)for(let a=0;a<s;a++){let s=e.get(o,a);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?i.set(1,o,s):t.size>0?i.set(i.get(o,s)+t.get(o,a),o,s):i.set(i.get(o,s)+1,o,s))}return i}var YE=AE(((e,t)=>e&t)),ZE=VE(dt,YE),JE={kernelName:dt,backendName:"cpu",kernelFunc:ZE};function QE(e){return(t,n,r)=>{let a=ka.getArrayFromDType(n,t.length);for(let n=0;n<t.length;++n)a[n]=e(t[n],r);return a}}function e$(e,t,n){return t$(e,QE(t),n)}function t$(e,t,n){return({inputs:r,attrs:a,backend:s})=>{let{x:i}=r;NE(i,e);let o,l=s,u=l.data.get(i.dataId).values;if("string"===i.dtype){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");o=Jf.fromUint8ToStringArray(u)}else o=u;let p=n||i.dtype,d=t(o,p,a);return l.makeTensorInfo(i.shape,p,d)}}var n$=QE((e=>Math.ceil(e))),r$=t$(mt,n$),a$={kernelName:mt,backendName:"cpu",kernelFunc:r$};function s$(e,t,n,r){let a=ka.getArrayFromDType(n,ka.sizeFromShape(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{let n=ka.sizeFromShape(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{let s="string"===n?Jf.fromUint8ToStringArray(e.vals):e.vals,i=0;for(let n=0;n<e.shape[0];++n){let o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[o+t]=s[i++]}r+=e.shape[1]}))}return a}var i$=AE(((e,t)=>e===t?1:0)),o$=VE(jt,i$,null,"bool"),l$={kernelName:jt,backendName:"cpu",kernelFunc:o$},u$=QE((e=>Math.exp(e))),p$=t$(qt,u$,"float32"),d$={kernelName:qt,backendName:"cpu",kernelFunc:p$},h$=QE((e=>Math.expm1(e))),c$=t$(Xt,h$),f$={kernelName:Xt,backendName:"cpu",kernelFunc:c$},m$=QE((e=>Math.floor(e))),g$=t$(Qt,m$),y$={kernelName:Qt,backendName:"cpu",kernelFunc:g$},b$=AE(((e,t)=>Math.floor(e/t))),x$=VE(en,b$,null,"int32"),w$={kernelName:en,backendName:"cpu",kernelFunc:x$};function v$(e,t,n,r,a,s,i,o,l){let u=mo([r,s],n);for(let n=0;n<r;n++){let r=[],p=0;for(let t=0;t<a;t++){let s=e[n*a+t];p+=s*i[t],r.push(s)}if(p<0||p>=l/s)throw new Error(`Invalid indices: ${r} does not index into ${o}`);for(let e=0;e<s;e++)u.values[n*s+e]=t.get(...t.indexToLoc(p*s+e))}return u}function k$(e,t,n){let r=mo(n,e.dtype);for(let n=0;n<r.size;++n){let a=r.indexToLoc(n).slice(),s=a[0],i=a[2],o=t.locToIndex([s,i]);a[2]=t.values[o];let l=e.locToIndex(a);0<=l&&l<e.values.length&&(r.values[n]=e.values[l])}return r}var I$=AE(((e,t)=>e>t?1:0)),S$=VE(an,I$,null,"bool"),N$={kernelName:an,backendName:"cpu",kernelFunc:S$},T$=AE(((e,t)=>e>=t?1:0)),_$=VE(sn,T$,null,"bool"),C$={kernelName:sn,backendName:"cpu",kernelFunc:_$},E$=AE(((e,t)=>e<t?1:0)),$$=VE(fn,E$,null,"bool"),A$={kernelName:fn,backendName:"cpu",kernelFunc:$$},F$=AE(((e,t)=>e<=t?1:0)),R$=VE(mn,F$,null,"bool"),D$={kernelName:mn,backendName:"cpu",kernelFunc:R$};function M$(e,t,n){let r=(t-e)/(n-1),a=ka.makeZerosTypedArray(n,"float32");a[0]=e;for(let e=1;e<a.length;e++)a[e]=a[e-1]+r;return a}var O$=QE((e=>Math.log(e))),L$=t$(yn,O$),z$={kernelName:yn,backendName:"cpu",kernelFunc:L$};function P$(e,t,n,r){let a=ka.getTypedArrayFromDType(r,ka.sizeFromShape(n));for(let n=0;n<a.length;++n){let r=n*t,s=e[r];for(let n=0;n<t;++n){let t=e[r+n];(Number.isNaN(t)||t>s)&&(s=t)}a[n]=s}return a}var B$=AE(((e,t)=>Math.max(e,t))),W$=VE(En,B$),V$={kernelName:En,backendName:"cpu",kernelFunc:W$},U$=AE(((e,t)=>Math.min(e,t))),G$=VE(Ln,U$),H$={kernelName:Ln,backendName:"cpu",kernelFunc:G$},j$=AE(((e,t)=>e*t)),q$=UE(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),K$=VE(Wn,j$,q$),X$={kernelName:Wn,backendName:"cpu",kernelFunc:K$};function Y$(e,t,n){let r=ka.createScalarValue(-1,n);return j$([],t,r,e,n)}var Z$={kernelName:Vn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t;NE(r,"neg");let a=n.data.get(r.dataId).values,[s,i]=Y$(a,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,s)}},J$=AE(((e,t)=>e!==t?1:0)),Q$=VE(Un,J$,null,"bool"),eA={kernelName:Un,backendName:"cpu",kernelFunc:Q$};function tA(e,t,n,r,a){let s=t.length,i=ka.sizeFromShape(t),o=ka.computeStrides(t),l=ka.computeStrides(a),u=ka.getTypedArrayFromDType(n,ka.sizeFromShape(a));for(let t=0;t<i;++t){let n=ka.indexToLoc(t,s,o),a=new Array(n.length);for(let e=0;e<a.length;e++)a[e]=n[r[e]];u[ka.locToIndex(a,s,l)]=e[t]}return u}function nA(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;NE(a,"transpose");let i=a.shape.length,o=new Array(i);for(let e=0;e<o.length;e++)o[e]=a.shape[s[e]];let l=tA(r.data.get(a.dataId).values,a.shape,a.dtype,s,o);return{dataId:r.write(l,o,a.dtype),shape:o,dtype:a.dtype}}var rA={kernelName:Zr,backendName:"cpu",kernelFunc:nA};function aA(e,t,n,r){let[a,s]=Jf.computeOutAndReduceShapes(e,r),i=gs(t,"int32"),o=ka.makeZerosTypedArray(ka.sizeFromShape(a),i),l=ka.sizeFromShape(s);for(let e=0;e<o.length;++e){let t=e*l,r=1;for(let e=0;e<l;++e)r*=n[t+e];o[e]=r}return{outVals:o,outShape:a,outDtype:i}}var sA={kernelName:er,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;NE(a,"prod");let o=a.shape.length,l=ka.parseAxisParam(s,a.shape),u=Jf.getAxesPermutation(l,o),p=l,d=a,h=[];null!=u&&(d=nA({inputs:{x:a},backend:n,attrs:{perm:u}}),h.push(d),p=Jf.getInnerMostAxes(p.length,o));let c=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=aA(d.shape,d.dtype,c,p),y=m;return i&&(y=Jf.expandShapeToKeepDim(m,l)),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}};function iA(e,t,n,r){let a=[],s=0,i=t.length-1+n.length,o=new Array(i).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){let r=e[n],a=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let e=0;e<t.length-1;++e){l*=t[e];let n=t[e+1];for(let t=1;t<l+1;++t)o[e].push(t*n)}for(let r=0;r<e.length;++r){let i=e[r],l=e[r]+1;for(let e=0;e<n.length;++e){let r=n[e],a=e+t.length-1;if(a>=0){let e=o[a],t=e[e.length-1]-r[i];for(let e=i;e<l;++e)o[a].push(r[e+1]+t)}i=r[i],l=r[l]}l!==i&&(a.push([i,l]),s+=l-i)}return{outSplits:o,valueSlices:a,numValues:s}}function oA(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function lA(e,t,n,r,a){let s=t.slice();s[0]=a;let i=ka.getArrayFromDType(n,ka.sizeFromShape(s)),o=e.length;return function(e,t,n,r,a,s){let i=oA(t,2)[1],o=oA(s,2)[1],l=0;for(let t of n)for(let n=t[0];n<t[1];++n){for(let t=0;t<r;++t)a[l*o+t]=e[n*i+t];++l}}(e,t,r,0===o?0:o/t[0],i,s),[i,s]}function uA(e,t,n,r,a,s,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){let a=ka.indexToLoc(r,t.length,ka.computeStrides(t)).join(",");throw new Error(`indices[${a}] = ${e} is not in [0, ${n})`)}}))}(s,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");let l=r[0],{outSplits:u,valueSlices:p,numValues:d}=iA(s,i,e,l),h=function(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,a=ka.getArrayFromDType("int32",r);t.push(a),e[n].forEach(((e,t)=>a[t]=e))}return t}(u),c=lA(n,r,a,p,d);return[h,c[0],c[1]]}var pA=2147483647;function dA(e,t,n,r,a,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=0===t.length,l=0===a.length,u=0===i.length,p=[];o||p.push(t[0]),l||p.push(a[0]),u||p.push(i[0]);for(let e=1;e<p.length;++e)if(p[e]!==p[e-1])throw new Error("starts, limits, and deltas must have the same shape");let d=0===p.length?1:p[0],h=ka.getArrayFromDType("int32",d+1);h[0]=0;for(let t=0;t<d;++t){let n,a=o?e[0]:e[t],i=l?r[0]:r[t],p=u?s[0]:s[t];if(0===p)throw new Error("Requires delta != 0");if(p>0&&i<a||p<0&&i>a)n=0;else if(n=Math.ceil(Math.abs((i-a)/p)),n>pA)throw new Error(`Requires ((limit - start) / delta) <= ${pA}`);h[t+1]=h[t]+n}let c=h[d],f=ka.getArrayFromDType(n,c),m=0;for(let t=0;t<d;++t){let n=h[t+1]-h[t],r=o?e[0]:e[t],a=u?s[0]:s[t];for(let e=0;e<n;++e)f[m++]=r,r+=a}return[h,f]}var hA=Jf.RowPartitionType,cA=class e{constructor(e,t,n,r,a,s,i,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=s,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=Jf.getRowPartitionTypesHelper(u),this.raggedRank=Jf.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===hA.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===hA.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case hA.VALUE_ROWIDS:return e.getMaxWidthValueRowID(n);case hA.ROW_SPLITS:return e.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${hA[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){let t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){let t=e.length;if(0===t)return 0;let n=0,r=e[0],a=0;for(let s=1;s<t;++s){let t=e[s];t!==r&&(r=t,a=Math.max(s-n,a),n=s)}return Math.max(t-n,a)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return mA(e,n)}calculateOutputSize(e){let t=this.valuesShape,n=this.defaultValueShape;Jf.validateDefaultValueShape(n,t);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=Jf.combineRaggedTensorToTensorShapes(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let e=1;e<=this.raggedRank;++e)a[e]<0&&(a[e]=this.getMaxWidth(e));return a}calculateFirstParentOutputIndex(e,t,n){let r=Math.min(e,n),a=[],s=0;for(let e=0;e<r;++e,s+=t)a.push(s);for(let t=r;t<e;++t)a.push(-1);return ka.assert(a.length===e,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(e,t,n,r){let a=e.length,s=[];for(let i=0;i<a-1;++i){let a=e[i+1]-e[i],o=Math.min(r,a),l=t[i];-1===l&&(o=0);for(let e=0;e<o;++e)s.push(l),l+=n;for(let e=0;e<a-o;++e)s.push(-1)}if(a>0&&s.length!==e[a-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,r){let a=e.length,s=[];if(0===a)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];s.push(l);for(let u=1;u<a;++u){let a=e[u];if(a===o)l>=0&&(++i,i<r?l+=n:l=-1);else{if(i=0,o=a,a>=t.length)throw new Error(`Got nextValueRowId=${a} which is not less than ${t.length}`);l=t[a]}s.push(l)}if(s.length!==e.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,r){let a=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case hA.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,n,r);case hA.ROW_SPLITS:if(a.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,n,r);default:throw new Error(`Unsupported partition type: ${hA[s]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case hA.FIRST_DIM_SIZE:return e[0];case hA.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case hA.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${hA[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let e=n.length-2;e>=0;--e)n[e]=n[e+1]*t[e+1];let r=mA(t,!1),a=ka.getArrayFromDType(this.valuesDType,ka.sizeFromShape(r));if(n[0]*t[0]>0){let s=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e)s=this.calculateOutputIndex(e-1,s,n[e],t[e]);this.setOutput(this.raggedRank,s,a,r)}return[r,a]}setOutput(e,t,n,r){if(0===n.length)return;let a=this.values,s=n,i=r.slice();i=i.slice(e+1);let o=ka.sizeFromShape(i),l=t.length,u=this.defaultValue;if(u.length!==o&&1!==u.length){let e=this.defaultValueShape;ri((()=>{let t=Zo(u,e);u=ml(t,i).dataSync()}))}let p=0,d=0,h=0;for(let e=0;e<=l;++e){let r=e<l?t[e]:-1;if(r!==h){if(d<h){let e=a.subarray(p*o);fA(s.subarray(d*o),e,(h-d)*o)}if(e>=l){let e=n.length;r=Math.floor(e/o)}if(r>h)if(1===this.defaultValue.length)s.subarray(h*o,r*o).fill(this.defaultValue[0]),h=r;else for(;r>h;){fA(s.slice(h*o),u,o),++h}r<0?(p=e+1,d=h):(p=e,d=h,h=d+1)}else++h}}};function fA(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function mA(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function gA(e,t,n,r,a,s,i,o,l,u){return new cA(e,t,n,r,a,s,i,o,l,u).compute()}function yA(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return ka.makeZerosTypedArray(0,r);let a=Math.abs(Math.ceil((t-e)/n)),s=ka.makeZerosTypedArray(a,r);t<e&&1===n&&(n=-1),s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+n;return s}var bA=QE((e=>1/Math.sqrt(e))),xA=t$(gr,bA),wA={kernelName:gr,backendName:"cpu",kernelFunc:xA};function vA(e,t,n,r,a,s,i,o,l,u){let p=[r/a,a],d=e.values,h=t.values;if(0===r)return mo(n,t.dtype);let c=l instanceof rs?l:mo(p,t.dtype);"string"==typeof l||"number"==typeof l?c.values.fill(l):"boolean"==typeof l&&c.values.fill(+l);for(let e=0;e<s;e++){let s=[],l=0;for(let t=0;t<i;t++){let n=d[e*i+t];s.push(n),l+=n*o[t]}if(l<0||l>=r/a)throw new Error(`Invalid indices: ${s} does not index into ${n}`);for(let n=0;n<a;n++)u?c.values[l*a+n]+=h[e*a+n]:c.values[l*a+n]=0===t.rank?h[0]:h[e*a+n]}return c}var kA=QE((e=>1/(1+Math.exp(-e)))),IA=e$(Tr,(e=>1/(1+Math.exp(-e)))),SA={kernelName:Tr,backendName:"cpu",kernelFunc:IA};function NA(e,t,n,r,a){let s=Tf.isSliceContinous(r,t,n),i=ka.sizeFromShape(n),o=ka.computeStrides(r);if(s){let n=Tf.computeFlatOffset(t,o);return"string"===a?e.slice(n,n+i):e.subarray(n,n+i)}let l=mo(r,a,"string"===a?Jf.fromUint8ToStringArray(e):e),u=mo(n,a);for(let e=0;e<u.size;++e){let n=u.indexToLoc(e),r=n.map(((e,n)=>e+t[n]));u.set(l.get(...r),...n)}return"string"===a?Jf.fromStringArrayToUint8(u.values):u.values}function TA(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r;NE(a,"slice");let[o,l]=Tf.parseSliceParams(a,s,i);Tf.assertParamsValid(a,o,l);let u=NA(n.data.get(a.dataId).values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,u)}var _A={kernelName:kr,backendName:"cpu",kernelFunc:TA};function CA(e,t,n,r,a,s,i){let o=t[0],l=s[0],u=new Array(l),p=new Array(o),d=t[1];if(0===l){if(0!==o)throw new Error(Jf.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));return[ka.getArrayFromDType(n,0),[0,d],ka.getArrayFromDType(a,0),u,p]}let h=!0,c=0,f=new Array(l).fill(0);for(let t=0;t<o;++t){let n=e[t*d];if(n<0)throw new Error(Jf.getSparseFillEmptyRowsNegativeIndexErrorMessage(t,n));if(n>=l)throw new Error(Jf.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(t,n,l));++f[n],h=h&&n>=c,c=n}let m=!0;for(let e=0;e<l;++e){let t=0===f[e];u[e]=t,m=m&&!t,f[e]=Math.max(f[e],1),e>0&&(f[e]+=f[e-1])}if(m&&h){let t=e,n=r;for(let e=0;e<o;++e)p[e]=e;return[t,[o,d],n,u,p]}{let t=f[l-1],s=ka.getArrayFromDType(n,t*d),h=ka.getArrayFromDType(a,t),c=new Array(l).fill(0);for(let t=0;t<o;++t){let n=e[t*d],a=c[n],i=(0===n?0:f[n-1])+a;c[n]++;for(let n=0;n<d;++n)s[i*d+n]=e[t*d+n];h[i]=r[t],p[t]=i}for(let e=0;e<l;++e)if(0===c[e]){let t=0===e?0:f[e-1];s[t*d+0]=e;for(let e=1;e<d;++e)s[t*d+e]=0;h[t]=i}return[s,[t,d],h,u,p]}}function EA(e,t,n,r,a){let s=ka.sizeFromShape(r),i=t[0],o=a.length,l=[],u=1,p=-1;for(let e=0;e<o;++e){let t=a[e];if(-1===t){if(-1!==p)throw new Error(Jf.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(p,e));p=e,l.push(1)}else{if(t<0)throw new Error(Jf.getSparseReshapeNegativeOutputDimErrorMessage(e,t));u*=t,l.push(t)}}if(-1!==p){if(u<=0)throw new Error(Jf.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let e=Math.trunc(s/u);if(u*e!==s)throw new Error(Jf.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[p]=e}if(ka.sizeFromShape(l)!==s)throw new Error(Jf.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let d=r.length,h=[];if(d>0){h[d-1]=1;for(let e=d-2;e>=0;--e)h[e]=h[e+1]*r[e+1]}let c=[];if(o>0){c[o-1]=1;for(let e=o-2;e>=0;--e)c[e]=c[e+1]*l[e+1]}let f=ka.getArrayFromDType(n,i*o);for(let t=0;t<i;++t){let n=0;for(let r=0;r<d;++r)n+=e[t*d+r]*h[r];for(let e=0;e<o;++e)f[t*o+e]=Math.trunc(n/c[e]),n%=c[e]}return[f,[i,o],l]}function $A(e,t,n,r,a,s=!1,i=0){let o=r.length,l=[t[0],e.length/t[0]],u=l[1],p=o>0?a[o-1]+1:0;if(p<0)throw new Error(Jf.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=t.slice();d[0]=p;let h=d.reduce(((e,t)=>e*t),1),c=ka.getArrayFromDType(n,h);if(0===o)return p>0&&c.fill(i),[c,d];if(p<=0)throw new Error(Jf.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=a[f];for(;;){let t=0;if(m<o){if(t=a[m],y===t){++m;continue}if(y>=t)throw new Error(Jf.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=p)throw new Error(Jf.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,p));y>g&&c.fill(i,g*u,y*u);for(let t=f;t<m;++t){let n=r[t];if(n<0||n>=l[0])throw new Error(Jf.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(t,r[t],l[0]));for(let t=0;t<u;t++)c[y*u+t]+=e[n*u+t]}if(s)for(let e=0;e<u;e++)c[y*u+e]/=m-f;if(f=m,++m,g=y+1,y=t,m>o)break}return g<p&&c.fill(i,g*u,p*u),[c,d]}var AA=QE((e=>Math.sqrt(e))),FA=e$(Cr,(e=>Math.sqrt(e))),RA={kernelName:Cr,backendName:"cpu",kernelFunc:FA},DA=AE(((e,t)=>{let n=e-t;return n*n})),MA=VE(zr,DA),OA={kernelName:zr,backendName:"cpu",kernelFunc:MA},LA=QE(((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)})),zA=t$(Br,LA),PA={kernelName:Br,backendName:"cpu",kernelFunc:zA};function BA(e,t,n,r){let a=mo(e,t.dtype);for(let e=0;e<a.size;e++){let s=a.indexToLoc(e),i=new Array(s.length);for(let e=0;e<i.length;e++)i[e]=s[e]*n[e]+r[e];a.set(t.get(...i),...s)}return a}var WA=class{constructor(e,t,n,r,a,s){this.separator=ka.encodeString(e),this.nGramWidths=t,this.leftPad=ka.encodeString(n),this.rightPad=ka.encodeString(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let i=0;i<a;++i){let o=this.getPadWidth(s),l=Math.max(0,o-i),u=Math.max(0,o-(a-(i+1))),p=s-(l+u),d=t+(l>0?0:i-o),h=0;h+=l*this.leftPad.length;for(let t=0;t<p;++t)h+=e[d+t].length;h+=u*this.rightPad.length,h+=(l+u+p-1)*this.separator.length,n[r+i]=new Uint8Array(h);let c=n[r+i],f=0,m=e=>e.forEach((e=>c[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<p-1;++t)m(e[d+t]),m(this.separator);if(p>0){m(e[d+p-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let a=1;a<r;++a){let r=t[a]>=e;if(r=r&&t[a]<=n,!r)throw new Error(`Invalid split value ${t[a]}, must be in [${e}, ${n}]`);e=t[a]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}let a=r-1,s=ka.getArrayFromDType("int32",r);if(0===n||0===r){let e=new Array(n);for(let e=0;e<=a;++e)s[e]=0;return[e,s]}s[0]=0;for(let e=1;e<=a;++e){let n=t[e]-t[e-1],r=0;this.nGramWidths.forEach((e=>{r+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===r&&(r=1),s[e]=s[e-1]+r}let i=new Array(s[a]);for(let n=0;n<a;++n){let r=t[n],a=s[n];if(this.nGramWidths.forEach((s=>{let o=t[n+1]-t[n],l=this.getNumNGrams(o,s);this.createNGrams(e,r,i,a,l,s),a+=l})),this.preserveShort&&a===s[n]){let s=t[n+1]-t[n];if(0===s)continue;let o=s+2*this.padWidth;this.createNGrams(e,r,i,a,1,o)}}return[i,s]}};function VA(e,t,n,r,a,s,i,o){return new WA(n,r,a,s,i,o).compute(e,t)}function UA(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){let a=t[0],s=e.indexOf(a);for(;-1!==s;){let t=e.subarray(0,s);(!n||0!==t.length)&&r.push(t),s=(e=e.subarray(s+1)).indexOf(a)}return void((!n||0!==e.length)&&r.push(e))}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){let t=e.subarray(a,s);(!n||0!==t.length)&&r.push(t),a=s+1}}function GA(e,t,n){let r=e.length,a=[],s=0,i=0,o=new Array(r);for(let l=0;l<r;++l){let r=a.length;UA(e[l],t,n,a);let u=a.length-r;o[l]=u,s+=u,i=Math.max(i,u)}let l=ka.getArrayFromDType("int32",2*s),u=new Array(s),p=[r,i],d=0;for(let e=0;e<r;++e)for(let t=0;t<o[e];++t)l[2*d]=e,l[2*d+1]=t,u[d]=a[d],++d;return[l,u,p]}function HA(e,t){let n=ka.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=ka.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var jA=AE(((e,t)=>e-t)),qA=UE(((e,t,n,r)=>({real:e-n,imag:t-r}))),KA=VE(Hr,jA,qA),XA={kernelName:Hr,backendName:"cpu",kernelFunc:KA};function YA(e,t){let n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];let r=mo(n,e.dtype);for(let t=0;t<r.values.length;++t){let n=r.indexToLoc(t),a=new Array(e.rank);for(let t=0;t<a.length;t++)a[t]=n[t]%e.shape[t];let s=e.locToIndex(a);r.values[t]=e.values[s]}return r}var ZA=(e,t)=>{let n=t.value-e.value;return 0===n?e.index-t.index:n};function JA(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let a=r-n+1,s=t-n+1,i=Math.log(a),o=.5*Math.exp(2*i/3),l=.5*Math.sqrt(i*o*(a-o)/a)*Math.sign(s-a/2);JA(e,t,Math.max(n,Math.floor(t-s*o/a+l)),Math.min(r,Math.floor(t+(a-s)*o/a+l)))}let a=e[t],s=n,i=r;for(ka.swap(e,n,t),ZA(e[r],a)>0&&ka.swap(e,n,r);s<i;){for(ka.swap(e,s,i),s++,i--;ZA(e[s],a)<0;)s+=1;for(;ZA(e[i],a)>0;)i-=1}0===ZA(e[n],a)?ka.swap(e,n,i):(i+=1,ka.swap(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function QA(e,t,n,r,a){let s=t[t.length-1],[i,o]=[e.length/s,s],l=ka.getTypedArrayFromDType(n,i*r),u=ka.getTypedArrayFromDType("int32",i*r);for(let t=0;t<i;t++){let n=t*o,s=e.subarray(n,n+o),i=new Array(s.length);s.forEach(((e,t)=>i[t]={value:e,index:t})),r<i.length&&(JA(i,r),i=i.slice(0,r)),a&&i.sort(ZA);let p=t*r,d=l.subarray(p,p+r),h=u.subarray(p,p+r);for(let e=0;e<r;e++)d[e]=i[e].value,h[e]=i[e].index}let p=t.slice();return p[p.length-1]=r,[mo(p,n,l),mo(p,"int32",u)]}function eF(e,t,n,r){let a=ka.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let e=0;e<a;e++)s[0]*=n[e];s[1]=n[a];for(let e=a+1;e<n.length;e++)s[2]*=n[e];let i=new Map,o=new Int32Array(n[a]),l=new rs(s,r,e),u=[],p=1===s[0]&&1===s[2];for(let t=0;t<n[a];t++){let n;if(p)n=e[t].toString();else{let e=[];for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)e.push(l.get(n,t,r));n=e.join(",")}let r=i.get(n);if(null!=r)o[t]=r;else{let e=i.size;i.set(n,e),o[t]=e,u.push(t)}}let d=s.slice();d[1]=i.size;let h=new rs(d,r);u.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)h.set(l.get(n,e,r),n,t,r)}));let c=n.slice();return c[a]=d[1],{outputValues:h.values,outputShape:c,indices:o}}var tF="4.22.0";ci("cpu",(()=>new _E),1);var nF=e$(Ut,(e=>e>=0?e:Math.exp(e)-1)),rF={kernelName:Ut,backendName:"cpu",kernelFunc:nF};function aF(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r;NE([a],"leakyRelu");let i=ka.sizeFromShape(a.shape),o=n.data.get(a.dataId).values,l=ka.getTypedArrayFromDType("float32",i);for(let e=0;e<o.length;e++)l[e]=o[e]<0?s*o[e]:o[e];return n.makeTensorInfo(a.shape,"float32",l)}var sF={kernelName:cn,backendName:"cpu",kernelFunc:aF},iF=AE(((e,t)=>e<0?t*e:e));function oF(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t;NE([r,a],"prelu");let s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[o,l]=iF(r.shape,a.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}var lF={kernelName:Qn,backendName:"cpu",kernelFunc:oF},uF=e$(or,(e=>Math.max(0,e))),pF={kernelName:or,backendName:"cpu",kernelFunc:uF},dF=e$(cr,(e=>Math.min(Math.max(0,e),6))),hF={kernelName:cr,backendName:"cpu",kernelFunc:dF};function cF(e,t,n,r,a){if("linear"===n)return ME({inputs:{x:t},backend:e});if("relu"===n)return uF({inputs:{x:t},backend:e});if("elu"===n)return nF({inputs:{x:t},backend:e});if("relu6"===n)return dF({inputs:{x:t},backend:e});if("prelu"===n)return oF({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return aF({inputs:{x:t},backend:e,attrs:{alpha:a}});if("sigmoid"===n)return IA({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function fF(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=ka.sizeFromShape(a.shape),o=ka.inferFromImplicitShape(s,i),l=ka.sizeFromShape(o);ka.assert(i===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(a.dataId);let u=n.data.get(a.dataId);if(null!=u.complexTensorInfos){let e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}var mF={kernelName:lr,backendName:"cpu",kernelFunc:fF};function gF(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;NE([a,s],"matMul");let l=a.shape.length,u=s.shape.length,p=i?a.shape[l-2]:a.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],h=i?a.shape[l-1]:a.shape[l-2],c=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=ka.sizeFromShape(f),y=ka.sizeFromShape(m),b=Pl.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,c]);ka.assert(p===d,(()=>`Error in matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`));let x=o?[y,c,d]:[y,d,c],w=fF({inputs:{x:a},backend:n,attrs:{shape:i?[g,p,h]:[g,h,p]}}),v=fF({inputs:{x:s},backend:n,attrs:{shape:x}}),k=i?w.shape[1]:w.shape[2],I=i?w.shape[2]:w.shape[1],S=o?v.shape[1]:v.shape[2],N=Math.max(g,y),T=n.data.get(w.dataId).values,_=n.data.get(v.dataId).values,C=ka.computeStrides(w.shape),E=ka.computeStrides(v.shape),[$,A,F]=i?[C[0],1,C[1]]:[C[0],C[1],1],[R,D,M]=o?[1,E[1],E[0]]:[E[1],1,E[0]],O=I*S,L=mo([N,I,S],w.dtype),z=L.values,P=n.blockSize;for(let e=0;e<N;e++){let t=e%g,n=e%y;for(let r=0;r<I;r+=P){let a=Math.min(r+P,I);for(let s=0;s<S;s+=P){let i=Math.min(s+P,S);for(let o=0;o<k;o+=P){let l=Math.min(o+P,k);for(let u=r;u<a;u++)for(let r=s;r<i;r++){let a=0;for(let e=o;e<l;e++){a+=T[t*$+u*A+e*F]*_[e*R+r*D+n*M]}z[e*O+(u*S+r)]+=a}}}}}return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(v),n.makeTensorInfo(b,L.dtype,L.values)}var yF={kernelName:lt,backendName:"cpu",kernelFunc:gF};var bF={kernelName:ia,backendName:"cpu",kernelFunc:function(e){let t,n,r,{inputs:a,backend:s,attrs:i}=e,{a:o,b:l,bias:u,preluActivationWeights:p}=a,{transposeA:d,transposeB:h,activation:c,leakyreluAlpha:f}=i,m=[];t=gF({inputs:{a:o,b:l},attrs:{transposeA:d,transposeB:h},backend:s}),u&&(n=jE({inputs:{a:t,b:u},backend:s}),m.push(t),t=n),c&&(r=cF(s,t,c,p,f),m.push(t),t=r);for(let e of m)s.disposeIntermediateTensorInfo(e);return t}},xF=e$(He,(e=>Math.acos(e))),wF={kernelName:He,backendName:"cpu",kernelFunc:xF},vF=e$(je,(e=>Math.acosh(e))),kF={kernelName:je,backendName:"cpu",kernelFunc:vF};var IF={kernelName:Ke,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,r=t;NE(t,"addN");let a=r.map((e=>n.data.get(e.dataId).values)),s=mo(r[0].shape,r[0].dtype),i=s.values;for(let e=0;e<r.length;e++){let t=a[e];for(let e=0;e<i.length;e++)i[e]+=t[e]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};var SF={kernelName:Xe,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;NE(a,"all");let o=ka.parseAxisParam(s,a.shape),l=o,u=Jf.getAxesPermutation(l,a.shape.length),p=a;null!=u&&(p=nA({inputs:{x:a},backend:n,attrs:{perm:u}}),l=Jf.getInnerMostAxes(l.length,a.shape.length)),Jf.assertAxesAreInnerMostDims("all",l,p.shape.length);let[d,h]=Jf.computeOutAndReduceShapes(p.shape,l),c=ka.sizeFromShape(h),f=ka.makeZerosTypedArray(ka.sizeFromShape(d),p.dtype),m=n.data.get(p.dataId).values;for(let e=0;e<f.length;++e){let t=e*c,n=m[t];for(let e=0;e<c;++e){let r=m[t+e];n=n&&r}f[e]=n}null!=u&&n.disposeIntermediateTensorInfo(p);let g=n.makeTensorInfo(d,p.dtype,f);if(i){let e=fF({inputs:{x:g},backend:n,attrs:{shape:Jf.expandShapeToKeepDim(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};var NF={kernelName:Ye,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;NE(a,"any");let o=ka.parseAxisParam(s,a.shape),l=o,u=Jf.getAxesPermutation(l,a.shape.length),p=a;null!=u&&(p=nA({inputs:{x:a},backend:n,attrs:{perm:u}}),l=Jf.getInnerMostAxes(l.length,a.shape.length)),Jf.assertAxesAreInnerMostDims("any",l,p.shape.length);let[d,h]=Jf.computeOutAndReduceShapes(p.shape,l),c=ka.sizeFromShape(h),f=ka.makeZerosTypedArray(ka.sizeFromShape(d),p.dtype),m=n.data.get(p.dataId).values;for(let e=0;e<f.length;++e){let t=e*c,n=m[t];for(let e=0;e<c;++e){let r=m[t+e];n=n||r}f[e]=n}null!=u&&n.disposeIntermediateTensorInfo(p);let g=n.makeTensorInfo(d,p.dtype,f);if(i){let e=fF({inputs:{x:g},backend:n,attrs:{shape:Jf.expandShapeToKeepDim(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};var TF={kernelName:Ze,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;NE(a,"argMax");let i=ka.parseAxisParam(s,a.shape),o=Jf.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=nA({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=Jf.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],Jf.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[p,d]=Jf.computeOutAndReduceShapes(l.shape,i),h=ka.sizeFromShape(p),c=ka.makeZerosTypedArray(h,"int32"),f=ka.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let e=0;e<c.length;++e){let t=e*f,n=m[t],r=0;for(let e=0;e<f;++e){let a=m[t+e];a>n&&(n=a,r=e)}c[e]=r}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(p,"int32",c)}};var _F={kernelName:Je,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;NE(a,"argMin");let i=ka.parseAxisParam(s,a.shape),o=Jf.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=nA({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=Jf.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],Jf.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[p,d]=Jf.computeOutAndReduceShapes(l.shape,i),h=ka.sizeFromShape(p),c=ka.makeZerosTypedArray(h,"int32"),f=ka.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let e=0;e<c.length;++e){let t=e*f,n=m[t],r=0;for(let e=0;e<f;++e){let a=m[t+e];a<n&&(n=a,r=e)}c[e]=r}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(p,"int32",c)}},CF=e$(Qe,(e=>Math.asin(e))),EF={kernelName:Qe,backendName:"cpu",kernelFunc:CF},$F=e$(et,(e=>Math.asinh(e))),AF={kernelName:et,backendName:"cpu",kernelFunc:$F},FF=e$(tt,(e=>Math.atan(e))),RF={kernelName:tt,backendName:"cpu",kernelFunc:FF},DF=AE(((e,t)=>Math.atan2(e,t))),MF=VE(rt,DF),OF={kernelName:rt,backendName:"cpu",kernelFunc:MF},LF=e$(nt,(e=>Math.atanh(e))),zF={kernelName:nt,backendName:"cpu",kernelFunc:LF};function PF(e,t,n,r,a,s){let i=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,p=a.effectiveFilterHeight,d=a.effectiveFilterWidth,h=a.padInfo.top,c=a.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=mo(a.outShape,n),g=m.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],b=a.outShape[2]*a.outShape[3],x=a.outShape[3];for(let t=0;t<a.batchSize;++t){let n=t*y,m=t*r[0];for(let t=0;t<a.inChannels;++t)for(let y=0;y<a.outHeight;++y){let w=y*i-h,v=Math.max(0,w),k=Math.min(a.inHeight,p+w),I=n+y*b;for(let n=0;n<a.outWidth;++n){let i=n*o-c,p=Math.max(0,i),h=Math.min(a.inWidth,d+i),y=f,b=0,w=0;for(let n=v;n<k;n+=l){let a=m+n*r[1];for(let n=p;n<h;n+=u){let i=e[a+n*r[2]+t];"max"===s&&i>y?y=i:"avg"===s&&(b+=i,w++)}if(isNaN(y))break}g[I+n*x+t]="avg"===s?b/w:y}}}return m}function BF(e,t,n,r,a=!1,s=!1){let i=mo(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,p=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,c=r.padInfo.top,f=r.padInfo.left,m=mo(t,n,e);for(let e=0;e<r.batchSize;++e)for(let t=0;t<r.inChannels;++t)for(let n=0;n<r.outHeight;++n){let g=n*o-c,y=g;for(;y<0;)y+=u;let b=Math.min(r.inHeight,d+g);for(let o=0;o<r.outWidth;++o){let d=o*l-f,c=d;for(;c<0;)c+=p;let x=Math.min(r.inWidth,h+d),w=Number.NEGATIVE_INFINITY,v=-1;for(let n=y;n<b;n+=u){let i=n-g;for(let o=c;o<x;o+=p){let l=o-d,u=m.get(e,n,o,t);u>w&&(w=u,v=a?s?((e*r.inHeight+n)*r.inWidth+o)*r.inChannels+t:(n*r.inWidth+o)*r.inChannels+t:i*h+l)}}i.set(v,e,n,o,t)}}return i}function WF(e,t,n,r,a,s){let i=a.strideDepth,o=a.strideHeight,l=a.strideWidth,u=a.dilationDepth,p=a.dilationHeight,d=a.dilationWidth,h=a.effectiveFilterDepth,c=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,b="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=mo(a.outShape,n),w=x.values,v=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],I=a.outShape[3]*a.outShape[4],S=a.outShape[4];for(let t=0;t<a.batchSize;++t){let n=t*v,x=t*r[0];for(let t=0;t<a.inChannels;++t)for(let v=0;v<a.outDepth;++v){let N=v*i-m,T=N;for(;T<0;)T+=u;let _=Math.min(a.inDepth,h+N),C=n+v*k;for(let n=0;n<a.outHeight;++n){let i=n*o-g,h=i;for(;h<0;)h+=p;let m=Math.min(a.inHeight,c+i),v=C+n*I;for(let n=0;n<a.outWidth;++n){let i=n*l-y,o=i;for(;o<0;)o+=d;let c=Math.min(a.inWidth,f+i),g=v+n*S,k=b,I=0,N=0;for(let n=T;n<_;n+=u){let a=x+n*r[1];for(let n=h;n<m;n+=p){let i=a+n*r[2];for(let n=o;n<c;n+=d){let a=e[i+n*r[3]+t];if("max"===s&&a>k?k=a:"avg"===s&&(I+=a,N++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}w[g+t]="avg"===s?I/Math.max(N,1):k}}}}return x}var VF={kernelName:at,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;NE(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;ka.assert(Jf.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));let u,p=Jf.computePool2DInfo(a.shape,s,i,1,o,l);if(1===p.filterWidth&&1===p.filterHeight&&ka.arraysEqual(p.inShape,p.outShape))u=ME({inputs:{x:a},backend:n});else{let e=n.data.get(a.dataId).values,t=ka.computeStrides(a.shape),r=PF(e,a.shape,a.dtype,t,p,"avg");u=n.makeTensorInfo(p.outShape,a.dtype,r.values)}return u}};var UF={kernelName:it,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;NE(a,"avgPool3d");let p=Jf.computePool3DInfo(a.shape,s,i,1,o,l,u),d=WF(n.data.get(a.dataId).values,a.shape,a.dtype,ka.computeStrides(a.shape),p,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}};var GF={kernelName:ot,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;NE([a,s],"avgPool3DGrad");let p=Jf.computePool3DInfo(s.shape,i,o,1,l,u),d=p.strideDepth,h=p.strideHeight,c=p.strideWidth,f=p.filterDepth,m=p.filterHeight,g=p.filterWidth,y=p.dilationDepth,b=p.dilationHeight,x=p.dilationWidth,w=p.effectiveFilterDepth,v=p.effectiveFilterHeight,k=p.effectiveFilterWidth,I=w-1-p.padInfo.front,S=k-1-p.padInfo.left,N=v-1-p.padInfo.top,T=mo(s.shape,"float32"),_=1/(f*m*g),C=n.bufferSync(a);for(let e=0;e<p.batchSize;++e)for(let t=0;t<p.inChannels;++t)for(let n=0;n<p.inDepth;++n)for(let r=0;r<p.inHeight;++r)for(let a=0;a<p.inWidth;++a){let s=n-I,i=r-N,o=a-S,l=0;for(let n=0;n<w;n+=y){let r=(s+n)/d;if(!(r<0||r>=p.outDepth||Math.floor(r)!==r))for(let n=0;n<v;n+=b){let a=(i+n)/h;if(!(a<0||a>=p.outHeight||Math.floor(a)!==a))for(let n=0;n<k;n+=x){let s=(o+n)/c;s<0||s>=p.outWidth||Math.floor(s)!==s||(l+=C.get(e,r,a,s,t))}}}T.set(l*_,e,n,r,a,t)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}};var HF={kernelName:st,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;NE([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,p=Jf.computePool2DInfo(i.shape,o,l,1,u),d=p.strideHeight,h=p.strideWidth,c=p.filterHeight,f=p.filterWidth,m=p.dilationHeight,g=p.dilationWidth,y=p.effectiveFilterHeight,b=p.effectiveFilterWidth,x=b-1-p.padInfo.left,w=y-1-p.padInfo.top,v=mo(i.shape,"float32"),k=1/(c*f),I=n.data.get(a.dataId).values,S=mo(a.shape,"float32",I);for(let e=0;e<p.batchSize;++e)for(let t=0;t<p.inChannels;++t)for(let n=0;n<p.inHeight;++n)for(let r=0;r<p.inWidth;++r){let a=n-w,s=r-x,i=0;for(let n=0;n<y;n+=m){let r=(a+n)/d;if(!(r<0||r>=p.outHeight||Math.floor(r)!==r))for(let n=0;n<b;n+=g){let a=(s+n)/h;a<0||a>=p.outWidth||Math.floor(a)!==a||(i+=S.get(e,r,a,t))}}v.set(i*k,e,n,r,t)}return n.makeTensorInfo(v.shape,v.dtype,v.values)}};var jF={kernelName:tn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,scale:s,offset:i,mean:o,variance:l}=t;ka.assert(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),ka.assert(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),ka.assert(null==s||o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),NE([a,o,l,s,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);let p=n.data.get(a.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(l.dataId).values,c=s?n.data.get(s.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(p.length),g=f.length,y=c.length,b=h.length,x=d.length,w=0,v=0,k=0,I=0;for(let e=0;e<p.length;++e)m[e]=f[w++]+(p[e]-d[v++])*c[k++]/Math.sqrt(h[I++]+u),w>=g&&(w=0),v>=x&&(v=0),k>=y&&(k=0),I>=b&&(I=0);return n.makeTensorInfo(a.shape,a.dtype,m)}};var qF={kernelName:ut,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;NE([a],"batchToSpaceND");let o=s.reduce(((e,t)=>e*t)),l=Jf.getReshaped(a.shape,s,o),u=Jf.getPermuted(l.length,s.length),p=Jf.getReshapedPermuted(a.shape,s,o),d=Jf.getSliceBeginCoords(i,s.length),h=Jf.getSliceSize(p,i,s.length),c=fF({inputs:{x:a},backend:n,attrs:{shape:l}}),f=nA({inputs:{x:c},backend:n,attrs:{perm:u}}),m=fF({inputs:{x:f},backend:n,attrs:{shape:p}}),g=TA({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};var KF={kernelName:pt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=KE(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,o)}};var XF={kernelName:ct,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=Jf.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},YF=e$(gt,((e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),ZF={kernelName:gt,backendName:"cpu",kernelFunc:YF},JF={kernelName:bt,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(ka.sizeFromShape(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let e=0;e<o.length;e++){let t=o[e],n=l[e];r[e]=Math.hypot(t,n)}return n.makeOutput(r,t.shape,"float32")}};function QF(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var eR={kernelName:un,backendName:"cpu",kernelFunc:QF};function tR(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=ka.parseAxisParam(a,t[0].shape)[0],i=t.map((e=>e.shape));Jf.assertParamsConsistent(i,s);let o=Jf.computeOutShape(t.map((e=>e.shape)),s);if(0===ka.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter((e=>ka.sizeFromShape(e.shape)>0));if(1===l.length)return ME({inputs:{x:l[0]},backend:n});if("complex64"===l[0].dtype){let e=l.map((e=>LE({inputs:{input:e},backend:n}))),t=l.map((e=>QF({inputs:{input:e},backend:n}))),r=tR({inputs:e,backend:n,attrs:{axis:s}}),a=tR({inputs:t,backend:n,attrs:{axis:s}}),i=FE({inputs:{real:r,imag:a},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),i}let u=l.map((e=>{let t=[-1,ka.sizeFromShape(e.shape.slice(s))];return fF({inputs:{x:e},backend:n,attrs:{shape:t}})})),p=u.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));o=Jf.computeOutShape(u.map((e=>e.shape)),1);let d=1===u[0].shape[0],h=s$(p,o,t[0].dtype,d),c=Jf.computeOutShape(l.map((e=>e.shape)),s),f=n.makeTensorInfo(c,t[0].dtype,h);return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}var nR={kernelName:xt,backendName:"cpu",kernelFunc:tR};function rR(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:p}=r;NE([a,s],"conv2d");let d=Jf.convertConv2DDataFormat(l),h=Jf.computeConv2DInfo(a.shape,s.shape,i,u,o,p,!1,d),c=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,x="channelsLast"===h.dataFormat,w=new rs(h.outShape,a.dtype),v=ka.computeStrides(a.shape),k=ka.computeStrides(s.shape),I=v[0],S=x?v[1]:v[2],N=x?v[2]:1,T=x?1:v[1],_=w.strides[0],C=x?w.strides[1]:w.strides[2],E=x?w.strides[2]:1,$=x?1:w.strides[1],A=n.data.get(a.dataId).values,F=n.data.get(s.dataId).values,R=w.values;for(let e=0;e<h.batchSize;++e){let t=e*I,n=e*_;for(let e=0;e<h.outHeight;++e){let r=n+e*C,a=e*h.strideHeight-b;for(let e=0;e<c;++e){let n=a+e*m;if(n<0||n>=h.inHeight)continue;let s=e*k[0],i=t+n*S;for(let e=0;e<h.outWidth;++e){let t=r+e*E,n=e*h.strideWidth-y;for(let e=0;e<f;++e){let r=n+e*g;if(r<0||r>=h.inWidth)continue;let a=i+r*N,o=s+e*k[1];for(let e=0;e<h.inChannels;++e){let n=A[a+e*T];for(let e=0;e<h.outChannels;++e)R[t+e*$]+=n*F[o+e];o+=h.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,R)}var aR={kernelName:wt,backendName:"cpu",kernelFunc:rR};var sR={kernelName:vt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:p}=r;NE([a,s],"conv2dBackpropFilter");let d=Jf.convertConv2DDataFormat(l),h=Jf.computeConv2DInfo(a.shape,p,i,1,o,u,!1,d),{strideHeight:c,strideWidth:f,filterHeight:m,filterWidth:g}=h,y="channelsLast"===h.dataFormat,b=new rs(h.filterShape,"float32"),x=h.padInfo.left,w=h.padInfo.top,v=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,I=new rs(a.shape,a.dtype,v),S=new rs(s.shape,s.dtype,k);for(let e=0;e<m;++e){let t=Math.max(0,Math.ceil((w-e)/c)),n=Math.min(h.outHeight,(h.inHeight+w-e)/c);for(let r=0;r<g;++r){let a=Math.max(0,Math.ceil((x-r)/f)),s=Math.min(h.outWidth,(h.inWidth+x-r)/f);for(let i=0;i<h.inChannels;++i)for(let o=0;o<h.outChannels;++o){let l=0;for(let u=0;u<h.batchSize;++u)for(let p=t;p<n;++p){let t=e+p*c-w;for(let e=a;e<s;++e){let n=r+e*f-x;l+=y?I.get(u,t,n,i)*S.get(u,p,e,o):I.get(u,i,t,n)*S.get(u,o,p,e)}}b.set(l,e,r,i,o)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};var iR={kernelName:kt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:p}=r;NE([a,s],"conv2dBackpropInput");let d=ka.computeStrides(s.shape),h=ka.computeStrides(a.shape),c=Jf.convertConv2DDataFormat(u),f=Jf.computeConv2DInfo(i,s.shape,o,1,l,p,!1,c),m=new rs(f.inShape,"float32"),g=m.values,y=n.data.get(a.dataId).values,b=n.data.get(s.dataId).values,[x,w,v]=d,{batchSize:k,filterHeight:I,filterWidth:S,inChannels:N,inHeight:T,inWidth:_,outChannels:C,outHeight:E,outWidth:$,strideHeight:A,strideWidth:F}=f;c=f.dataFormat;let R=I-1-f.padInfo.top,D=S-1-f.padInfo.left,M="channelsLast"===c,O=m.strides[0],L=M?m.strides[1]:m.strides[2],z=M?m.strides[2]:1,P=M?1:m.strides[1],B=h[0],W=M?h[1]:h[2],V=M?h[2]:1,U=M?1:h[1];for(let e=0;e<k;++e)for(let t=0;t<N;++t)for(let n=0;n<T;++n){let r=n-R,a=Math.max(0,Math.ceil(r/A)),s=Math.min(E,(I+r)/A);for(let i=0;i<_;++i){let o=i-D,l=Math.max(0,Math.ceil(o/F)),u=Math.min($,(S+o)/F),p=0;for(let n=a;n<s;++n){let a=n*A-r;for(let r=l;r<u;++r){let s=B*e+W*n+V*r,i=x*(I-1-a)+w*(S-1-(r*F-o))+v*t;for(let e=0;e<C;++e){p+=y[s+U*e]*b[i+e]}}}g[O*e+L*n+z*i+P*t]=p}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};var oR={kernelName:It,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;NE([a,s],"conv3d");let u=Jf.computeConv3DInfo(a.shape,s.shape,i,l,o),{filterDepth:p,filterHeight:d,filterWidth:h,dilationDepth:c,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,x=g.top,w=new rs(u.outShape,a.dtype),v=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,I=w.values,S=ka.computeStrides(a.shape),N=ka.computeStrides(s.shape);for(let e=0;e<u.batchSize;++e){let t=e*S[0],n=e*w.strides[0];for(let e=0;e<u.outDepth;++e){let r=n+e*w.strides[1],a=e*u.strideDepth-y;for(let e=0;e<p;++e){let n=a+e*c;if(n<0||n>=u.inDepth)continue;let s=e*N[0],i=t+n*S[1];for(let e=0;e<u.outHeight;++e){let t=r+e*w.strides[2],n=e*u.strideHeight-x;for(let e=0;e<d;++e){let r=n+e*f;if(r<0||r>=u.inHeight)continue;let a=s+e*N[1],o=i+r*S[2];for(let e=0;e<u.outWidth;++e){let n=t+e*u.outChannels,r=e*u.strideWidth-b;for(let e=0;e<h;++e){let t=r+e*m;if(t<0||t>=u.inWidth)continue;let s=a+e*N[2],i=o+t*u.inChannels,l=s;for(let e=0;e<u.inChannels;++e){let t=v[i+e];for(let e=0;e<u.outChannels;++e)I[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};var lR={kernelName:St,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;NE([a,s],"conv3dBackpropFilterV2");let u=ka.computeStrides(a.shape),p=ka.computeStrides(s.shape),d=Jf.computeConv3DInfo(a.shape,l,i,1,o),h=d.strideDepth,c=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new rs(d.filterShape,"float32"),x=b.values,[w,v,k,I]=b.strides,S=n.data.get(s.dataId).values,[N,T,_,C]=p,E=n.data.get(a.dataId).values,[$,A,F,R]=u,D=d.padInfo.front,M=d.padInfo.left,O=d.padInfo.top;for(let e=0;e<m;++e){let t=Math.max(0,Math.ceil((D-e)/h)),n=Math.min(d.outDepth,(d.inDepth+D-e)/h),r=e*w;for(let a=0;a<g;++a){let s=Math.max(0,Math.ceil((O-a)/c)),i=Math.min(d.outHeight,(d.inHeight+O-a)/c),o=a*v+r;for(let r=0;r<y;++r){let l=Math.max(0,Math.ceil((M-r)/f)),u=Math.min(d.outWidth,(d.inWidth+M-r)/f),p=r*k+o;for(let o=0;o<d.inChannels;++o){let m=o*I+p;for(let p=0;p<d.outChannels;++p){let g=0;for(let m=0;m<d.batchSize;++m){let d=m*$,y=m*N;for(let m=t;m<n;++m){let t=(e+m*h-D)*A+d,n=m*T+y;for(let e=s;e<i;++e){let s=(a+e*c-O)*F+t,i=e*_+n;for(let e=l;e<u;++e){let t=e*C+i;g+=E[(r+e*f-M)*R+s+o]*S[t+p]}}}}x[m+p]=g}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};var uR={kernelName:Nt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;NE([a],"conv3dBackpropInputV2");let u=ka.computeStrides(a.shape),p=ka.computeStrides(s.shape),d=Jf.computeConv3DInfo(l,s.shape,o,1,i),h=new rs(d.inShape,"float32"),c=h.values,[f,m,g,y]=h.strides,b=n.data.get(a.dataId).values,[x,w,v,k]=u,I=n.data.get(s.dataId).values,[S,N,T,_]=p,{batchSize:C,filterDepth:E,filterHeight:$,filterWidth:A,inChannels:F,inDepth:R,inHeight:D,inWidth:M,outChannels:O,outDepth:L,outHeight:z,outWidth:P,strideDepth:B,strideHeight:W,strideWidth:V}=d,U=E-1-d.padInfo.front,G=$-1-d.padInfo.top,H=A-1-d.padInfo.left;for(let e=0;e<C;++e)for(let t=0;t<F;++t)for(let n=0;n<R;++n){let r=n-U,a=Math.max(0,Math.ceil(r/B)),s=Math.min(L,(E+r)/B);for(let i=0;i<D;++i){let o=i-G,l=Math.max(0,Math.ceil(o/W)),u=Math.min(z,($+o)/W);for(let p=0;p<M;++p){let d=p-H,h=Math.max(0,Math.ceil(d/V)),C=Math.min(P,(A+d)/V),F=0;for(let n=a;n<s;++n){let a=n*B-r;for(let r=l;r<u;++r){let s=r*W-o;for(let i=h;i<C;++i){let o=x*e+w*n+v*r+k*i,l=S*(E-1-a)+N*($-1-s)+T*(A-1-(i*V-d))+_*t;for(let e=0;e<O;++e){F+=b[o+e]*I[l+e]}}}}c[f*e+m*n+g*i+y*p+t]=F}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},pR=e$(Tt,(e=>Math.cos(e))),dR={kernelName:Tt,backendName:"cpu",kernelFunc:pR},hR=e$(_t,(e=>Math.cosh(e))),cR={kernelName:_t,backendName:"cpu",kernelFunc:hR};var fR={kernelName:$t,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[p,d,h,c]=a.shape,f=s.shape[0],[m,g]=o,y=mo([f,m,g,c],"float32"),b=n.data.get(s.dataId).values,x=n.data.get(i.dataId).values,w=n.data.get(a.dataId).values,v=ka.computeStrides(a.shape),k=ka.computeStrides(y.shape);for(let e=0;e<f;e++){let t=4*e,n=b[t],r=b[t+1],a=b[t+2],s=b[t+3],i=x[e];if(i>=p)continue;let o=m>1?(a-n)*(d-1)/(m-1):0,f=g>1?(s-r)*(h-1)/(g-1):0;for(let t=0;t<m;t++){let p=m>1?n*(d-1)+t*o:.5*(n+a)*(d-1);if(p<0||p>d-1)for(let n=0;n<g;n++)for(let r=0;r<c;r++){let a=r+n*k[2]+t*k[1]+e*k[0];y.values[a]=u}else if("bilinear"===l){let n=Math.floor(p),a=Math.ceil(p),o=p-n;for(let l=0;l<g;l++){let p=g>1?r*(h-1)+l*f:.5*(r+s)*(h-1);if(p<0||p>h-1){for(let n=0;n<c;n++){let r=n+l*k[2]+t*k[1]+e*k[0];y.values[r]=u}continue}let d=Math.floor(p),m=Math.ceil(p),b=p-d;for(let r=0;r<c;r++){let s=r+d*v[2]+n*v[1]+i*v[0],u=w[s];s=r+m*v[2]+n*v[1]+i*v[0];let p=w[s];s=r+d*v[2]+a*v[1]+i*v[0];let h=w[s];s=r+m*v[2]+a*v[1]+i*v[0];let c=u+(p-u)*b,f=h+(w[s]-h)*b;s=r+l*k[2]+t*k[1]+e*k[0],y.values[s]=c+(f-c)*o}}}else for(let n=0;n<g;++n){let a=g>1?r*(h-1)+n*f:.5*(r+s)*(h-1);if(a<0||a>h-1){for(let r=0;r<c;r++){let a=r+n*k[2]+t*k[1]+e*k[0];y.values[a]=u}continue}let o=Math.round(a),l=Math.round(p);for(let r=0;r<c;r++){let a=r+o*v[2]+l*v[1]+i*v[0],s=r+n*k[2]+t*k[1]+e*k[0];y.values[s]=w[a]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};var mR={kernelName:Ct,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;NE(a,"cumprod");let l=Jf.getAxesPermutation([s],a.shape.length),u=a;null!=l&&(u=nA({inputs:{x:a},backend:n,attrs:{perm:l}}));let p=Jf.getInnerMostAxes(1,a.shape.length)[0];if(p!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${p}`);let d=gs(u.dtype,"int32"),h=ka.makeOnesTypedArray(ka.sizeFromShape(u.shape),d),c=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<c.length;e+=f)for(let t=0;t<f;t++){let n=m(e,t);if(0===t)h[n]=i?1:c[n];else{let r=m(e,t-1);h[n]=i?c[r]*h[r]:c[n]*h[r]}}let g=n.makeTensorInfo(u.shape,d,h);if(null!=l){let e=nA({inputs:{x:g},backend:n,attrs:{perm:Jf.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};var gR={kernelName:Et,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;NE(a,"cumsum");let l=Jf.getAxesPermutation([s],a.shape.length),u=a;null!=l&&(u=nA({inputs:{x:a},backend:n,attrs:{perm:l}}));let p=Jf.getInnerMostAxes(1,a.shape.length)[0];if(p!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${p}`);let d=gs(u.dtype,"int32"),h=ka.makeZerosTypedArray(ka.sizeFromShape(u.shape),d),c=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<c.length;e+=f)for(let t=0;t<f;t++){let n=m(e,t);if(0===t)h[n]=i?0:c[n];else{let r=m(e,t-1);h[n]=i?c[r]+h[r]:c[n]+h[r]}}let g=n.makeTensorInfo(u.shape,d,h);if(null!=l){let e=nA({inputs:{x:g},backend:n,attrs:{perm:Jf.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};var yR={kernelName:At,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){let e=KE(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,e)}if(2===a.shape.length){let e=XE(n.bufferSync(a),n.bufferSync(s),i,o);return n.makeTensorInfo(e.shape,s.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};var bR={kernelName:Ft,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r;ka.assert("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));let o=a.shape[0],l=a.shape[1],u=a.shape[2],p=a.shape[3],d=l*s,h=u*s,c=p/(s*s),f=n.data.get(a.dataId).values,m=new Float32Array(o*d*h*c),g=0;for(let e=0;e<o;++e)for(let t=0;t<d;++t){let n=Math.floor(t/s),r=t%s;for(let t=0;t<h;++t){let a=Math.floor(t/s),i=(r*s+t%s)*c;for(let t=0;t<c;++t){let r=t+i+p*(a+u*(n+l*e));m[g++]=f[r]}}}return n.makeTensorInfo([o,d,h,c],a.dtype,m)}};function xR(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;NE([a,s],"depthwiseConv2DNative");let p=ka.computeStrides(a.shape),d=ka.computeStrides(s.shape),h=l;null==h&&(h=[1,1]),ka.assert(Jf.eitherStridesOrDilationsAreOne(i,h),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`));let c=Jf.computeConv2DInfo(a.shape,s.shape,i,h,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=c,x=b.left,w=b.top,v=c.outChannels/c.inChannels,k=new rs(c.outShape,a.dtype),I=n.data.get(a.dataId).values,S=n.data.get(s.dataId).values,N=k.values;for(let e=0;e<c.batchSize;++e){let t=e*p[0],n=e*k.strides[0];for(let e=0;e<c.outHeight;++e){let r=n+e*k.strides[1],a=e*c.strideHeight-w;for(let e=0;e<f;++e){let n=a+e*g;if(n<0||n>=c.inHeight)continue;let s=e*d[0],i=t+n*p[1];for(let e=0;e<c.outWidth;++e){let t=r+e*k.strides[2],n=e*c.strideWidth-x;for(let e=0;e<m;++e){let r=n+e*y;if(r<0||r>=c.inWidth)continue;let a=s+e*d[1],o=i+r*c.inChannels,l=t,u=a;for(let e=0;e<c.inChannels;++e){let t=I[o+e];for(let e=0;e<v;++e)N[l+e]+=t*S[u+e];l+=v,u+=v}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var wR={kernelName:Rt,backendName:"cpu",kernelFunc:xR};var vR={kernelName:Dt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:p}=r;NE([a,s],"depthwiseConv2dNativeBackpropFilter");let d=Jf.computeConv2DInfo(a.shape,p,i,o,l,u,!0),{strideHeight:h,strideWidth:c,filterHeight:f,filterWidth:m}=d,g=new rs(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,x=d.outChannels/d.inChannels,w=n.data.get(a.dataId).values,v=new rs(a.shape,a.dtype,w),k=n.data.get(s.dataId).values,I=new rs(s.shape,s.dtype,k);for(let e=0;e<f;++e){let t=Math.max(0,Math.ceil((b-e)/h)),n=Math.min(d.outHeight,(d.inHeight+b-e)/h);for(let r=0;r<m;++r){let a=Math.max(0,Math.ceil((y-r)/c)),s=Math.min(d.outWidth,(d.inWidth+y-r)/c);for(let i=0;i<d.outChannels;++i){let o=Math.trunc(i/x),l=i%x,u=0;for(let l=0;l<d.batchSize;++l)for(let p=t;p<n;++p){let t=e+p*h-b;for(let e=a;e<s;++e){let n=r+e*c-y;u+=v.get(l,t,n,o)*I.get(l,p,e,i)}}g.set(u,e,r,o,l)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};var kR={kernelName:Mt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:p}=r;NE([a,s],"depthwiseConv2DNativeBackpropInput");let d=ka.computeStrides(a.shape),h=ka.computeStrides(s.shape),c=Jf.computeConv2DInfo(p,s.shape,i,o,l,u,!0),f=new rs(c.inShape,"float32"),m=f.values,[g,y,b]=f.strides,x=n.data.get(a.dataId).values,[w,v,k]=d,I=n.data.get(s.dataId).values,[S,N,T]=h,{batchSize:_,filterHeight:C,filterWidth:E,inChannels:$,inHeight:A,inWidth:F,outChannels:R,outHeight:D,outWidth:M,strideHeight:O,strideWidth:L}=c,z=C-1-c.padInfo.top,P=E-1-c.padInfo.left,B=R/$;for(let e=0;e<_;++e)for(let t=0;t<$;++t)for(let n=0;n<A;++n){let r=n-z,a=Math.max(0,Math.ceil(r/O)),s=Math.min(D,(C+r)/O);for(let i=0;i<F;++i){let o=i-P,l=Math.max(0,Math.ceil(o/L)),u=Math.min(M,(E+o)/L),p=0;for(let n=a;n<s;++n){let a=n*O-r;for(let r=l;r<u;++r){let s=w*e+v*n+k*r,i=S*(C-1-a)+N*(E-1-(r*L-o))+T*t;for(let e=0;e<B;++e){p+=x[s+(t*B+e)]*I[i+e]}}}m[g*e+y*n+b*i+t]=p}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};var IR={kernelName:Ot,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=ka.sizeFromShape(r.shape),s=n.data.get(r.dataId).values,i=mo([a,a],r.dtype),o=i.values;for(let e=0;e<s.length;e++)o[e*a+e]=s[e];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}},SR={kernelName:Lt,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a}=e,{strides:s,pad:i,dilations:o}=n,l=t,u=l.data.get(r.dataId).values,p=r.shape.length,d=l.data.get(a.dataId).values,h=a.shape.length,{batchSize:c,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:w,strideWidth:v,filterHeight:k,filterWidth:I,dilationHeight:S,dilationWidth:N,outShape:T}=Jf.computeDilation2DInfo(r.shape,a.shape,s,i,"NHWC",o),_=ka.sizeFromShape(T),C=T.length,E=ka.getArrayFromDType(r.dtype,_);for(let e=0;e<c;++e)for(let t=0;t<y;++t){let n=t*w-x.top;for(let s=0;s<b;++s){let i=s*v-x.left;for(let o=0;o<g;++o){let l=Number.MIN_SAFE_INTEGER;for(let t=0;t<k;++t){let s=n+t*S;if(s>=0&&s<f)for(let n=0;n<I;++n){let c=i+n*N;if(c>=0&&c<m){let i=ka.locToIndex([e,s,c,o],p,ka.computeStrides(r.shape)),f=ka.locToIndex([t,n,o],h,ka.computeStrides(a.shape)),m=u[i]+d[f];m>l&&(l=m)}}}E[ka.locToIndex([e,t,s,o],C,ka.computeStrides(T))]=l}}}return{dataId:l.write(ka.toTypedArray(E,r.dtype),T,r.dtype),shape:T,dtype:r.dtype}}},NR={kernelName:Pt,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=t,p=ka.toNestedArray(r.shape,u.data.get(r.dataId).values),d=ka.toNestedArray(a.shape,u.data.get(a.dataId).values),{batchSize:h,inHeight:c,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:w,filterHeight:v,filterWidth:k,dilationHeight:I,dilationWidth:S,outShape:N}=Jf.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);ka.assert(s.rank===N.length,(()=>`Error in ${Pt}, dy must have the same rank as output ${N.length}, but got ${s.rank}`));let T=ka.toNestedArray(N,u.data.get(s.dataId).values),_=ka.makeZerosNestedTypedArray(a.shape,a.dtype);for(let e=0;e<h;++e)for(let t=0;t<g;++t){let n=t*x-b.top;for(let r=0;r<y;++r){let a=r*w-b.left;for(let s=0;s<m;++s){let i=Number.MIN_SAFE_INTEGER,o=0,l=0;for(let t=0;t<v;++t){let r=n+t*I;if(r>=0&&r<c)for(let n=0;n<k;++n){let u=a+n*S;if(u>=0&&u<f){let a=p[e][r][u][s]+d[t][n][s];a>i&&(i=a,o=t,l=n)}}}_[o][l][s]+=T[e][t][r][s]}}}return{dataId:u.write(ka.toTypedArray(_,r.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},TR={kernelName:zt,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=t,p=ka.toNestedArray(r.shape,u.data.get(r.dataId).values),d=ka.toNestedArray(a.shape,u.data.get(a.dataId).values),{batchSize:h,inHeight:c,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:w,filterHeight:v,filterWidth:k,dilationHeight:I,dilationWidth:S,outShape:N}=Jf.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);ka.assert(s.rank===N.length,(()=>`Error in ${zt}, dy must have the same rank as output ${N.length}, but got ${s.rank}`));let T=ka.toNestedArray(N,u.data.get(s.dataId).values),_=ka.makeZerosNestedTypedArray(r.shape,r.dtype);for(let e=0;e<h;++e)for(let t=0;t<g;++t){let n=t*x-b.top;for(let r=0;r<y;++r){let a=r*w-b.left;for(let s=0;s<m;++s){let i=Number.MIN_SAFE_INTEGER,o=n<0?0:n,l=a<0?0:a;for(let t=0;t<v;++t){let r=n+t*I;if(r>=0&&r<c)for(let n=0;n<k;++n){let u=a+n*S;if(u>=0&&u<f){let a=p[e][r][u][s]+d[t][n][s];a>i&&(i=a,o=r,l=u)}}}_[e][o][l][s]+=T[e][t][r][s]}}}return{dataId:u.write(ka.toTypedArray(_,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};var _R={kernelName:Bt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{canvas:s,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(null==l?void 0:l.alpha)||1,p=(null==o?void 0:o.contextType)||"2d";if("2d"!==p)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let d=s.getContext(p,(null==o?void 0:o.contextAttributes)||{});if(null==d)throw new Error(`Could not get the context with ${p} type.`);let[h,c]=a.shape.slice(0,2),f=2===a.shape.length?1:a.shape[2],m=n.data.get(a.dataId).values,g="float32"===a.dtype?255:1,y=new Uint8ClampedArray(c*h*4);for(let e=0;e<h*c;++e){let t=[0,0,0,255*u];for(let n=0;n<f;n++){let r=m[e*f+n];if("float32"===a.dtype){if(r<0||r>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${r}.`)}else if("int32"===a.dtype&&(r<0||r>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${r}.`);1===f?(t[0]=r*g,t[1]=r*g,t[2]=r*g):t[n]=r*g}let n=4*e;y[n+0]=Math.round(t[0]),y[n+1]=Math.round(t[1]),y[n+2]=Math.round(t[2]),y[n+3]=Math.round(t[3])}s.width=c,s.height=h;let b=new ImageData(y,c,h);return d.putImageData(b,0,0),a}};function CR(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a;NE(s,"sum"),t="bool"===s.dtype?BE({inputs:{x:s},backend:r,attrs:{dtype:"int32"}}):ME({inputs:{x:s},backend:r});let l=t.shape.length,u=ka.parseAxisParam(i,t.shape),p=Jf.getAxesPermutation(u,l),d=u,h=t;null!=p&&(h=nA({inputs:{x:t},backend:r,attrs:{perm:p}}),d=Jf.getInnerMostAxes(d.length,l)),Jf.assertAxesAreInnerMostDims("sum",d,h.shape.length);let[c,f]=Jf.computeOutAndReduceShapes(h.shape,d),m=DE(r,c,Jf.upcastType(h.dtype,"int32")),g=ka.sizeFromShape(f),y=r.data.get(m.dataId).values,b=r.data.get(h.dataId).values;for(let e=0;e<y.length;++e){let t=e*g,n=0;for(let e=0;e<g;++e)n+=b[t+e];y[e]=n}if(o){let e=m;m=fF({inputs:{x:m},backend:r,attrs:{shape:Jf.expandShapeToKeepDim(m.shape,u)}}),r.disposeIntermediateTensorInfo(e)}return r.disposeIntermediateTensorInfo(t),null!=p&&r.disposeIntermediateTensorInfo(h),m}var ER={kernelName:Er,backendName:"cpu",kernelFunc:CR};var $R={kernelName:Vt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=Jf.decodeEinsumEquation(a,s.length);Jf.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:p}=Jf.getEinsumComputePath(o,l),d=p.length,h=null,c=i.length,f=[];for(let e=0;e<d;++e){for(let t of p[e]){let e,{permutationIndices:r,expandDims:a}=Jf.getEinsumPermutation(c,l[t]);Jf.isIdentityPermutation(r)?e=s[t]:(e=nA({inputs:{x:s[t]},backend:n,attrs:{perm:r}}),f.push(e));let i=e.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);ka.arraysEqual(e.shape,i)||(e=fF({inputs:{x:e},backend:n,attrs:{shape:i}}),f.push(e)),null===h?h=e:(h=K$({inputs:{a:e,b:h},backend:n}),f.push(h))}e<d-1&&(u[e]>=0&&(h=CR({inputs:{x:h},backend:n,attrs:{axis:u[e]-(i.length-c),keepDims:!1}}),f.push(h)),c--)}for(let e of f)e!==h&&n.disposeIntermediateTensorInfo(e);return h}};var AR={kernelName:Gt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t;NE([r,a],"eluGrad");let s=new Float32Array(ka.sizeFromShape(a.shape)),i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let e=0;e<i.length;++e){let t=i[e];s[e]=t>=0?o[e]:o[e]*(t+1)}return n.makeTensorInfo(a.shape,"float32",s)}},FR=Jf.ERF_P,RR=Jf.ERF_A1,DR=Jf.ERF_A2,MR=Jf.ERF_A3,OR=Jf.ERF_A4,LR=Jf.ERF_A5,zR=e$(Ht,(e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+FR*n);return t*(1-((((LR*r+OR)*r+MR)*r+DR)*r+RR)*r*Math.exp(-n*n))})),PR={kernelName:Ht,backendName:"cpu",kernelFunc:zR};function BR(e){let{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:s}=r,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(ka.assert(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),fF({inputs:{x:a},backend:n,attrs:{shape:o}})}var WR={kernelName:Kt,backendName:"cpu",kernelFunc:BR},VR=AE(((e,t)=>e/t)),UR=VE(Wt,VR),GR={kernelName:Wt,backendName:"cpu",kernelFunc:UR};function HR(e,t,n){let r=e.shape,a=r[0],s=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[a,s],p=ka.sizeFromShape(u),d=ka.getTypedArrayFromDType("float32",p),h=ka.getTypedArrayFromDType("float32",p);for(let e=0;e<a;e++){let r=TA({inputs:{x:o},backend:n,attrs:{begin:[e,0],size:[1,s]}}),a=TA({inputs:{x:l},backend:n,attrs:{begin:[e,0],size:[1,s]}}),i=FE({inputs:{real:r,imag:a},backend:n}),{real:u,imag:p}=jR(i,t,n),c=Jf.mergeRealAndImagArrays(u,p);for(let t=0;t<s;t++){let n=Jf.getComplexWithIndex(c,t);d[e*s+t]=n.real,h[e*s+t]=n.imag}n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i)}let c=n.makeTensorInfo(u,"float32",d),f=n.makeTensorInfo(u,"float32",h),m=FE({inputs:{real:c,imag:f},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),m}function jR(e,t,n){let r=ka.sizeFromShape(e.shape),a=n.data.get(e.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,i=n.data.get(a.complexTensorInfos.imag.dataId).values;if(function(e){return 0==(e&e-1)}(r)){let a=qR(s,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){let e=n.makeTensorInfo(o,"float32",a.real),t=n.makeTensorInfo(o,"float32",a.imag),s=n.makeTensorInfo([],"float32",ka.createScalarValue(r,"float32")),i=ME({inputs:{x:s},backend:n}),l=GR.kernelFunc({inputs:{a:e,b:s},backend:n}),u=GR.kernelFunc({inputs:{a:t,b:i},backend:n}),p=n.data.get(l.dataId).values,d=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:p,imag:d}}return a}{let e=function(e,t,n){let r=new Float32Array(2*t);for(let a=0;a<t;a++){let s=0,i=0;for(let r=0;r<t;r++){let o=Jf.exponent(a*r,t,n),l=Jf.getComplexWithIndex(e,r);s+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(s/=t,i/=t),Jf.assignToTypedArray(r,s,i,a)}return r}(Jf.mergeRealAndImagArrays(s,i),r,t);return Jf.splitRealAndImagArrays(e)}}function qR(e,t,n,r,a){if(1===n)return{real:e,imag:t};let s=Jf.mergeRealAndImagArrays(e,t),i=n/2,o=Jf.complexWithEvenIndex(s),l=o.real,u=o.imag,p=[l.length],d=a.makeTensorInfo(p,"float32",l),h=a.makeTensorInfo(p,"float32",u),c=FE({inputs:{real:d,imag:h},backend:a}),f=Jf.complexWithOddIndex(s),m=f.real,g=f.imag,y=[m.length],b=a.makeTensorInfo(y,"float32",m),x=a.makeTensorInfo(y,"float32",g),w=FE({inputs:{real:b,imag:x},backend:a}),v=qR(l,u,i,r,a),k=v.real,I=v.imag,S=[k.length],N=a.makeTensorInfo(S,"float32",k),T=a.makeTensorInfo(S,"float32",I),_=FE({inputs:{real:N,imag:T},backend:a}),C=qR(m,g,i,r,a),E=C.real,$=C.imag,A=[E.length],F=a.makeTensorInfo(A,"float32",E),R=a.makeTensorInfo(A,"float32",$),D=FE({inputs:{real:F,imag:R},backend:a}),M=Jf.exponents(n,r),O=[M.real.length],L=a.makeTensorInfo(O,"float32",M.real),z=a.makeTensorInfo(O,"float32",M.imag),P=FE({inputs:{real:L,imag:z},backend:a}),B=K$({inputs:{a:P,b:D},backend:a}),W=jE({inputs:{a:_,b:B},backend:a}),V=KA({inputs:{a:_,b:B},backend:a}),U=LE({inputs:{input:W},backend:a}),G=LE({inputs:{input:V},backend:a}),H=QF({inputs:{input:W},backend:a}),j=QF({inputs:{input:V},backend:a}),q=tR({inputs:[U,G],backend:a,attrs:{axis:0}}),K=tR({inputs:[H,j],backend:a,attrs:{axis:0}}),X=a.data.get(q.dataId).values,Y=a.data.get(K.dataId).values;return a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(w),a.disposeIntermediateTensorInfo(N),a.disposeIntermediateTensorInfo(T),a.disposeIntermediateTensorInfo(_),a.disposeIntermediateTensorInfo(F),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(D),a.disposeIntermediateTensorInfo(L),a.disposeIntermediateTensorInfo(z),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(K),{real:X,imag:Y}}var KR={kernelName:Yt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t,a=ka.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=fF({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),o=HR(i,!1,n),l=fF({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}};function XR(e){let{backend:t,attrs:n}=e,{shape:r,value:a,dtype:s}=n,i=s||ka.inferDtype(a),o=ka.getArrayFromDType(i,ka.sizeFromShape(r));return function(e,t,n){e.fill(t)}(o,a),t.makeTensorInfo(r,i,o)}var YR={kernelName:Zt,backendName:"cpu",kernelFunc:XR};var ZR={kernelName:Jt,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,a=n,s=ka.getTypedArrayFromDType(r.dtype,ka.sizeFromShape(r.shape)),[i,o,l,u]=r.shape,p=a.data.get(r.dataId).values;for(let e=0;e<i;e++){let t=e*l*o*u;for(let e=0;e<o;e++){let n=e*(l*u);for(let e=0;e<l;e++){let r=e*u;for(let a=0;a<u;a++){let i=Math.round(l-e-1),o=t+n+r+a,d=p[o];if(i>=0&&i<l){d=p[t+n+i*u+a]}s[o]=d}}}}return{dataId:a.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};var JR={kernelName:oa,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:h,activation:c,leakyreluAlpha:f}=r,m=rR({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:h}});if(i){let e=m;if("NCHW"===p&&1===i.shape.length&&1!==i.shape[0]){let e=fF({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=jE({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=jE({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(c){let e=m;if("NCHW"===p&&"prelu"===c&&1===o.shape.length&&1!==o.shape[0]){let e=fF({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=cF(n,m,c,e,f),n.disposeIntermediateTensorInfo(e)}else m=cF(n,m,c,o,f);n.disposeIntermediateTensorInfo(e)}return m}};var QR={kernelName:la,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:h,activation:c,leakyreluAlpha:f}=r,m=xR({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:h}});if(i){let e=m;m=jE({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(c){let e=m;m=cF(n,m,c,o,f),n.disposeIntermediateTensorInfo(e)}return m}};var eD={kernelName:rn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=ka.sizeFromShape(r.shape),i=a.shape,o=i[i.length-1],[l,u,p,d]=Jf.prepareAndValidate(r,a);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);let h=v$(n.data.get(a.dataId).values,n.bufferSync(r),r.dtype,u,o,p,d,r.shape,s);return n.makeTensorInfo(l,r.dtype,h.values)}};var tD={kernelName:nn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r;NE([a,s],"gatherV2");let l=ka.parseAxisParam(i,a.shape)[0],u=n.data.get(s.dataId).values,p=a.shape[l];for(let e=0;e<u.length;++e){let t=u[e];ka.assert(t<=p-1&&t>=0,(()=>`GatherV2: the index value ${t} is not in [0, ${p-1}]`))}let d=o;null==o&&(d=0);let h=ka.sizeFromShape(s.shape),c=Jf.segment_util.collectGatherOpShapeInfo(a,s,l,d),f=fF({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),m=fF({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,h/c.batchSize]}}),g=[c.batchSize,c.outerSize,h/c.batchSize,c.sliceSize],y=n.bufferSync(m),b=k$(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(c.outputShape,b.dtype,b.values)}};var nD={kernelName:ln,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t,a=ka.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=fF({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),o=HR(i,!0,n),l=fF({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}},rD=e$(pn,(e=>Number.isFinite(e)?1:0),"bool"),aD={kernelName:pn,backendName:"cpu",kernelFunc:rD},sD=e$(dn,(e=>Math.abs(e)===1/0?1:0),"bool"),iD={kernelName:dn,backendName:"cpu",kernelFunc:sD},oD=e$(hn,(e=>Number.isNaN(e)?1:0),"bool"),lD={kernelName:hn,backendName:"cpu",kernelFunc:oD};var uD={kernelName:gn,backendName:"cpu",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=M$(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}},pD=e$(bn,(e=>Math.log1p(e))),dD={kernelName:bn,backendName:"cpu",kernelFunc:pD},hD=AE(((e,t)=>e&&t)),cD=VE(xn,hD,null,"bool"),fD={kernelName:xn,backendName:"cpu",kernelFunc:cD},mD=e$(wn,(e=>e?0:1),"bool"),gD={kernelName:wn,backendName:"cpu",kernelFunc:mD},yD=AE(((e,t)=>e||t)),bD=VE(vn,yD,null,"bool"),xD={kernelName:vn,backendName:"cpu",kernelFunc:bD};var wD={kernelName:Nn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;NE(a,"LRN");let u=a.shape[3],p=u-1,d=n.data.get(a.dataId).values,h=ka.sizeFromShape(a.shape),c=new Float32Array(h);function f(e){let t=e%u,n=e-t+Math.max(0,t-s),r=e-t+Math.min(t+s,p),a=0;for(;n<=r;n++){let e=d[n];a+=e*e}return a}for(let e=0;e<h;e++){let t=f(e),n=d[e]*Math.pow(i+o*t,-l);c[e]=n}return n.makeTensorInfo(a.shape,a.dtype,c)}};var vD={kernelName:Tn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:p}=r;NE(i,"LRNGrad");let d=ka.sizeFromShape(i.shape),h=i.shape[3],c=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(d),y=d;for(let e=0;e<y;e++){let t=e%h,n=e-t+Math.max(0,t-o),r=e-t+Math.min(h,t+o+1),a=0;for(let e=n;e<r;e++)a+=Math.pow(f[e],2);a=u*a+l;for(let t=n;t<r;t++){let n=-2*u*p*f[t]*m[e]/a;e===t&&(n+=Math.pow(a,-p)),n*=c[e],g[t]+=n}}return n.makeTensorInfo(i.shape,a.dtype,g)}};function kD(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=n,l=a.shape,u=l.length,p=ka.parseAxisParam(s,l),d=p,h=Jf.getAxesPermutation(d,u),c=o.data.get(a.dataId).values;if(null!=h){let e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[h[t]];c=tA(c,l,a.dtype,h,e),d=Jf.getInnerMostAxes(d.length,u),l=e}NE(a,"max"),Jf.assertAxesAreInnerMostDims("max",d,u);let[f,m]=Jf.computeOutAndReduceShapes(l,d),g=P$(c,ka.sizeFromShape(m),f,a.dtype),y=o.write(g,f,a.dtype),b=f;return i&&(b=Jf.expandShapeToKeepDim(f,p)),{dataId:y,shape:b,dtype:a.dtype}}var ID={kernelName:Cn,backendName:"cpu",kernelFunc:kD};var SD={kernelName:$n,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;NE(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;ka.assert(Jf.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));let u,p=Jf.computePool2DInfo(a.shape,s,i,1,o,l);if(1===p.filterWidth&&1===p.filterHeight&&ka.arraysEqual(p.inShape,p.outShape))u=ME({inputs:{x:a},backend:n});else{let e=n.data.get(a.dataId).values,t=ka.computeStrides(a.shape),r=PF(e,a.shape,a.dtype,t,p,"max");u=n.makeTensorInfo(p.outShape,a.dtype,r.values)}return u}};var ND={kernelName:Fn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;NE(a,"maxPool3d");let p=Jf.computePool3DInfo(a.shape,s,i,1,o,l,u),d=WF(n.data.get(a.dataId).values,a.shape,a.dtype,ka.computeStrides(a.shape),p,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}};var TD={kernelName:Rn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;NE([a,s],"maxPool3DGrad");let p=Jf.computePool3DInfo(s.shape,i,o,1,l,u),d=function(e,t){let n=mo(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,p=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,c=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*r-h,x=b;for(;x<0;)x+=i;let w=Math.min(t.inDepth,u+b);for(let r=0;r<t.outHeight;++r){let u=r*a-c,h=u;for(;h<0;)h+=o;let v=Math.min(t.inHeight,p+u);for(let a=0;a<t.outWidth;++a){let c=a*s-f,k=c;for(;k<0;)k+=l;let I=Math.min(t.inWidth,d+c),S=Number.NEGATIVE_INFINITY,N=-1;for(let t=x;t<w;t+=i){let n=t-b;for(let r=h;r<v;r+=o){let a=r-u;for(let s=k;s<I;s+=l){let i=s-c,o=e.get(m,t,r,s,g);o>=S&&(S=o,N=n*p*d+a*p+i)}}}n.set(N,m,y,r,a,g)}}}return n}(n.bufferSync(s),p),h=p.strideDepth,c=p.strideHeight,f=p.strideWidth,m=p.dilationDepth,g=p.dilationHeight,y=p.dilationWidth,b=p.effectiveFilterDepth,x=p.effectiveFilterHeight,w=p.effectiveFilterWidth,v=b-1-p.padInfo.front,k=w-1-p.padInfo.left,I=x-1-p.padInfo.top,S=mo(s.shape,"float32"),N=n.bufferSync(a);for(let e=0;e<p.batchSize;++e)for(let t=0;t<p.inChannels;++t)for(let n=0;n<p.inDepth;++n)for(let r=0;r<p.inHeight;++r)for(let a=0;a<p.inWidth;++a){let s=n-v,i=r-I,o=a-k,l=0;for(let n=0;n<b;n+=m){let r=(s+n)/h;if(!(r<0||r>=p.outDepth||Math.floor(r)!==r))for(let a=0;a<x;a+=g){let s=(i+a)/c;if(!(s<0||s>=p.outHeight||Math.floor(s)!==s))for(let i=0;i<w;i+=y){let u=(o+i)/f;if(u<0||u>=p.outWidth||Math.floor(u)!==u)continue;let h=b*x*w-1-d.get(e,r,s,u,t)===n*x*w+a*w+i?1:0;0!==h&&(l+=N.get(e,r,s,u,t)*h)}}}S.set(l,e,n,r,a,t)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};var _D={kernelName:An,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;NE([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:p,dimRoundingMode:d}=r,h=Jf.computePool2DInfo(o.shape,l,u,1,p,d),c=n.data.get(o.dataId).values,f=mo(h.outShape,o.dtype,BF(c,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,x=h.effectiveFilterHeight,w=h.effectiveFilterWidth,v=w-1-h.padInfo.left,k=x-1-h.padInfo.top,I=mo(o.shape,"float32"),S=n.data.get(a.dataId).values,N=mo(a.shape,"float32",S);for(let e=0;e<h.batchSize;++e)for(let t=0;t<h.inChannels;++t)for(let n=0;n<h.inHeight;++n)for(let r=0;r<h.inWidth;++r){let a=n-k,s=r-v,i=0;for(let n=0;n<x;n+=y){let r=(a+n)/m;if(!(r<0||r>=h.outHeight||Math.floor(r)!==r))for(let a=0;a<w;a+=b){let o=(s+a)/g;if(o<0||o>=h.outWidth||Math.floor(o)!==o)continue;let l=x*w-1-f.get(e,r,o,t)===n*w+a?1:0;0!==l&&(i+=N.get(e,r,o,t)*l)}}I.set(i,e,n,r,t)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};var CD={kernelName:Dn,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;NE(r,"MaxPoolWithArgmax");let u=l.data.get(r.dataId).values,p=Jf.computePool2DInfo(r.shape,a,s,[1,1],i),[d,h]=function(e,t,n,r,a){let s=PF(e,0,n,ka.computeStrides(t),a,"max"),i=BF(e,t,n,a,!0,r);return[s.values,i.values]}(u,r.shape,r.dtype,o,p),c=l.write(d,p.outShape,r.dtype),f=l.write(h,p.outShape,r.dtype);return[{dataId:c,shape:p.outShape,dtype:r.dtype},{dataId:f,shape:p.outShape,dtype:"int32"}]}};var ED={kernelName:Mn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=ka.parseAxisParam(s,a.shape),l=Jf.computeOutAndReduceShapes(a.shape,o)[1],u=ka.sizeFromShape(l),p=[],d=n.makeTensorInfo([],"float32",new Float32Array([u]));p.push(d);let h=BE({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});p.push(h);let c=UR({inputs:{a:h,b:d},backend:n});p.push(c);let f=CR({inputs:{x:c},backend:n,attrs:{axis:s,keepDims:i}});return p.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};var $D={kernelName:On,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;NE(a,"min");let o=ka.parseAxisParam(s,a.shape),l=o,u=Jf.getAxesPermutation(l,a.shape.length),p=a;null!=u&&(p=nA({inputs:{x:a},backend:n,attrs:{perm:u}}),l=Jf.getInnerMostAxes(l.length,a.shape.length)),Jf.assertAxesAreInnerMostDims("min",l,p.shape.length);let[d,h]=Jf.computeOutAndReduceShapes(p.shape,l),c=ka.sizeFromShape(h),f=ka.makeZerosTypedArray(ka.sizeFromShape(d),p.dtype),m=n.data.get(p.dataId).values;for(let e=0;e<f.length;++e){let t=e*c,n=m[t];for(let e=0;e<c;++e){let r=m[t+e];(Number.isNaN(r)||r<n)&&(n=r)}f[e]=n}null!=u&&n.disposeIntermediateTensorInfo(p);let g=n.makeTensorInfo(d,p.dtype,f);if(i){let e=fF({inputs:{x:g},backend:n,attrs:{shape:Jf.expandShapeToKeepDim(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};var AD={kernelName:zn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r;NE(a,"mirrorPad");let o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=s.map(((e,t)=>e[0]+a.shape[t])),p="reflect"===i?0:1,d=n.data.get(a.dataId).values,h=a.shape.length,c=ka.computeStrides(a.shape),f=ka.sizeFromShape(o),m=o.length,g=ka.computeStrides(o),y=ka.getTypedArrayFromDType(a.dtype,f);for(let e=0;e<f;e++){let t=ka.indexToLoc(e,m,g);for(let e=0;e<m;e++)t[e]<l[e]?t[e]=2*l[e]-t[e]-p:t[e]>=u[e]&&(t[e]=2*(u[e]-1)-t[e]+p);t=t.map(((e,t)=>e-l[t]));let n=ka.locToIndex(t,h,c);y[e]=d[n]}return{dataId:n.write(y,o,a.dtype),shape:o,dtype:a.dtype}}},FD=AE(((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),RD=VE(Pn,FD),DD={kernelName:Pn,backendName:"cpu",kernelFunc:RD},MD=y(E());function OD(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=a.shape.length,o=s;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=ka.parseAxisParam([o],a.shape),u=kD({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),p=Jf.expandShapeToKeepDim(u.shape,l),d=fF({inputs:{x:u},backend:n,attrs:{shape:p}}),h=KA({inputs:{a:a,b:d},backend:n}),c=p$({inputs:{x:h},backend:n}),f=CR({inputs:{x:c},backend:n,attrs:{axis:l,keepDims:!1}}),m=fF({inputs:{x:f},backend:n,attrs:{shape:p}}),g=UR({inputs:{a:c,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var LD={kernelName:Fr,backendName:"cpu",kernelFunc:OD};var zD={kernelName:Bn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;NE(a,"multinomial");let l=o?a:OD({inputs:{logits:a},backend:n,attrs:{dim:-1}}),u=l.shape[0],p=l.shape[1],d=n.data.get(l.dataId).values,h=[u,s],c=ka.makeZerosTypedArray(ka.sizeFromShape(h),"int32");for(let e=0;e<u;++e){let t=e*p,n=new Float32Array(p-1);n[0]=d[t];for(let e=1;e<n.length;++e)n[e]=n[e-1]+d[t+e];let r=MD.alea(i.toString()),a=e*s;for(let e=0;e<s;++e){let t=r();c[a+e]=n.length;for(let r=0;r<n.length;r++)if(t<n[r]){c[a+e]=r;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(h,"int32",c)}},PD=ag.nonMaxSuppressionV3Impl;var BD={kernelName:Gn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;NE(a,"NonMaxSuppression");let u=n.data.get(a.dataId).values,p=n.data.get(s.dataId).values,{selectedIndices:d}=PD(u,p,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},WD=ag.nonMaxSuppressionV4Impl;var VD={kernelName:Hn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;NE(a,"NonMaxSuppressionPadded");let p=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:h,validOutputs:c}=WD(p,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([c]))]}},UD=ag.nonMaxSuppressionV5Impl;var GD={kernelName:jn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;NE(a,"NonMaxSuppressionWithScore");let p=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,h=i,c=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=UD(p,d,h,c,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};var HD={kernelName:Kn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r;NE(a,"oneHot");let u=ka.sizeFromShape(a.shape),p=new Float32Array(u*i);p.fill(l);let d=n.data.get(a.dataId).values;for(let e=0;e<u;++e)d[e]>=0&&d[e]<i&&(p[e*i+d[e]]=o);return n.makeTensorInfo([...a.shape,i],s,p)}};function jD(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){let e=LE({inputs:{input:r},backend:n}),t=jD({inputs:{x:e},backend:n}),a=QF({inputs:{input:r},backend:n}),s=jD({inputs:{x:a},backend:n}),i=FE({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return XR({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var qD={kernelName:na,backendName:"cpu",kernelFunc:jD};var KD={kernelName:qn,backendName:"cpu",kernelFunc:function e(t){let{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===a.dtype){let t=LE({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=QF({inputs:{input:a},backend:r}),i=jD({inputs:{x:s},backend:r}),o=FE({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}return XR({backend:r,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}};function XD(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return BR({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{ka.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),ka.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=tR({inputs:t.map((e=>{let t=BR({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}var YD={kernelName:Xn,backendName:"cpu",kernelFunc:XD};var ZD={kernelName:Yn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;NE(a,"pad");let o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=n.data.get(a.dataId).values,p=ka.sizeFromShape(a.shape),d=a.shape.length,h=ka.computeStrides(a.shape),c=ka.sizeFromShape(o),f=o.length,m=ka.computeStrides(o),g=ka.getTypedArrayFromDType(a.dtype,c);0!==i&&g.fill(i);for(let e=0;e<p;e++){let t=ka.indexToLoc(e,d,h).map(((e,t)=>e+l[t]));g[ka.locToIndex(t,f,m)]=u[e]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}},JD=AE(((e,t)=>Math.pow(e,t))),QD=VE(Jn,JD),eM={kernelName:Jn,backendName:"cpu",kernelFunc:QD};var tM={kernelName:tr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.data.get(e.dataId).values)),u=a.map((e=>e.shape)),p=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,[h,c,f]=uA(l,u,p,s.shape,s.dtype,d,i.shape),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,c);return m.concat([g])}};var nM={kernelName:nr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,p]=dA(i,r.shape,r.dtype,o,a.shape,l,s.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([p.length],r.dtype,p)]}};var rM={kernelName:rr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(a.dataId).values,p=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,h=o.map((e=>n.data.get(e.dataId).values)),c=o.map((e=>e.shape)),[f,m]=gA(u,a.shape,p,s.shape,s.dtype,d,i.shape,h,c,l);return n.makeTensorInfo(f,s.dtype,m)}};var aM={kernelName:ar,backendName:"cpu",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,dtype:s,step:i}=n,o=yA(r,a,i,s);return t.makeTensorInfo([o.length],s,o)}},sM=e$(ir,(e=>1/e)),iM={kernelName:ir,backendName:"cpu",kernelFunc:sM};var oM={kernelName:dr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;NE(a,"resizeBilinear");let l=ka.computeStrides(a.shape),[u,p]=o,[d,h,c,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(ka.sizeFromShape([d,u,p,f])),y=[s&&u>1?h-1:h,s&&p>1?c-1:c],b=[s&&u>1?u-1:u,s&&p>1?p-1:p],x=0,w=y[0]/b[0],v=y[1]/b[1];for(let e=0;e<d;e++)for(let t=0;t<u;t++){let n;n=i?w*(t+.5)-.5:w*t;let r=Math.max(0,Math.floor(n)),a=n-r,s=Math.min(h-1,Math.ceil(n)),o=e*l[0]+r*l[1],u=e*l[0]+s*l[1];for(let e=0;e<p;e++){let t;t=i?v*(e+.5)-.5:v*e;let n=Math.max(0,Math.floor(t)),r=t-n,s=Math.min(c-1,Math.ceil(t)),p=o+n*l[2],d=u+n*l[2],h=o+s*l[2],y=u+s*l[2];for(let e=0;e<f;e++){let t=m[p+e],n=m[d+e],s=t+(m[h+e]-t)*r,i=s+(n+(m[y+e]-n)*r-s)*a;g[x++]=i}}}return n.makeTensorInfo([d,u,p,f],"float32",g)}};var lM={kernelName:hr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;NE([s,a],"resizeBilinearGrad");let o=ka.computeStrides(a.shape),[l,u,p,d]=a.shape,[,h,c]=s.shape,f=new Float32Array(l*u*p*d),m=[i&&h>1?u-1:u,i&&c>1?p-1:p],g=[i&&h>1?h-1:h,i&&c>1?c-1:c],y=m[0]/g[0],b=m[1]/g[1],x=n.data.get(s.dataId).values,w=0;for(let e=0;e<l;e++){let t=e*o[0];for(let e=0;e<h;e++){let n=e*y,r=Math.floor(n),a=Math.min(Math.ceil(n),u-1),s=t+r*o[1],i=t+a*o[1],l=n-r,h=1-l;for(let e=0;e<c;e++){let t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),p-1),a=t-n,u=1-a,c=s+n*o[2],m=s+r*o[2],g=i+n*o[2],y=i+r*o[2],v=h*u,k=h*a,I=l*u,S=l*a;for(let e=0;e<d;e++){let t=x[w++];f[c+e]+=t*v,f[m+e]+=t*k,f[g+e]+=t*I,f[y+e]+=t*S}}}}return n.makeTensorInfo([l,p,u,d],"float32",f)}};var uM={kernelName:ur,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;NE(a,"resizeNearestNeighbor");let l=ka.computeStrides(a.shape),[u,p]=o,[d,h,c,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(d*u*p*f),y=[s&&u>1?h-1:h,s&&p>1?c-1:c],b=[s&&u>1?u-1:u,s&&p>1?p-1:p],x=y[0]/b[0],w=y[1]/b[1],v=0;for(let e=0;e<d;e++){let t=e*l[0];for(let e=0;e<u;e++){let n=i?x*(e+.5):x*e,r=Math.min(h-1,s?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));let a=t+r*l[1];for(let e=0;e<p;e++){let t=i?w*(e+.5):w*e,n=Math.min(c-1,s?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));let r=a+n*l[2];for(let e=0;e<f;e++){let t=m[r+e];g[v++]=t}}}}return n.makeTensorInfo([d,u,p,f],a.dtype,g)}};var pM={kernelName:pr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;NE([s,a],"resizeNearestNeighborGrad");let o=ka.computeStrides(a.shape),l=ka.computeStrides(s.shape),[u,p,d,h]=a.shape,[,c,f]=s.shape,m=new Float32Array(u*p*d*h),g=n.data.get(s.dataId).values,y=[i&&c>1?p-1:p,i&&f>1?d-1:d],b=[i&&c>1?c-1:c,i&&f>1?f-1:f],x=y[0]/b[0],w=y[1]/b[1],v=1/x,k=1/w,I=2*Math.ceil(v)+2,S=2*Math.ceil(k)+2;for(let e=0;e<u;e++){let t=e*o[0];for(let e=0;e<p;e++){let n=t+e*o[1],r=Math.floor(e*v),a=Math.floor(r-I/2);for(let r=0;r<d;r++){let s=n+r*o[2],u=Math.floor(r*k),y=Math.floor(u-S/2);for(let n=0;n<h;n++){let o=0;for(let s=0;s<I;s++){let u=s+a;if(u<0||u>=c)continue;let h=t+u*l[1],m=u*x;if(e===Math.min(p-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<S;e++){let t=e+y;if(t<0||t>=f)continue;let a=h+t*l[2],s=t*w;r===Math.min(d-1,i?Math.round(s):Math.floor(s))&&(o+=g[a+n])}}m[s+n]=o}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}};var dM={kernelName:fr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r;NE(a,"reverse");let i=a.shape.length,o=ka.parseAxisParam(s,a.shape);if(0===i)return ME({inputs:{x:a},backend:n});let l=new rs(a.shape,a.dtype),u=n.bufferSync(a);for(let e=0;e<l.size;e++){let t=l.indexToLoc(e),n=t.slice();o.forEach((e=>n[e]=a.shape[e]-1-n[e])),l.set(u.get(...n),...t)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},hM={kernelName:sa,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=n,l=ka.getTypedArrayFromDType(r.dtype,ka.sizeFromShape(r.shape)),[u,p,d,h]=r.shape,[c,f]=Jf.getImageCenter(i,p,d),m=Math.sin(a),g=Math.cos(a),y=o.data.get(r.dataId).values;for(let e=0;e<u;e++){let t=e*d*p*h;for(let e=0;e<p;e++){let n=e*(d*h);for(let r=0;r<d;r++){let a=r*h;for(let i=0;i<h;i++){let o=[u,e,r,i],b=o[2],x=o[1],w=(b-c)*g-(x-f)*m,v=(b-c)*m+(x-f)*g;w=Math.round(w+c),v=Math.round(v+f);let k=s;if("number"!=typeof s&&(k=3===i?255:s[i]),w>=0&&w<d&&v>=0&&v<p){k=y[t+v*(d*h)+w*h+i]}l[t+n+a+i]=k}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},cM=e$(mr,(e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1})),fM={kernelName:mr,backendName:"cpu",kernelFunc:cM};var mM={kernelName:yr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:p,outputSize:d}=Jf.calculateShapes(s,a,i),h=vA(n.bufferSync(a),n.bufferSync(s),i,d,u,l,o,p,0,!0);return n.makeTensorInfo(i,h.dtype,h.values)}};function gM(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function yM(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}var bM={kernelName:xr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=function(e,t,n,r,a,s){let i=ka.getArrayFromDType("int32",n*a);for(let o=0;o<n;++o){let n=e.slice(o*r,(o+1)*r),l=o*a;for(let e=0;e<a;++e)i[l+e]="left"===s?gM(n,t[e+l]):yM(n,t[e+l])}return i}(n.data.get(a.dataId).values,n.data.get(s.dataId).values,a.shape[0],a.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",o)}};var xM={kernelName:wr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t;NE([r,a,s],"select");let i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,p=gs(a.dtype,s.dtype),d=ka.makeZerosTypedArray(ka.sizeFromShape(a.shape),p),h=0,c=0===i||i>1||1===a.shape.length?1:ka.sizeFromShape(a.shape.slice(1));for(let e=0;e<o.length;e++)for(let t=0;t<c;t++)1===o[e]?d[h++]=l[e]:d[h++]=u[e];return n.makeTensorInfo(a.shape,p,d)}},wM=Jf.SELU_SCALEALPHA,vM=Jf.SELU_SCALE,kM=e$(vr,(e=>e>=0?vM*e:wM*(Math.exp(e)-1))),IM={kernelName:vr,backendName:"cpu",kernelFunc:kM},SM=e$(Nr,(e=>e<0?-1:e>0?1:0)),NM={kernelName:Nr,backendName:"cpu",kernelFunc:SM},TM=e$(Ir,(e=>Math.sin(e))),_M={kernelName:Ir,backendName:"cpu",kernelFunc:TM},CM=e$(Sr,(e=>Math.sinh(e))),EM={kernelName:Sr,backendName:"cpu",kernelFunc:CM},$M=Math.log(1.1920928955078125e-7)+2,AM=e$(_r,(e=>{let t,n=e>-$M,r=e<$M,a=Math.exp(e);return t=r?a:n?e:Math.log(1+a),t})),FM={kernelName:_r,backendName:"cpu",kernelFunc:AM};var RM={kernelName:$r,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;NE([a],"spaceToBatchND");let o=ka.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let e=1+s.length;e<a.shape.length;++e)l.push([0,0]);let u=ZD.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),p=Jf.getReshaped(u.shape,s,o,!1),d=Jf.getPermuted(p.length,s.length,!1),h=Jf.getReshapedPermuted(u.shape,s,o,!1),c=fF({inputs:{x:u},backend:n,attrs:{shape:p}}),f=nA({inputs:{x:c},backend:n,attrs:{perm:d}}),m=fF({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),m}};var DM={kernelName:Rr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n        ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,p=n.data.get(i.dataId).values[0],[d,h,c,f,m]=CA(o,r.shape,r.dtype,l,a.dtype,u,p);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,c),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};var MM={kernelName:Dr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,p,d]=EA(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(p,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};var OM={kernelName:Mr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,p]=$A(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(p,r.dtype,u)}};var LM={kernelName:Or,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,p]=$A(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(p,r.dtype,u)}};var zM={kernelName:Lr,backendName:"cpu",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{sparseIndices:s,sparseValues:i,defaultValue:o}=n,{outputShape:l}=a,{sliceRank:u,numUpdates:p,sliceSize:d,strides:h,outputSize:c}=Jf.calculateShapes(i,s,l),f=!1,m=r.bufferSync(s);switch(i.dtype){case"bool":t=vA(m,r.bufferSync(i),l,c,d,p,u,h,!!r.data.get(o.dataId).values[0],f);break;case"float32":case"int32":t=vA(m,r.bufferSync(i),l,c,d,p,u,h,r.data.get(o.dataId).values[0],f);break;case"string":t=vA(m,r.bufferSync(i),l,c,d,p,u,h,ka.decodeString(r.data.get(o.dataId).values[0]),f);break;default:throw new Error(`Unsupported type ${i.dtype}`)}return r.makeTensorInfo(l,t.dtype,t.values)}};var PM={kernelName:Ar,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=ka.parseAxisParam(i,a.shape)[0],l=Jf.prepareSplitSize(a,s,o),u=new Array(a.shape.length).fill(0),p=a.shape.slice();return l.map((e=>{let t=[...p];t[o]=e;let r=TA({inputs:{x:a},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r}))}},BM={kernelName:Pr,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;NE(n,"square");let a=r.data.get(n.dataId).values,s=new Float32Array(a.length);for(let e=0;e<a.length;++e){let t=a[e];s[e]=t*t}return{dataId:r.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},WM=e$(ra,((e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),VM={kernelName:ra,backendName:"cpu",kernelFunc:WM};var UM={kernelName:Wr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:p,newAxisMask:d,shrinkAxisMask:h}=r;NE(a,"stridedSlice");let c,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:x,end:w,strides:v}=Tf.sliceInfo(a.shape,s,i,o,l,u,p,d,h);if(g)c=fF({inputs:{x:a},backend:n,attrs:{shape:m}});else if(y||b){ka.assert(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));let e=Tf.computeOutShape(x,w,v),t=TA({inputs:{x:a},backend:n,attrs:{begin:x,size:e}});c=fF({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else{let e=BA(f,n.bufferSync(a),v,x);c=n.makeTensorInfo(m,e.dtype,e.values)}return c}};var GM={kernelName:Vr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:p,dataSplits:d}=t,h=n.data.get(p.dataId).values,c=n.data.get(d.dataId).values,[f,m]=VA(h,c,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};var HM={kernelName:Ur,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[u,p,d]=GA(o,l,a),h=p.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",p),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};var jM={kernelName:Gr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=HA(n.data.get(s.dataId).values,a);return n.makeTensorInfo(s.shape,"int32",i)}},qM=e$(jr,(e=>Math.tan(e))),KM={kernelName:jr,backendName:"cpu",kernelFunc:qM},XM=e$(qr,(e=>Math.tanh(e)));var YM={kernelName:br,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:p}=Jf.calculateShapes(s,a,r.shape),d=n.bufferSync(a),h=n.bufferSync(s),c=n.bufferSync(r),f=vA(d,h,r.shape,p,l,o,i,u,c,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};var ZM={kernelName:Kr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;NE(a,"tile");let i=YA(n.bufferSync(a),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}};var JM={kernelName:Xr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r;NE(a,"topk");let o=n.data.get(a.dataId).values,[l,u]=QA(o,a.shape,a.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};var QM={kernelName:Yr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[p,d,h,c]=a.shape,[f,m]=null!=u?u:[d,h],g=[p,f,m,c],y=ka.computeStrides(a.shape),b=y[0],x=y[1],w=y[2],v=ka.computeStrides(g),k=v[0],I=v[1],S=v[2],N=ka.getTypedArrayFromDType(a.dtype,ka.sizeFromShape(g));N.fill(l);let T=r.data.get(a.dataId).values,_=r.data.get(s.dataId).values;for(let e=0;e<p;++e){let t=1===s.shape[0]?_:_.subarray(8*e,8*e+8);for(let n=0;n<f;++n)for(let r=0;r<m;++r)for(let a=0;a<c;++a){let s,u=t[6]*r+t[7]*n+1;if(0===u)continue;let p=(t[0]*r+t[1]*n+t[2])/u,c=(t[3]*r+t[4]*n+t[5])/u,f=eO(p,h,o),m=eO(c,d,o);switch(i){case"nearest":s=nO(T,d,h,b,x,w,e,m,f,a,l);break;case"bilinear":s=rO(T,d,h,b,x,w,e,m,f,a,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}N[e*k+n*I+r*S+a]=s}return r.makeTensorInfo(g,a.dtype,N)}return{dataId:r.write(N,g,a.dtype),shape:a.shape,dtype:a.dtype}}};function eO(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{let e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return ka.clamp(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{let e=t-1;n-=t*Math.trunc(n/e)}return ka.clamp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return ka.clamp(0,e,t-1)}(e,t);default:return function(e,t){return e}(e)}}function tO(e,t,n,r,a,s,i,o,l,u,p){return 0<=o&&o<t&&0<=l&&l<n?e[i*r+o*a+l*s+u]:p}function nO(e,t,n,r,a,s,i,o,l,u,p){return tO(e,t,n,r,a,s,i,Math.round(o),Math.round(l),u,p)}function rO(e,t,n,r,a,s,i,o,l,u,p){let d=Math.floor(o),h=Math.floor(l),c=d+1,f=h+1;return(c-o)*((f-l)*tO(e,t,n,r,a,s,i,d,h,u,p)+(l-h)*tO(e,t,n,r,a,s,i,d,f,u,p))+(o-d)*((f-l)*tO(e,t,n,r,a,s,i,c,h,u,p)+(l-h)*tO(e,t,n,r,a,s,i,c,f,u,p))}var aO={kernelName:Jr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;NE(s,"unique");let i=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:u}=eF(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};var sO={kernelName:Qr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape.length,o=a.shape[s],l=new Array(i-1),u=0;for(let e=0;e<i;e++)e!==s&&(l[u++]=a.shape[e]);let p=new Array(i).fill(0),d=a.shape.slice();d[s]=1;let h=new Array(o);for(let e=0;e<h.length;e++){p[s]=e;let t=TA({inputs:{x:a},backend:n,attrs:{begin:p,size:d}});h[e]=fF({inputs:{x:t},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(t)}return h}};var iO={kernelName:ea,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r;NE(a,"unsortedSegmentSum");let o=[],l=[],u=a.shape.length-s.shape.length,p=s;for(let e=0;e<u;++e){let t=BR({inputs:{input:p},backend:n,attrs:{dim:e+1}});p=t,l.push(t)}for(let e=0;e<i;++e){let t=ka.createScalarValue(e,"int32"),r=n.makeTensorInfo([],"int32",t),s=o$({inputs:{a:r,b:p},backend:n}),i=BE({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),u=K$({inputs:{a:i,b:a},backend:n}),d=CR({inputs:{x:u},backend:n,attrs:{axis:0,keepDims:!1}});o.push(d),l.push(r),l.push(s),l.push(i),l.push(u),l.push(d)}let d=XD({inputs:o,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},oO=[bF,$E,wF,kF,qE,IF,SF,NF,TF,_F,EF,AF,RF,OF,zF,VF,UF,GF,HF,yF,jF,qF,KF,JE,XF,WE,a$,ZF,RE,JF,nR,aR,sR,iR,oR,lR,uR,dR,cR,fR,mR,gR,yR,bR,wR,vR,kR,IR,SR,NR,TR,_R,$R,rF,AR,l$,PR,d$,WR,f$,KR,YR,ZR,y$,w$,JR,QR,eD,tD,N$,C$,OE,nD,eR,aD,iD,lD,sF,A$,D$,uD,z$,dD,fD,gD,xD,wD,vD,ID,V$,SD,ND,TD,_D,CD,ED,$D,H$,AD,DD,zD,X$,Z$,BD,VD,GD,eA,HD,KD,YD,ZD,eM,lF,sA,tM,nM,rM,aM,zE,GR,iM,pF,hF,mF,oM,lM,uM,pM,dM,hM,fM,wA,mM,bM,xM,IM,SA,NM,_M,EM,_A,LD,FM,RM,DM,MM,OM,LM,zM,PM,RA,BM,OA,PA,VM,UM,GM,HM,jM,XA,ER,KM,{kernelName:qr,backendName:"cpu",kernelFunc:XM},YM,ZM,JM,QM,rA,aO,sO,iO,qD];for(let e of oO)ga(e);var lO={};g(lO,{assertNotComplex:()=>yL,bindCanvasToFramebuffer:()=>qO,bindColorTextureToFramebuffer:()=>KO,bindTextureToProgramUniformSampler:()=>jO,bindTextureUnit:()=>VO,bindVertexBufferToProgramAttribute:()=>WO,callAndCheck:()=>wO,canBeRepresented:()=>IO,createFragmentShader:()=>_O,createFramebuffer:()=>BO,createProgram:()=>FO,createStaticIndexBuffer:()=>OO,createStaticVertexBuffer:()=>MO,createTexture:()=>zO,createVertexShader:()=>TO,getBatchDim:()=>eL,getExtensionOrThrow:()=>NO,getFramebufferErrorMessage:()=>ZO,getMaxTexturesInShader:()=>uL,getNumChannels:()=>LO,getProgramUniformLocation:()=>HO,getProgramUniformLocationOrThrow:()=>GO,getRowsCols:()=>tL,getShapeAs3D:()=>nL,getTextureShapeFromLogicalShape:()=>rL,getWebGLDisjointQueryTimerVersion:()=>pL,getWebGLErrorMessage:()=>SO,getWebGLMaxTextureSize:()=>iL,hasExtension:()=>dL,isCapableOfRenderingToFloatTexture:()=>cL,isDownloadFloatTextureEnabled:()=>fL,isReshapeFree:()=>sL,isWebGLFenceEnabled:()=>gL,isWebGLVersionEnabled:()=>hL,linkProgram:()=>RO,logShaderSourceAndInfoLog:()=>AO,resetMaxTextureSize:()=>oL,resetMaxTexturesInShader:()=>lL,unbindColorTextureFromFramebuffer:()=>XO,unbindTextureUnit:()=>UO,validateFramebuffer:()=>YO,validateProgram:()=>DO,validateTextureSize:()=>PO});var uO,pO,dO,hO={},cO={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function fO(e,t){hO[e]=t}function mO(e,t){if(!(e in hO)||null!=t){let n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=null==t?function(e){if(!Pe().getBool("IS_SAFARI")&&"undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e):t;return n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete hO[e]}),!1),Pe().getBool("SOFTWARE_WEBGL_ENABLED")&&(cO.failIfMajorPerformanceCaveat=!1),1===e?n.getContext("webgl",cO)||n.getContext("experimental-webgl",cO):n.getContext("webgl2",cO)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;hO[e]=n}let n=hO[e];return null==n||n.isContextLost()?(delete hO[e],mO(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),hO[e])}function gO(e,t){return[t,e]}function yO(e){let t=ka.sizeFromShape(e),n=Math.ceil(t/4);return ka.sizeToSquarishShape(n)}function bO(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function xO(e,t){let n,r,a,s,i,o,l,u,p,d,h=e;return 2===Pe().getNumber("WEBGL_VERSION")?(n=h.R32F,r=h.R16F,a=h.RGBA16F,s=h.RGBA32F,i=h.RED,l=4,u=1,p=h.HALF_FLOAT,d=h.FLOAT,o=h.RGBA8):(n=e.RGBA,r=e.RGBA,a=e.RGBA,s=h.RGBA,i=e.RGBA,l=4,u=4,p=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,o=e.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:s,textureFormatFloat:i,downloadTextureFormat:o,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:p,textureTypeFloat:d}}function wO(e,t){let n=t();return Pe().getBool("DEBUG")&&function(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+SO(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(uO||(uO={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(pO||(pO={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(dO||(dO={}));var vO=5.96e-8,kO=65504;function IO(e){return!!(Pe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||vO<Math.abs(e)&&Math.abs(e)<kO)}function SO(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function NO(e,t){return JO(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function TO(e,t){let n=JO(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(wO(e,(()=>e.shaderSource(n,t))),wO(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function _O(e,t){let n=JO(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(wO(e,(()=>e.shaderSource(n,t))),wO(e,(()=>e.compileShader(n))),Pe().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw AO(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var CO,EO,$O=/ERROR: [0-9]+:([0-9]+):/g;function AO(e,t){let n=$O.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);let r=+n[1],a=e.split("\n"),s=a.length.toString().length+2,i=a.map(((e,t)=>ka.rightPad((t+1).toString(),s)+e)),o=0;for(let e=0;e<i.length;e++)o=Math.max(i[e].length,o);let l=i.slice(0,r-1),u=i.slice(r-1,r),p=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${ka.rightPad(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(p.join("\n"))}function FO(e){return JO(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function RO(e,t){if(wO(e,(()=>e.linkProgram(t))),!Pe().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function DO(e,t){if(wO(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function MO(e,t){let n=JO(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return wO(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),wO(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function OO(e,t){let n=JO(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return wO(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),wO(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function LO(){return 2===Pe().getNumber("WEBGL_VERSION")?1:4}function zO(e){return JO(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function PO(e,t){let n=Pe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){throw new Error("Requested texture size "+`[${e}x${t}]`+" is invalid.")}if(e>n||t>n){throw new Error("Requested texture size "+`[${e}x${t}]`+" greater than WebGL maximum on this browser / GPU "+`[${n}x${n}]`+".")}}function BO(e){return JO(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function WO(e,t,n,r,a,s,i){let o=e.getAttribLocation(t,n);return-1!==o&&(wO(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),wO(e,(()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,s,i))),wO(e,(()=>e.enableVertexAttribArray(o))),!0)}function VO(e,t,n){QO(e,n),wO(e,(()=>e.activeTexture(e.TEXTURE0+n))),wO(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function UO(e,t){QO(e,t),wO(e,(()=>e.activeTexture(e.TEXTURE0+t))),wO(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function GO(e,t,n){return JO(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function HO(e,t,n){return e.getUniformLocation(t,n)}function jO(e,t,n,r){wO(e,(()=>VO(e,t,r))),wO(e,(()=>e.uniform1i(n,r)))}function qO(e){wO(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),wO(e,(()=>e.viewport(0,0,e.canvas.width,e.canvas.height))),wO(e,(()=>e.scissor(0,0,e.canvas.width,e.canvas.height)))}function KO(e,t,n){wO(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),wO(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function XO(e,t){wO(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),wO(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function YO(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+ZO(e,t))}function ZO(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function JO(e,t,n){let r=wO(e,(()=>t()));if(null==r)throw new Error(n);return r}function QO(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function eL(e,t=2){return ka.sizeFromShape(e.slice(0,e.length-t))}function tL(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function nL(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[eL(e),...tL(e)]),t}function rL(e,t=!1){let n=Pe().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Pe().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&Pe().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,n)=>n>=e.length-2?ka.nearestLargerEven(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length&&(e=ka.squeezeShape(e).newShape);let a=ka.sizeFromShape(e),s=null;e.length<=1&&a<=n?s=[1,a]:2===e.length&&e[0]<=n&&e[1]<=n?s=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);let i=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(null==s||i)if(t){let t=eL(e),n=2,r=2;e.length&&([n,r]=tL(e)),a=t*(n/2)*(r/2),s=ka.sizeToSquarishShape(a).map((e=>2*e))}else s=ka.sizeToSquarishShape(a);return s}function aL(e){return e%2==0}function sL(e,t){if(e=e.slice(-2),t=t.slice(-2),ka.arraysEqual(e,t)||!e.length||!t.length||0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||aL(n)&&aL(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&aL(e[0])&&aL(t[0])}function iL(e){if(null==CO){let t=mO(e);CO=t.getParameter(t.MAX_TEXTURE_SIZE)}return CO}function oL(){CO=null}function lL(){EO=null}function uL(e){if(null==EO){let t=mO(e);EO=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,EO)}function pL(e){if(0===e)return 0;let t,n=mO(e);return t=dL(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:dL(n,"EXT_disjoint_timer_query")?1:0,t}function dL(e,t){return null!=e.getExtension(t)}function hL(e){try{if(null!=mO(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function cL(e){if(0===e)return!1;let t=mO(e);if(1===e){if(!dL(t,"OES_texture_float"))return!1}else if(!dL(t,"EXT_color_buffer_float"))return!1;return mL(t)}function fL(e){if(0===e)return!1;let t=mO(e);if(1!==e){if(dL(t,"EXT_color_buffer_float"))return mL(t);let e="EXT_color_buffer_half_float";if(dL(t,e)){let n=t.getExtension(e);return function(e,t){let n=xO(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(a),s}(t,n)}return!1}return!(!dL(t,"OES_texture_float")||!dL(t,"WEBGL_color_buffer_float"))&&mL(t)}function mL(e){let t=xO(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function gL(e){return 2===e&&null!=mO(e).fenceSync}function yL(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&ka.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}var bL=Pe();function xL(){let e,t,n,r,a,s,i,o,l,u;return 2===Pe().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",i="out vec4 outputColor;",o=Pe().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function wL(e,t,n="index"){let r=ka.computeStrides(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${t}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`};`)).join("")}function vL(e,t,n="index"){let r=ka.computeStrides(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / outShapeStrides[${a}]`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`};`)).join("")}function kL(e,t,n="index"){let r=function(e,t){let n=e.length,r=e.map((e=>`${t}[${e}]`)),a=new Array(n-1);a[n-2]=r[n-1];for(let e=n-3;e>=0;--e)a[e]=`(${a[e+1]} * ${r[e+1]})`;return a}(e.map(((e,t)=>t)),t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${r[a]}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${r[a]}`:`index -= ${e[a]} * ${r[a]}`};`)).join("")}function IL(e){let t=ka.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}bL.registerFlag("HAS_WEBGL",(()=>bL.getNumber("WEBGL_VERSION")>0)),bL.registerFlag("WEBGL_VERSION",(()=>hL(2)?2:hL(1)?1:0)),bL.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),bL.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===bL.get("WEBGL_VERSION"))),bL.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),bL.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),bL.registerFlag("WEBGL_PACK",(()=>bL.getBool("HAS_WEBGL"))),bL.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>bL.getBool("WEBGL_PACK"))),bL.registerFlag("WEBGL_PACK_CLIP",(()=>bL.getBool("WEBGL_PACK"))),bL.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>bL.getBool("WEBGL_PACK"))),bL.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>bL.getBool("WEBGL_PACK"))),bL.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>bL.getBool("WEBGL_PACK"))),bL.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>bL.getBool("WEBGL_PACK"))),bL.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>bL.getBool("WEBGL_PACK"))),bL.registerFlag("WEBGL_PACK_REDUCE",(()=>bL.getBool("WEBGL_PACK"))),bL.registerFlag("WEBGL_LAZILY_UNPACK",(()=>bL.getBool("WEBGL_PACK"))),bL.registerFlag("WEBGL_CONV_IM2COL",(()=>bL.getBool("WEBGL_PACK"))),bL.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>bL.getBool("WEBGL_PACK"))),bL.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>iL(bL.getNumber("WEBGL_VERSION")))),bL.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>uL(bL.getNumber("WEBGL_VERSION")))),bL.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{let e=bL.getNumber("WEBGL_VERSION");return 0===e?0:pL(e)})),bL.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>bL.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Fs.isMobile())),bL.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>cL(bL.getNumber("WEBGL_VERSION")))),bL.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!bL.getBool("WEBGL_FORCE_F16_TEXTURES")&&bL.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),bL.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>fL(bL.getNumber("WEBGL_VERSION")))),bL.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>gL(bL.getNumber("WEBGL_VERSION")))),bL.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>bL.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),bL.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!=typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),bL.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Fs.isMobile()?1:-1),(e=>{if("number"!=typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),bL.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),bL.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),bL.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),bL.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),bL.registerFlag("WEBGL_EXP_CONV",(()=>!1)),bL.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>bL.getBool("IS_TEST"))),bL.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),bL.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),bL.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),bL.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));var SL="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:NL}=Jf;function TL(e,t,n){let r=[];if(e.forEach((e=>{let t=ka.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){let{uniformShape:t}=LL(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));let a,s,i=r.join("\n"),o=e.map((e=>function(e,t,n=!1,r){let a="";a+=n?CL(e,r):_L(e,r);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(a+=n?function(e,t){let n,r=e.name,a=r.charAt(0).toUpperCase()+r.slice(1),s="get"+a+"AtOutCoords",i=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,l=NL(e.shapeInfo.logicalShape,t.logicalShape),u=OL(o),p=o-i,d=["x","y","z","w","u","v"];n=0===i?"":o<2&&l.length>=1?"coords = 0;":l.map((e=>`coords.${d[e+p]} = 0;`)).join("\n");let h="";h=o<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${d[t+p]}`)).join(", ");let c="return outputValue;",f=1===ka.sizeFromShape(e.shapeInfo.logicalShape),m=1===ka.sizeFromShape(t.logicalShape);if(1!==i||f||m){if(f&&!m)c=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){let e=i-2,t=i-1;l.indexOf(e)>-1&&l.indexOf(t)>-1?c="return vec4(outputValue.x);":l.indexOf(e)>-1?c="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(t)>-1&&(c="return vec4(outputValue.xx, outputValue.zz);")}}else c="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${u} coords = getOutputCoords();\n      ${n}\n      vec4 outputValue = get${a}(${h});\n      ${c}\n    }\n  `}(e,t):function(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&ka.arraysEqual(i,s))return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;let u,p=OL(l),d=NL(e.shapeInfo.logicalShape,t.logicalShape),h=l-o,c=["x","y","z","w","u","v"];u=0===o?"":l<2&&d.length>=1?"coords = 0;":d.map((e=>`coords.${c[e+h]} = 0;`)).join("\n");let f="";return f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${c[t+h]}`)).join(", "),`\n    float ${a}() {\n      ${p} coords = getOutputCoords();\n      ${u}\n      return get${r}(${f});\n    }\n  `}(e,t)),a}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),l=t.texShape,u=xL(),p=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(u),d=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${EL}\n    ${$L}\n    ${AL}\n  `}(u);return t.isPacked?(a=function(e,t,n){switch(e.length){case 0:return RL();case 1:return function(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(ka.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;let a=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2),i=s,o="",l="b, r, c";for(let t=2;t<e.length-1;t++)i*=e[e.length-t-1],o=`\n      int b${t} = index / ${i};\n      index -= b${t} * ${i};\n    `+o,l=`b${t}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,l,n.enableShapeUniforms),s=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(u)):(a=function(e,t,n){switch(e.length){case 0:return RL();case 1:return function(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){return ka.arraysEqual(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${vL(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;let r=wL(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${vL(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;let r=wL(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){let n=wL(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){let n=wL(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,l,n.enableShapeUniforms),s=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),n.packedInputs&&(d+=FL),[d,p,s,i,a,o,n.userCode].join("\n")}function _L(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[a,s]=e.shapeInfo.texShape;if(1===a&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let i=DL(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;let[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${ML(e)}\n      }\n    `;let a=e.shapeInfo.texShape,s=a[0],i=a[1];if(1===i&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let o=DL(n);return 1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===s?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(null!=s&&ka.arraysEqual(n,s)){if(t)return`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;let e=s[0];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}let{newShape:i,keptDims:o}=ka.squeezeShape(n),l=i;if(l.length<n.length){let n=["row","col"];return`\n      ${_L(zL(e,l),t)}\n      float ${a}(int row, int col) {\n        return ${a}(${PL(n,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${ML(e)}\n      }\n    `;let u=s[0],p=s[1],d=DL(r);return 1===p?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${p}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=ka.squeezeShape(n),u=o;if(u.length<n.length){let n=["row","col","depth"];return`\n        ${_L(zL(e,u),t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${PL(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${i}, 1)));\n        ${ML(e)}\n      }\n    `;let p=e.shapeInfo.texShape,d=p[0],h=p[1],c=e.shapeInfo.flatOffset;if(h===s&&null==c)return t?`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===i&&null==c)return t?`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;let f=DL(r);return t?`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:u}=ka.squeezeShape(n);if(l.length<n.length){let n=["row","col","depth","depth2"];return`\n      ${_L(zL(e,l),t)}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${PL(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${s}, 1)));\n        ${ML(e)}\n      }\n    `;let p=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],c=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(c===o&&null==p)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${c}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(c===s&&null==p)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${c}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;let y=DL(r);return t?`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${c}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:u}=ka.squeezeShape(t);if(l.length<t.length){let t=["row","col","depth","depth2","depth3"];return`\n      ${_L(zL(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${PL(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${s}, ${a})) +\n          depth3;\n        ${ML(e)}\n      }\n    `;let p=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],c=d[1];if(c===o&&null==p)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${s}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${c}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(c===a&&null==p)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${c}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let f=DL(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${s} +\n          depth2 * ${a} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${h}, ${c}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=ka.squeezeShape(t);if(a.length<t.length){let t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${_L(zL(e,a))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${PL(t,s)});\n      }\n    `}let i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,p=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${p}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${ML(e)}\n      }\n    `;let d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,c=h[0],f=h[1];if(f===p&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${c}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${c}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let m=DL(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${p} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${c}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function CL(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=xL();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=xL();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;let i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=xL();if(null!=s&&ka.arraysEqual(n,s))return t?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],p=Math.ceil(n[1]/2);return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${p}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){let r=[1,2],s=["b","row","col"];return`\n        ${CL(zL(e,n.slice(1)),t)}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${PL(s,r)});\n        }\n      `}let o=xL();if(t)return`\n    vec4 ${a}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;let l=i[0],u=i[1],p=Math.ceil(n[2]/2),d=p*Math.ceil(n[1]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${d}, ${p}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=xL();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);\n    }\n  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],p=l[1],d=Math.ceil(s[i-1]/2),h=d*Math.ceil(s[i-2]/2),c="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let e=2;e<i-1;e++)c=`int b${e}, `+c,h*=s[i-e-1],f=`b${e} * ${h} + `+f;return`\n    vec4 ${r}(${c}) {\n      int index = ${f};\n      int texR = index / ${p};\n      int texC = index - texR * ${p};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${u});\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}var EL="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",$L="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",AL="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",FL="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function RL(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function DL(e){return`offset${e}`}function ML(e){let t=e.name,n=ka.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function OL(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function LL(e,t,n){let{newShape:r,keptDims:a}=ka.squeezeShape(t),s=t.length,i=e&&3===s&&1===t[0],o=i?t.slice(1):r,l=!e&&s>1&&!ka.arraysEqual(t,n)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:a}}function zL(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function PL(e,t){return t.map((t=>e[t])).join(", ")}function BL(e,t,n){let r,a,s,i=[],o=[],l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===Pe().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));let p=!1;for(let r of t.variableNames){let a={name:r,uniform:e.getUniformLocation(n,r,p),offset:e.getUniformLocation(n,`offset${r}`,p)};t.enableShapeUniforms&&(a.shape=e.getUniformLocation(n,`${r}Shape`,p),a.texShape=e.getUniformLocation(n,`${r}TexShape`,p)),i.push(a)}if(t.enableShapeUniforms&&(r=e.getUniformLocation(n,"outShape",p),s=e.getUniformLocation(n,"outShapeStrides",p),a=e.getUniformLocation(n,"outTexShape",p)),t.customUniforms)for(let r of t.customUniforms)o.push(e.getUniformLocation(n,r.name,p));return{variablesLocations:i,customUniformLocations:o,infLoc:l,nanLoc:u,outShapeLocation:r,outShapeStridesLocation:s,outTexShapeLocation:a}}function WL(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{let r=e.logicalShape,a=t[n],s=a.shape;if(!ka.arraysEqual(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(e.isUniform&&a.isUniform)return;let i=e.texShape,o=a.isUniform?null:a.texData.texShape;if(!ka.arraysEqual(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)}))}function VL(e){return Pe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var UL=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=uO.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=xL();this.outputShape=e,this.enableShapeUniforms=VL(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?vL(["r","c","d"],e):wL(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}},GL=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=uO.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=xL();this.outputShape=e,this.enableShapeUniforms=VL(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?vL(["r","c","d"],e):wL(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}},HL=class{constructor(e){this.variableNames=["A"],this.outTexUsage=pO.DOWNLOAD;let t=xL();this.outputShape=e,this.userCode=`\n      ${SL}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}},jL=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=pO.DOWNLOAD;let t=xL();this.outputShape=e,this.userCode=`\n      ${SL}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}},qL={R:0,G:1,B:2,A:3},KL=class{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=xL();this.outputShape=e,this.enableShapeUniforms=VL(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let s="";for(let e=0;e<n.length;e++){let t=n[e];s+=`\n          if(offset == ${e}) {\n            result = values[${qL[t]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":IL(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${s}\n        }\n        ${r.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}},XL=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=xL();this.outputShape=e,this.enableShapeUniforms=VL(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let a=0;a<=1;a++){let s=2*t+a;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${s}] = values[0];\n            } else if (offset == 1) {\n              result[${s}] = values[1];\n            } else if (offset == 2) {\n              result[${s}] = values[2];\n            } else {\n              result[${s}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":IL(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${a};\n        }\n    `}},YL={};function ZL(e){let t=xL();return TO(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function JL(e){return MO(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function QL(e){return OO(e,new Uint16Array([0,1,2,2,1,3]))}function ez(e,t,n,r,a,s){PO(t,n);let i=zO(e),o=e.TEXTURE_2D;return wO(e,(()=>e.bindTexture(o,i))),wO(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),wO(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),wO(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),wO(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===Pe().getNumber("WEBGL_VERSION")?wO(e,(()=>e.texImage2D(o,0,r,t,n,0,a,s,null))):wO(e,(()=>e.texStorage2D(o,1,r,t,n))),wO(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function tz(e){return e.internalFormatFloat}function nz(e,t,n,r){let[a,s]=gO(t,n);return ez(e,a,s,tz(r),r.textureFormatFloat,e.FLOAT)}function rz(e){return e.internalFormatHalfFloat}function az(e,t,n,r){let[a,s]=gO(t,n);return ez(e,a,s,rz(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function sz(e){return e.downloadTextureFormat}function iz(e,t,n,r){let[a,s]=gO(t,n);return ez(e,a,s,sz(r),e.RGBA,e.UNSIGNED_BYTE)}function oz(e){return e.internalFormatPackedFloat}function lz(e,t,n,r){let[a,s]=bO(t,n);return ez(e,a,s,oz(r),e.RGBA,e.FLOAT)}function uz(e){return e.internalFormatPackedHalfFloat}function pz(e,t,n,r){let[a,s]=bO(t,n);return ez(e,a,s,uz(r),e.RGBA,r.textureTypeHalfFloat)}function dz(e,t,n){return wO(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),WO(e,t,"clipSpacePos",n,3,20,0)&&WO(e,t,"uv",n,2,20,12)}function hz(e,t,n,r,a,s){let i,o,l;wO(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(a),2===Pe().getNumber("WEBGL_VERSION")?wO(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i))):wO(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i))),wO(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function cz(e,t,n){wO(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===Pe().getNumber("WEBGL_VERSION")?wO(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):wO(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===Pe().getNumber("WEBGL_VERSION")?wO(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):wO(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),wO(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function fz(e,t,n,r){let a=e.createBuffer();wO(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a)));let s=16*t*n;return wO(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),wO(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),wO(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),a}function mz(e,t,n){let r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function gz(e,t,n,r){let[a,s]=gO(t,n),i=new Uint8Array(function(e,t){return e*t}(t*n,4));return wO(e,(()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}function yz(e,t,n,r,a,s,i,o){let l=e,u=new Float32Array(function(e,t){let[n,r]=bO(e,t);return n*r*4}(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function bz(e,t,n){let r=new Float32Array(t*n*4);return wO(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}g(YL,{bindVertexProgramAttributeStreams:()=>dz,createBufferFromOutputTexture:()=>fz,createFloat16MatrixTexture:()=>az,createFloat16PackedMatrixTexture:()=>pz,createFloat32MatrixTexture:()=>nz,createIndexBuffer:()=>QL,createPackedMatrixTexture:()=>lz,createUnsignedBytesMatrixTexture:()=>iz,createVertexBuffer:()=>JL,createVertexShader:()=>ZL,downloadByteEncodedFloatMatrixFromOutputTexture:()=>gz,downloadFloat32MatrixFromBuffer:()=>mz,downloadMatrixFromPackedOutputTexture:()=>bz,downloadPackedMatrixFromBuffer:()=>yz,getInternalFormatForFloat16MatrixTexture:()=>rz,getInternalFormatForFloat16PackedMatrixTexture:()=>uz,getInternalFormatForFloat32MatrixTexture:()=>tz,getInternalFormatForPackedMatrixTexture:()=>oz,getInternalFormatForUnsignedBytesMatrixTexture:()=>sz,uploadDenseMatrixToTexture:()=>hz,uploadPixelDataToTexture:()=>cz});var xz=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=Pe().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,fO(t,e)):this.gl=mO(t),e=this.gl,2===Pe().getNumber("WEBGL_VERSION")){let t=e;this.createVertexArray=()=>wO(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>wO(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>wO(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>wO(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){let t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>wO(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>wO(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>wO(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>wO(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Pe().getNumber("WEBGL_VERSION")){let e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=NO(this.gl,e),dL(this.gl,t))this.textureHalfFloatExtension=NO(this.gl,t);else if(Pe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),dL(this.gl,r))this.colorBufferHalfFloatExtension=NO(this.gl,r);else if(Pe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",dL(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!dL(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=JL(this.gl),this.indexBuffer=QL(this.gl),this.framebuffer=BO(this.gl),this.textureConfig=xO(this.gl,this.textureHalfFloatExtension)}get debug(){return Pe().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;wO(e,(()=>e.finish())),wO(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),wO(e,(()=>e.deleteFramebuffer(this.framebuffer))),wO(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),wO(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),wO(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),nz(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),az(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),iz(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),cz(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),hz(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),pz(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),lz(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(XO(this.gl,this.framebuffer),this.outputTexture=null),wO(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>gz(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return yz(this.gl,e,0,0,0,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return mz(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=fz(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Pe().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>bz(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();let t=this.gl;null==this.vertexShader&&(this.vertexShader=ZL(t));let n=FO(t);wO(t,(()=>t.attachShader(n,this.vertexShader))),wO(t,(()=>t.attachShader(n,e))),RO(t,n);let r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&DO(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;wO(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),dz(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(wO(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&DO(this.gl,this.program),wO(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?GO(this.gl,e,t):HO(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),wO(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),jO(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,a]=bO(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&DO(this.gl,this.program),YO(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}wO(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),wO(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=NO(this.gl,2===Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await ka.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){let t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{let t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){let t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{let t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){let e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){let{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Pe().platform&&(n=Pe().platform.setTimeoutCustom.bind(Pe().platform)),ka.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),KO(this.gl,e,this.framebuffer),this.debug&&YO(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(KO(this.gl,this.outputTexture,this.framebuffer),this.debug&&YO(this.gl)):XO(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;KO(r,e,this.framebuffer),this.debug&&YO(r),this.outputTexture=e,wO(r,(()=>r.viewport(0,0,t,n))),wO(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),wO(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}};var{addImpl:wz,bincountImpl:vz,bincountReduceImpl:kz,bitwiseAndImpl:Iz,castImpl:Sz,ceilImpl:Nz,concatImpl:Tz,equalImpl:_z,expImpl:Cz,expm1Impl:Ez,floorImpl:$z,gatherNdImpl:Az,gatherV2Impl:Fz,greaterImpl:Rz,greaterEqualImpl:Dz,lessImpl:Mz,lessEqualImpl:Oz,linSpaceImpl:Lz,logImpl:zz,maxImpl:Pz,maximumImpl:Bz,minimumImpl:Wz,multiplyImpl:Vz,negImpl:Uz,notEqualImpl:Gz,prodImpl:Hz,raggedGatherImpl:jz,raggedRangeImpl:qz,raggedTensorToTensorImpl:Kz,rangeImpl:Xz,rsqrtImpl:Yz,scatterImpl:Zz,sigmoidImpl:Jz,simpleAbsImpl:Qz,sliceImpl:eP,sparseFillEmptyRowsImpl:tP,sparseReshapeImpl:nP,sparseSegmentReductionImpl:rP,sqrtImpl:aP,staticRegexReplaceImpl:sP,stridedSliceImpl:iP,stringNGramsImpl:oP,stringSplitImpl:lP,stringToHashBucketFastImpl:uP,subImpl:pP,tileImpl:dP,topKImpl:hP,transposeImpl:cP,uniqueImpl:fP}=CE;function mP(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function gP(e,t){return 1===t?[e]:mP(e,t)}var yP=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=VL(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{let e=gP("rc",this.rank),t=OL(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${e[e.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){let t=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}},bP=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=VL(this.outputShape.length);let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}this.userCode=`\n      ${function(e,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?kL(["r","c","d"],"inputShape"):wL(["r","c","d"],e)}\n      return ivec3(r, c, d);\n    }\n  `}(t,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":IL(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}};var xP=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r=vP(t,n),a=kP(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);let s,i=wP(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let e=this.freeTextures[a].pop();return this.usedTextures[a].push(e),e}return r===dO.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===dO.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===dO.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===dO.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===dO.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(s),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),s}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;let a=vP(n,r),s=kP(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);let i=wP(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=Pe().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[s],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(let e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(let e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function wP(e,t,n,r,a){let s,i=function(e,t){switch(e){case dO.PACKED_2X2_FLOAT32:return oz(t);case dO.PACKED_2X2_FLOAT16:return uz(t);case dO.UNPACKED_FLOAT32:return tz(t);case dO.UNPACKED_FLOAT16:return rz(t);case dO.PACKED_4X1_UNSIGNED_BYTE:return sz(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);if(a){let[t,n]=bO(e[0],e[1]);s=t*n}else{let[t,n]=gO(e[0],e[1]);s=t*n}let o=function(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,i);return s*o}function vP(e,t){if(e===pO.UPLOAD)return dO.PACKED_2X2_FLOAT32;if(e===pO.RENDER||null==e)return function(e){return Pe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?dO.PACKED_2X2_FLOAT32:dO.UNPACKED_FLOAT32:e?dO.PACKED_2X2_FLOAT16:dO.UNPACKED_FLOAT16}(t);if(e===pO.DOWNLOAD||e===pO.PIXELS)return dO.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function kP(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var IP=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=VL(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},SP="if (isnan(x)) return x;",NP="return x;",TP="return abs(x);",_P="return (x >= 0.0) ? x : (exp(x) - 1.0);",CP=SP+"\n  return (x < 0.0) ? 0.0 : x;\n",EP=SP+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",$P="return x;",AP="return 1.0 / (1.0 + exp(-1.0 * x));",FP="return x;",RP="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",DP="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",MP="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",OP="return 1.0 / (1.0 + exp(-1.0 * x));",LP=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=VL(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},zP=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=VL(this.outputShape.length);let t=e.length,n=gP("rc",t),r=OL(t),a=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}},PP=ag.whereImpl,BP={};var WP=Pe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");var VP=class e extends B{nextDataId(){return e.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Pe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof xz)t=e;else{let n=mO(Pe().getNumber("WEBGL_VERSION"),e);t=new xz(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let e=mO(Pe().getNumber("WEBGL_VERSION"));t=new xz(e),this.binaryCache=function(e){return e in BP||(BP[e]={}),BP[e]}(Pe().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new xP(this.gpgpu),this.numMBBeforeWarning=null==Pe().global.screen?1024:Pe().global.screen.height*Pe().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new P(this,ei())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,a,s){let i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,a]},o.texShape=[r,a];let l=nL(t),u=new KL(l,!1,s),p=this.runWebGLProgram(u,[i],n,[[r,a]]);return p.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),p.dataId}write(e,t,n){if((Pe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Pe().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:pO.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,a){if(Pe().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:pO.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:i,isPacked:o}=t;if(null!=s){let t;t=o?new LP(i,$P):new IP(i,$P);let n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;let l,u,p=null!=this.activeTimers;if(p&&(l=ka.now()),"complex64"===r){let e=this.readSync(a.real.dataId),t=this.readSync(a.imag.dataId);u=Jf.mergeRealAndImagArrays(e,t)}else u=this.getValuesFromTexture(e);return p&&(this.downloadWaitMs+=ka.now()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){let t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}let t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:i,isPacked:o}=t;if(null!=a){let t;t=o?new LP(r,$P):new IP(r,$P);let n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(Pe().getBool("DEBUG")&&!Pe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Pe().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,p=null;if("complex64"!==s&&Pe().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);let t=this.texData.get(l.dataId);p=this.gpgpu.createBufferFromTexture(t.texture.texture,...yO(r))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){let e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),t=e[0],n=e[1];u=Jf.mergeRealAndImagArrays(t,n)}else if(null==p)u=this.getValuesFromTexture(e);else{let e=ka.sizeFromShape(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(p,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=p){let e=this.gpgpu.gl;wO(e,(()=>e.deleteBuffer(p)))}let d=this.convertAndCacheOnCPU(e,u),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&ei().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){let n=this.texData.get(e),{values:r,shape:a,slice:s,dtype:i,isPacked:o,texture:l}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=o?new LP(a,$P):new IP(a,$P);let r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:i}],i),s=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),s}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let u=this.decode(e,t.customTexShape),p=ei().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:p},d.texture)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map((e=>ka.decodeString(e)));return mo(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return mo(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){let n=e[t];if(!IO(n))throw Pe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=ka.sizeFromShape(t);if(Pe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let n=this.decode(e),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...yO(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),s}let s=Pe().getBool("WEBGL_PACK")&&!0===r,i=s?nL(t):t,o=s?new jL(i):new HL(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),p}timerAvailable(){return Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,n=[],r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();let a=ka.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=ka.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let e=await Promise.all(a);i.kernelMs=ka.sum(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ka.now(),endMs:null}}endTimer(e){return Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=ka.now(),e)}async getQueryTime(e){if(Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:r,usage:a,isPacked:s,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,s)));let u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=WP){return Pe().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&ka.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){Jf.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return PP(e.shape,t)}packedUnaryOp(e,t,n){let r=new LP(e.shape,t),a=this.compileAndRun(r,[e],n);return ei().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){let t=Qz(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(Pe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,TP,e.dtype);let t=new IP(e.shape,TP),n=this.compileAndRun(t,[e]);return ei().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&ka.isString(n[0])){let a=n.map((e=>ka.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return ei().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){let t=new zP(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new yP(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){let n=[eL(e.shape),...tL(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[eL(t),...tL(t)],s=new bP(a,n),i=[n],o=this.runWebGLProgram(s,[r],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){let n=this.texData.get(e),{isPacked:r,shape:a,dtype:s}=n;if(null!=t){let e=ka.sizeFromShape(a),n=t[0]*t[1]*4;ka.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}let i,o=nL(a);i=r?new GL(o):new UL(o);let l=[null!=t?t:yO(o)];return{dtype:s,shape:a,dataId:this.runWebGLProgram(i,[{shape:o,dtype:s,dataId:e}],s,l,!0,t).dataId}}runWebGLProgram(e,t,n,r,a=!1,s){let i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===uO.DENSE){let t=null!=s?s:yO(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===ka.sizeFromShape(i.shape))return o.values=ka.getTypedArrayFromDType(i.dtype,0),i;let l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&ka.sizeFromShape(t.shape)<=Pe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!sL(n.shape,t.shape)){let e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);let p,d={shape:i.shape,texData:o,isUniform:!1},h=function(e,t,n){let r="";t.concat(n).forEach((t=>{let a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){let s=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:l}=LL(e.packedInputs,t.shape,s),u="",p="",d="";if(1===o.length&&e.packedInputs){let e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){let e=ka.computeStrides(o);d=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}}else p=`${o[0]>1}_${o[1]>1}`;let h=t.shape.length,c=2===o.length&&ka.arraysEqual(t.shape,s),f=1===ka.sizeFromShape(t.shape),m=Jf.getBroadcastDims(t.shape,n.shape),g=!e.packedInputs&&h===n.shape.length&&ka.arraysEqual(s,n.texData.texShape),y=e.packedInputs||o.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${h}_${g}_${i?l:""}_${o.length}_${f}_${m}_${c}_${u}_${p}_${d}_${y}_${a}`}else{let e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${a}`}}));let a=e.userCode,s=e.constructor.name;return s+="_"+r+"_"+a+`${Pe().getNumber("WEBGL_VERSION")}`,s}(e,u,d),c=this.getAndSaveBinary(h,(()=>function(e,t,n,r){let a=n.map(((e,n)=>{let r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),s=a.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=TL(a,i,t),l=_O(e.gl,o),u=e.createProgram(l);return Pe().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},BL(e,t,u)))}(this.gpgpu,e,u,d))),f=null!=this.activeTimers;f&&(p=this.startTimer()),Pe().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,a){t.program.enableShapeUniforms||(WL(t.inShapeInfos,n),WL([t.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===Pe().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let r=0;r<n.length;++r){let a=n[r],{uniform:s,offset:i,shape:o,texShape:l}=t.variablesLocations[r];if(o){let{uniformShape:n}=LL(t.program.packedInputs,a.shape,a.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(o,new Int32Array(n));break;case 2:e.gl.uniform2iv(o,new Int32Array(n));break;case 3:e.gl.uniform3iv(o,new Int32Array(n));break;case 4:e.gl.uniform4iv(o,new Int32Array(n))}}if(l&&e.gl.uniform2i(l,a.texData.texShape[0],a.texData.texShape[1]),null!=s){if(a.isUniform){if(ka.sizeFromShape(a.shape)<2)e.gl.uniform1f(s,a.uniformValues[0]);else{let t=a.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}continue}null!=a.texData.slice&&null!=i&&e.gl.uniform1i(i,a.texData.slice.flatOffset),e.setInputMatrixTexture(a.texData.texture.texture,s,r)}}let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){let n=ka.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let n=0;n<t.program.customUniforms.length;++n){let r=t.program.customUniforms[n],s=t.customUniformLocations[n],i=a[n];if("float"===r.type)e.gl.uniform1fv(s,i);else if("vec2"===r.type)e.gl.uniform2fv(s,i);else if("vec3"===r.type)e.gl.uniform3fv(s,i);else if("vec4"===r.type)e.gl.uniform4fv(s,i);else if("int"===r.type)e.gl.uniform1iv(s,i);else if("ivec2"===r.type)e.gl.uniform2iv(s,i);else if("ivec3"===r.type)e.gl.uniform3iv(s,i);else{if("ivec4"!==r.type)throw Error(`uniform type ${r.type} is not supported yet.`);e.gl.uniform4iv(s,i)}}e.executeProgram()}(this.gpgpu,c,u,d,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),f&&(p=this.endTimer(p),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(p)}));let m=Pe().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){let e=ka.now();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!Pe().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===a){let e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r,a=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Pe().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=ri((()=>{if(!Pe().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=Pe().getBool("DEBUG");Pe().set("DEBUG",!1);let t=this.abs(uu(1e-8)).dataSync()[0];if(Pe().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:s,usage:i,isPacked:o}=t;if(null!=s)return;let l,u=null!=this.activeTimers;u&&(l=ka.now());let p=t.texShape;if(null==p&&(p=rL(n,o),t.texShape=p),null!=a){let e,s=nL(n),i=p[1],d=p[0],h=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(o||!h)&&([i,d]=bO(p[0],p[1])),e=o?new XL(s,h):new KL(s,h);let c=h?[d,i]:p,f=this.makeTensorInfo(c,r),m=this.texData.get(f.dataId);m.usage=h?pO.PIXELS:pO.UPLOAD,m.texShape=c,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,d,a);let g=[[d,i]],y=this.runWebGLProgram(e,[f],r,g,!0),b=this.texData.get(y.dataId);t.texShape=b.texShape,t.isPacked=b.isPacked,t.usage=b.usage,Pe().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(t.texture=b.texture,t.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),u&&(this.uploadWaitMs+=ka.now()-l)}else{let e=this.acquireTexture(p,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){let n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){let e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*ka.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(let[,t]of Object.entries(this.binaryCache)){let n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Yf(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(AO(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);let{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}=BL(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.outShapeLocation=s,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";let{texture:r,height:a,width:s,channels:i}=e,o=ei().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let l=o.writeTexture(r,t,n,a,s,i);return ei().makeTensorFromDataId(l,t,n,o)}};VP.nextDataId=0;var UP="4.22.0";function GP(){Pe().set("WEBGL_FORCE_F16_TEXTURES",!0)}Fs.isBrowser()&&ci("webgl",(()=>new VP),2);var HP={forceHalfFloat:GP},jP="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",qP=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Jf.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=VL(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}},KP="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n",XP=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Jf.assertAndGetBroadcastShape(t,n);let a=this.outputShape.length;this.enableShapeUniforms=VL(a);let s="";if(r)if(0===a||1===ka.sizeFromShape(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(s=`\n          ${OL(a)} coords = getOutputCoords();\n        `,1===a)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{let e=gP("coords",a);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}};function YP(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var ZP={kernelName:on,backendName:"webgl",kernelFunc:YP};function JP(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(s.dataId),o=YP({inputs:{x:r},backend:n}),l=YP({inputs:{x:a},backend:n});return i.complexTensorInfos={real:o,imag:l},s}var QP={kernelName:yt,backendName:"webgl",kernelFunc:JP},eB="return (a < 0.) ? b * a : a;",tB="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";var nB={kernelName:cn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,i=n.makeTensorInfo([],"float32",ka.createScalarValue(s,"float32")),o=Pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new XP(tB,a.shape,i.shape):new qP(eB,a.shape,i.shape),l=n.runWebGLProgram(o,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),l}},rB="return (a < 0.) ? b * a : a;",aB="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";var sB={kernelName:Qn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=Pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new XP(aB,r.shape,a.shape):new qP(rB,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}},iB="if (isnan(x)) return x;";function oB({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:a,backend:s})=>{let i,{x:o}=a,l=s,u=r||o.dtype;if(l.shouldExecuteOnCPU([o])&&null!=n){let e=l.texData.get(o.dataId),t=n(e.values,u);return l.makeTensorInfo(o.shape,u,t)}return i=Pe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new LP(o.shape,t):new IP(o.shape,e),l.runWebGLProgram(i,[o],u)}}function lB({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:a,dtype:s}){return({inputs:i,backend:o})=>{let{a:l,b:u}=i,p=o;if(r&&"complex64"===l.dtype){let t=p.texData.get(l.dataId),n=p.texData.get(u.dataId),[r,a]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{let[n,r]=t,a={dataId:n.dataId,dtype:n.dtype,shape:l.shape},s={dataId:r.dataId,dtype:r.dtype,shape:u.shape},i=new qP(e,l.shape,u.shape);return p.runWebGLProgram(i,[a,s],gs(n.dtype,r.dtype))})),s=JP({inputs:{real:r,imag:a},backend:p});return p.disposeIntermediateTensorInfo(r),p.disposeIntermediateTensorInfo(a),s}let d,h=s||gs(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||p.shouldExecuteOnCPU([l,u]))&&null!=a){let e=p.texData.get(l.dataId).values,t=p.texData.get(u.dataId).values,n="string"===l.dtype?Jf.fromUint8ToStringArray(e):e,r="string"===l.dtype?Jf.fromUint8ToStringArray(t):t,[s,i]=a(l.shape,u.shape,n,r,h),o=p.makeTensorInfo(i,h);return p.texData.get(o.dataId).values=s,o}return d=Pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new XP(t,l.shape,u.shape,n):new qP(e,l.shape,u.shape),p.runWebGLProgram(d,[l,u],h)}}function uB(e,t=!1){if("linear"===e)return t?FP:NP;if("relu"===e)return t?DP:CP;if("elu"===e)return t?RP:_P;if("relu6"===e)return t?MP:EP;if("prelu"===e)return t?aB:rB;if("leakyrelu"===e)return t?tB:eB;if("sigmoid"===e)return t?OP:AP;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var pB=class{constructor(e,t,n,r=!1,a=!1,s=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=VL(this.outputShape.length);let u=r?e[1]:e[2],p=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=a?"rc.z, i * 2":"i * 2, rc.z",c=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");let y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",x="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(x=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${p}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${x};\n        for (int i = 0; i < ${p}; i++) {\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${c[0]} * ${f[0]});\n          result += (${c[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}},dB={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},hB=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Jf.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}},cB="return a * b;";function fB(e){let t,{inputs:n,backend:r}=e,{a:a,b:s}=n,i=Jf.upcastType(a.dtype,s.dtype);if("complex64"===a.dtype){let e=r.texData.get(a.dataId),t=r.texData.get(s.dataId),n=new hB(dB.REAL,a.shape,s.shape),i=new hB(dB.IMAG,a.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],l=r.runWebGLProgram(n,o,"float32"),u=r.runWebGLProgram(i,o,"float32"),p=JP({inputs:{real:l,imag:u},backend:r});return r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(u),p}if(r.shouldExecuteOnCPU([a,s])){let e=r.texData.get(a.dataId),t=r.texData.get(s.dataId),[n,o]=Vz(a.shape,s.shape,e.values,t.values,i),l=r.makeTensorInfo(o,i);return r.texData.get(l.dataId).values=n,l}return t=Pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new XP(cB,a.shape,s.shape):new qP(cB,a.shape,s.shape),r.runWebGLProgram(t,[a,s],i)}var mB={kernelName:Wn,backendName:"webgl",kernelFunc:fB};function gB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=n,o=ka.sizeFromShape(a.shape),l=ka.inferFromImplicitShape(s,o),u=ka.sizeFromShape(l);ka.assert(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));let p=i.texData.get(a.dataId);return!p.isPacked||sL(a.shape,l)||null!==p.texture&&sL(p.shape,l)?(i.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):function(e,t,n){let r=[eL(e.shape),...tL(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[eL(t),...tL(t)],i=new bP(s,r),o=[r],l=n.runWebGLProgram(i,[a],e.dtype,o,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(a,l,i)}var yB={kernelName:lr,backendName:"webgl",kernelFunc:gB},bB=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i=4*Math.floor(n/4),o=n%4,l="sumValue += dot(values, ones);";if(null!=t){let e=1/t;l=`sumValue += dot(values * ${ka.isInt(e)?e.toPrecision(2):e}, ones);`}let u="";a%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}},xB=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");let u=4*Math.floor(n/4),p=n%4,d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,h="vec4";"all"===t?(i="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(i="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let c="";a%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===p}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===p}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===p}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}};function wB(e,t,n,r){let a=function(e){let t=[];for(;0===t.length||1!==t[t.length-1].outSize;){let n=t.length?t[t.length-1].outSize:e[1],r=Jf.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape),s=e;for(let i=0;i<a.length;i++){let o,l,{inSize:u,windowSize:p,outSize:d}=a[i];o="mean"===n?0===i?new bB({windowSize:p,inSize:u,batchSize:e.shape[0],outSize:d},u):new bB({windowSize:p,inSize:u,batchSize:e.shape[0],outSize:d}):new xB({windowSize:p,inSize:u,batchSize:e.shape[0],outSize:d},n),l=s,s=r.runWebGLProgram(o,[s],t),l.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(l)}return s}var vB=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;let r=OL(this.rank),a=function(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let t=0;t<e.length;t++)r[e[t]]=n[t];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}};var kB=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=OL(this.rank),a=mP("rc",this.rank),s=new Array(this.rank);for(let e=0;e<t.length;e++)s[t[e]]=a[e];let i=`vec2(${s.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}};function IB(e,t,n){let r=Pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kB(e.shape,t):new vB(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function SB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;return function(e,t,n,r){let a=t,s=e.shape.length,i=ka.parseAxisParam(a,e.shape),o=i,l=Jf.getAxesPermutation(o,s),u=null!=l,p=e;u&&(p=IB(e,l,r),o=Jf.getInnerMostAxes(o.length,s)),Jf.assertAxesAreInnerMostDims("sum",o,s);let[d,h]=Jf.computeOutAndReduceShapes(p.shape,o),c=d;n&&(c=Jf.expandShapeToKeepDim(d,i));let f=ka.sizeFromShape(h),m=gB({inputs:{x:p},attrs:{shape:[ka.sizeFromShape(e.shape)/f,f]},backend:r}),g=wB(m,ys(e.dtype),"sum",r),y=gB({inputs:{x:g},attrs:{shape:c},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),u&&r.disposeIntermediateTensorInfo(p),y}(a,s,i,n)}var NB={kernelName:Er,backendName:"webgl",kernelFunc:SB};function TB(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{perm:i}=a,o=r,l=s.shape.length,u=new Array(l);for(let e=0;e<u.length;e++)u[e]=s.shape[i[e]];if(o.shouldExecuteOnCPU([s])){let e=o.texData.get(s.dataId).values,n=cP(e,s.shape,s.dtype,i,u);t=o.makeTensorInfo(u,s.dtype),o.texData.get(t.dataId).values=n}else t=IB(s,i,o);return t}var _B={kernelName:Zr,backendName:"webgl",kernelFunc:TB},CB=1e3;function EB({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){let u=e.shape.length,p=t.shape.length,d=n?e.shape[u-2]:e.shape[u-1],h=r?t.shape[p-1]:t.shape[p-2],c=n?e.shape[u-1]:e.shape[u-2],f=r?t.shape[p-2]:t.shape[p-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=ka.sizeFromShape(m),b=ka.sizeFromShape(g),x=Pl.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([c,f]);ka.assert(d===h,(()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`));let w,v=n?[y,d,c]:[y,c,d],k=r?[b,f,h]:[b,h,f],I=gB({inputs:{x:e},backend:a,attrs:{shape:v}}),S=gB({inputs:{x:t},backend:a,attrs:{shape:k}}),N=[I,S],T=Math.max(y,b),_=n?I.shape[1]:I.shape[2],C=null!=s,E=null!=i,$="leakyrelu"===l,A=null!=l?uB(l,!0):null;if((1===c||1===f)&&_>CB&&!1===(C||E||$||null!=A)){let e=I,t=S;n&&(e=TB({inputs:{x:I},backend:a,attrs:{perm:[0,2,1]}}),N.push(e)),r&&(t=TB({inputs:{x:S},backend:a,attrs:{perm:[0,2,1]}}),N.push(t));let s=1===f,i=e;1!==f&&(i=gB({inputs:{x:e},backend:a,attrs:{shape:[T,_,1]}}),N.push(i));let o=1===f?2:1,l=t;s&&(l=gB({inputs:{x:t},backend:a,attrs:{shape:[T,1,_]}}),N.push(l));let u=fB({inputs:{a:i,b:l},backend:a});w=SB({inputs:{x:u},backend:a,attrs:{axis:o,keepDims:!0}}),N.push(u)}else{let l=gs(e.dtype,t.dtype),u=new pB(v,k,[T,c,f],n,r,C,A,E,$),p=[I,S];if(null!=s&&p.push(s),E&&p.push(i),$){let e=a.makeTensorInfo([],"float32",ka.createScalarValue(o,"float32"));p.push(e),N.push(e)}w=a.runWebGLProgram(u,p,l)}let F=gB({inputs:{x:w},backend:a,attrs:{shape:x}});N.push(w);for(let e of N)a.disposeIntermediateTensorInfo(e);return F}var $B={kernelName:ia,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:p,leakyreluAlpha:d}=r;return EB({a:a,b:s,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:p})}},AB="return abs(x);";var FB={kernelName:Ge,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){let e=r.texData.get(a.dataId),t=Qz(e.values);return r.makeTensorInfo(a.shape,a.dtype,t)}return t=Pe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new LP(a.shape,AB):new IP(a.shape,AB),r.runWebGLProgram(t,[a],a.dtype)}},RB=oB({opSnippet:SP+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),DB={kernelName:He,backendName:"webgl",kernelFunc:RB},MB=oB({opSnippet:SP+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),OB={kernelName:je,backendName:"webgl",kernelFunc:MB},LB="return a + b;",zB=lB({opSnippet:LB,packedOpSnippet:LB,supportsComplex:!0,cpuKernelImpl:wz}),PB={kernelName:qe,backendName:"webgl",kernelFunc:zB},BB=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));let n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));let r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}},WB=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));let n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));let r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}};var VB={kernelName:Ke,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r}=t,a=n;if(1===a.length)return YP({inputs:{x:a[0]},backend:r});if(a.length>Pe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let t=Math.floor(a.length/2),n=e({inputs:a.slice(0,t),backend:r}),s=e({inputs:a.slice(t),backend:r});return e({inputs:[n,s],backend:r})}let s=a.map((e=>e.dtype)).reduce(((e,t)=>gs(e,t))),i=a.map((e=>e.shape)),o=Pe().getBool("WEBGL_PACK")?new WB(a[0].shape,i):new BB(a[0].shape,i);return r.runWebGLProgram(o,a,s)}};var UB={kernelName:Xe,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=ka.parseAxisParam(s,a.shape),u=l,p=Jf.getAxesPermutation(u,o),d=a;null!=p&&(d=TB({inputs:{x:a},backend:n,attrs:{perm:p}}),u=Jf.getInnerMostAxes(u.length,o)),Jf.assertAxesAreInnerMostDims("all",u,o);let h,[c,f]=Jf.computeOutAndReduceShapes(d.shape,u),m=gB({inputs:{x:d},backend:n,attrs:{shape:[-1,ka.sizeFromShape(f)]}}),g=wB(m,m.dtype,"all",n);if(i){h=gB({inputs:{x:g},backend:n,attrs:{shape:Jf.expandShapeToKeepDim(c,l)}})}else h=gB({inputs:{x:g},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=p&&n.disposeIntermediateTensorInfo(d),h}};var GB={kernelName:Ye,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=ka.parseAxisParam(s,a.shape),u=l,p=Jf.getAxesPermutation(u,o),d=a;null!=p&&(d=TB({inputs:{x:a},backend:n,attrs:{perm:p}}),u=Jf.getInnerMostAxes(u.length,o)),Jf.assertAxesAreInnerMostDims("any",u,o);let h,[c,f]=Jf.computeOutAndReduceShapes(d.shape,u),m=gB({inputs:{x:d},backend:n,attrs:{shape:[-1,ka.sizeFromShape(f)]}}),g=wB(m,m.dtype,"any",n);if(i){h=gB({inputs:{x:g},backend:n,attrs:{shape:Jf.expandShapeToKeepDim(c,l)}})}else h=gB({inputs:{x:g},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=p&&n.disposeIntermediateTensorInfo(d),h}},HB=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];let i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}},jB=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,ka.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));let a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");let i,o,l=this.outputShape,u=l.length,p=OL(u),d=gP("coords",u);if(1===s){o=u+1;let e=OL(o);i=`\n        ${e} sourceLocR = ${e}(${d.join()}, 0);\n        ++${d[u-1]};\n        ${e} sourceLocG = ${e}(${d.join()}, 0);\n        ++${d[u-2]};\n        ${e} sourceLocA = ${e}(${d.join()}, 0);\n        --${d[u-1]};\n        ${e} sourceLocB = ${e}(${d.join()}, 0);\n        --${d[u-2]};`}else o=u,i=`\n        ${p} sourceLocR = coords;\n        ++${d[u-1]};\n        ${p} sourceLocG = coords;\n        ++${d[u-2]};\n        ${p} sourceLocA = coords;\n        --${d[u-1]};\n        ${p} sourceLocB = coords;\n        --${d[u-2]};`;let h=["x","y","z","w","u","v"].slice(0,o),c="."+h[o-1],f=h.map((e=>"int "+e)),m=gP("sourceLocR",o-1).concat("inIdx.r"),g=gP("sourceLocG",o-1).concat("inIdx.g"),y=gP("sourceLocB",o-1).concat("inIdx.b"),b=gP("sourceLocA",o-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",w=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,v=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${p} coords = getOutputCoords();\n        bool hasNextCol = ${d[u-1]} < ${l[u-1]-1};\n        bool hasNextRow = ${d[u-2]} < ${l[u-2]-1};\n        ${i}\n        ivec4 srcIdx = ivec4(sourceLocR${c}, sourceLocG${c},\n          sourceLocB${c}, sourceLocA${c}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${v};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${v};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}};function qB(e,t,n,r=null){let a=t.shape[0],s=t.shape[1];null!=r&&(a=r.shape[0],s=r.shape[1]);let i=Jf.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:a,outSize:Math.ceil(s/i)},l=new HB(o,n,null==r),u=[t];null!=r&&u.push(r);let p=e.runWebGLProgram(l,u,"int32");if(1===p.shape[1])return p;let d=qB(e,t,n,p);return e.disposeIntermediateTensorInfo(p),d}function KB(e,t,n,r=null){let a=null!=r?r.shape:t.shape,s=a[a.length-1],i=Jf.computeOptimalWindowSize(s),o=new jB(a,i,n,null==r),l=null==r?[t]:[t,r],u=e.runWebGLProgram(o,l,"int32");if(u.shape.length===t.shape.length){let r=KB(e,t,n,u);return e.disposeIntermediateTensorInfo(u),r}return u}function XB(e,t,n,r){let a=[n];if(Jf.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!Pe().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let n=[],s=e.texData.get(t.dataId),i=t;null!==s&&s.isPacked&&(i=e.unpackTensor(t),n.push(i));let[o,l]=Jf.computeOutAndReduceShapes(i.shape,a),u=ka.sizeFromShape(l),p=gB({inputs:{x:i},backend:e,attrs:{shape:[-1,u]}});n.push(p);let d=qB(e,p,r);n.push(d);let h=gB({inputs:{x:d},backend:e,attrs:{shape:o}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return KB(e,t,r)}var YB={kernelName:Ze,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=ka.parseAxisParam(s,a.shape),o=Jf.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=TB({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=Jf.getInnerMostAxes(i.length,l.shape.length)),Jf.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let p=XB(n,l,i[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};var ZB={kernelName:Je,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=ka.parseAxisParam(s,a.shape),o=Jf.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=TB({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=Jf.getInnerMostAxes(i.length,l.shape.length)),Jf.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let p=XB(n,l,i[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}},JB=oB({opSnippet:SP+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),QB={kernelName:Qe,backendName:"webgl",kernelFunc:JB},eW=oB({opSnippet:SP+"return log(x + sqrt(x * x + 1.0));"}),tW={kernelName:et,backendName:"webgl",kernelFunc:eW},nW=oB({opSnippet:SP+"\n  return atan(x);\n"}),rW={kernelName:tt,backendName:"webgl",kernelFunc:nW},aW=lB({opSnippet:jP+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+KP+"\n  return result;\n"}),sW={kernelName:rt,backendName:"webgl",kernelFunc:aW},iW=oB({opSnippet:SP+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),oW={kernelName:nt,backendName:"webgl",kernelFunc:iW},lW=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,p=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,c=e.padInfo.left;this.outputShape=e.outShape;let f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,y="0.0";if(f||(y="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${h}, ${c});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${p};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?m:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / max(count, 1.0)");let x=4*Math.floor(s/4),w=s%4,v=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${h}, ${c});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${p};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${x}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${v}\n          }\n\n          int xC = xCCorner + ${x};\n          if (${1===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${2===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${3===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${v}\n          }\n        }\n        setOutput(${b});\n      }\n    `}},uW=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,p=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,c=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;let b="avg"===t,x="0.0";if(b||(x="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${c};\n                wR += ${p}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${c} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(w="avgValue / max(count, 1.0)");let v=4*Math.floor(s/4),k=s%4,I=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${c};\n            wR += ${p}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${v}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${I}\n            }\n\n            int xC = xCCorner + ${v};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${I}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${I}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${I}\n            }\n          }\n        }\n        setOutput(${w});\n      }\n    `}};var pW={kernelName:at,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;yL(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;ka.assert(Jf.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));let u=Jf.computePool2DInfo(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&ka.arraysEqual(u.inShape,u.outShape))return YP({inputs:{x:a},backend:n});let p=new lW(u,"avg",!1);return n.runWebGLProgram(p,[a],"float32")}};var dW={kernelName:it,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,p=Jf.computePool3DInfo(a.shape,s,i,[1,1,1],o,l,u),d=new uW(p,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}},hW=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,p=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${p});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},cW=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,p=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,c=p-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${a}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var fW={kernelName:ot,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:p}=r,d=Jf.computePool3DInfo(i.shape,o,l,[1,1,1],u,p),h=new cW(d);return n.runWebGLProgram(h,[a],i.dtype)}};var mW={kernelName:st,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;yL([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,p=Jf.computePool2DInfo(i.shape,o,l,1,u),d=new hW(p);return n.runWebGLProgram(d,[a],i.dtype)}};var gW={kernelName:lt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;return EB({a:a,b:s,transposeA:i,transposeB:o,backend:n})}},yW=class{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],Jf.assertAndGetBroadcastShape(e,t),Jf.assertAndGetBroadcastShape(e,n);let i="0.0";null!=r&&(Jf.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=a&&(Jf.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}},bW=class{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Jf.assertAndGetBroadcastShape(e,t),Jf.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";null!=r&&(Jf.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=a&&(Jf.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}},xW={kernelName:tn,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:a,variance:s,offset:i,scale:o}=e;ka.assert(a.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),ka.assert(null==i||a.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),ka.assert(null==o||a.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=n;null==l&&(l=.001);let u=[r,a,s],p=null;null!=i&&(p=i.shape,u.push(i));let d=null;null!=o&&(d=o.shape,u.push(o));let h=Pe().getBool("WEBGL_PACK_NORMALIZATION")?new bW(r.shape,a.shape,s.shape,p,d,l):new yW(r.shape,a.shape,s.shape,p,d,l);return t.runWebGLProgram(h,u,u[0].dtype)}},wW=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=OL(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n,r=function(e){if(1===e)return"sourceLoc";if(e<=6)return vW.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);n=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${vW[t]} = start[${t}] + coords.${vW[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${n}\n        setOutput(getSource(${r}));\n      }\n    `}},vW=["x","y","z","w","u","v"];var kW=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=OL(this.rank),n=gP("coords",this.rank),r=gP("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,i=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}};function IW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r,[o,l]=Tf.parseSliceParams(a,s,i);if(Tf.assertParamsValid(a,o,l),0===ka.sizeFromShape(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){let e=n.texData.get(a.dataId),t=eP(e.values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,t)}let{isPacked:u}=n.texData.get(a.dataId),p=Tf.isSliceContinous(a.shape,o,l);if(u||!p){let e=Pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kW(l):new wW(l),t=[o];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),function(e,t,n,r){let a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),i=r.texData.get(s.dataId);Object.assign(i,a),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Tf.computeFlatOffset(t,ka.computeStrides(e.shape));a.slice&&(o+=a.slice.flatOffset),i.slice={flatOffset:o,origDataId:a.slice&&a.slice.origDataId||e.dataId};let l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}(a,o,l,n)}var SW={kernelName:kr,backendName:"webgl",kernelFunc:IW},NW={kernelName:ut,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;ka.assert(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));let o=s.reduce(((e,t)=>e*t)),l=Jf.getReshaped(a.shape,s,o),u=Jf.getPermuted(l.length,s.length),p=Jf.getReshapedPermuted(a.shape,s,o),d=Jf.getSliceBeginCoords(i,s.length),h=Jf.getSliceSize(p,i,s.length),c=[],f=gB({inputs:{x:a},backend:n,attrs:{shape:l}}),m=TB({inputs:{x:f},backend:n,attrs:{perm:u}}),g=gB({inputs:{x:m},backend:n,attrs:{shape:p}}),y=IW({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return c.push(f),c.push(m),c.push(g),c.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}};var TW={kernelName:pt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.readSync(a.dataId),l=n.readSync(s.dataId),u=vz(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}};var _W={kernelName:dt,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{a:a,b:s}=n,i=Pe().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=Pe().getNumber("WEBGL_VERSION");if(r.shouldExecuteOnCPU([a,s])||1===o){let e=r.texData.get(a.dataId).values,t=r.texData.get(s.dataId).values,[n,i]=Iz(a.shape,s.shape,e,t,a.dtype),o=r.makeTensorInfo(i,a.dtype);return r.texData.get(o.dataId).values=n,o}return t=i?new XP("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",a.shape,s.shape,!1):new qP("\n  return float(int(a.r) & int(b.r));\n",a.shape,s.shape),r.runWebGLProgram(t,[a,s],a.dtype)}};var CW={kernelName:ct,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),i=n.readSync(a.dataId),o=Jf.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},EW=lB({opSnippet:"return float(a != b);",cpuKernelImpl:Gz,dtype:"bool"}),$W={kernelName:Un,backendName:"webgl",kernelFunc:EW};function AW(e){let{inputs:t,backend:n}=e,{input:r}=t;return YP({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}var FW={kernelName:sr,backendName:"webgl",kernelFunc:AW},RW="return float(int(x));";var DW={kernelName:ft,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r,attrs:a}=t,{x:s}=n,{dtype:i}=a;if("complex64"===i){if("complex64"===s.dtype)return YP({inputs:{x:s},backend:r});let t=op(s.shape),n=e({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),a=JP({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===s.dtype){let t=AW({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!ka.hasEncodingLoss(s.dtype,i)){let e=YP({inputs:{x:s},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([s])){let e=r.texData.get(s.dataId).values,[t,n,a]=Sz(e,s.shape,s.dtype,i);return r.makeTensorInfo(t,n,a)}if("int32"===i)return function(e,t){let n=new IP(e.shape,RW),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,r);if("bool"===i){let e=r.makeTensorInfo([],"bool",ka.getTypedArrayFromDType("bool",1)),t=EW({inputs:{a:s,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}},MW="return ceil(x);",OW=oB({opSnippet:MW,packedOpSnippet:MW,cpuKernelImpl:Nz}),LW={kernelName:mt,backendName:"webgl",kernelFunc:OW},zW=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}},PW=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}};var BW={kernelName:gt,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{clipValueMin:i,clipValueMax:o}=a;t=Pe().getBool("WEBGL_PACK_CLIP")?new PW(s.shape):new zW(s.shape);let l=[[i],[o]];return r.runWebGLProgram(t,[s],s.dtype,l)}},WW=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}};function VW(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}var UW={kernelName:bt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new WW(r.shape),i=[VW(r,a.complexTensorInfos.real),VW(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}},GW=class{constructor(e){this.outputShape=[],this.outputShape=Jf.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));let t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){let r=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${r}));`)}let r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}},HW=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Jf.computeOutShape(e,t);let n=this.outputShape,r=n.length,a=OL(r),s=gP("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));let o=new Array(e.length-1);o[0]=e[0][t];for(let n=1;n<o.length;n++)o[n]=o[n-1]+e[n][t];let l=i[t],u=i.slice(-2),p=i.join(),d=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${p}), vec2(${u.join()}));\n        }`;for(let e=1;e<o.length;e++){let t=o[e-1];d+=`\n        if (${l} < ${o[e]}  && ${l} >= ${o[e-1]}) {\n          return getChannel(\n            getT${e}(${jW(i,l,t)}),\n            vec2(${jW(u,l,t)}));\n        }`}let h=o.length,c=o[o.length-1];d+=`\n        return getChannel(\n          getT${h}(${jW(i,l,c)}),\n          vec2(${jW(u,l,c)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${d}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}};function jW(e,t,n){let r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function qW(e){let{inputs:t,backend:n}=e,{input:r}=t;return YP({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}var KW={kernelName:un,backendName:"webgl",kernelFunc:qW};function XW(e,t,n){let r=e[0].dtype;if("complex64"===r){let r=e.map((e=>AW({inputs:{input:e},backend:n}))),a=e.map((e=>qW({inputs:{input:e},backend:n}))),s=XW(r,t,n),i=XW(a,t,n),o=JP({inputs:{real:s,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),a.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),o}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){let a=e.map((e=>{let r=[-1,ka.sizeFromShape(e.shape.slice(t))];return gB({inputs:{x:e},backend:n,attrs:{shape:r}})})),s=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=Jf.computeOutShape(a.map((e=>e.shape)),1),o=1===a[0].shape[0],l=Tz(s,i,r,o),u=Jf.computeOutShape(e.map((e=>e.shape)),t),p=n.makeTensorInfo(u,r,l);return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}let s=e.filter((e=>ka.sizeFromShape(e.shape)>0)),i=Pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){let t=i?new IP(e[0].shape,$P):new LP(e[0].shape,$P);return n.runWebGLProgram(t,e,r)}let o=Pe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){let e=[];for(let r=0;r<s.length;r+=o){let a=s.slice(r,r+o);e.push(XW(a,t,n))}let r=XW(e,t,n);for(let t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){let e=new HW(s.map((e=>e.shape)),t);return n.runWebGLProgram(e,s,r)}let{tensors2D:l,outShape:u}=function(e,t,n){let r=Jf.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>gB({inputs:{x:e},attrs:{shape:[-1,ka.sizeFromShape(e.shape.slice(t))]},backend:n}))),outShape:r}}(s,t,n),p=new GW(l.map((e=>e.shape))),d=n.runWebGLProgram(p,l,r);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));let h=gB({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),h}function YW(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=ka.parseAxisParam(a,t[0].shape)[0],i=t.map((e=>e.shape));Jf.assertParamsConsistent(i,s);let o=Jf.computeOutShape(t.map((e=>e.shape)),s);if(0===ka.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter((e=>ka.sizeFromShape(e.shape)>0));return 1===l.length?YP({inputs:{x:l[0]},backend:n}):XW(l,s,n)}var ZW={kernelName:xt,backendName:"webgl",kernelFunc:YW},JW=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,p=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,c=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1,x="",w="";n&&(x=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,w="result = activation(result);");let v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${p};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${c}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${c}) *\n                    getW(wR, wC, ${c}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${c}, xR, xC) *\n                    getW(wR, wC, ${c}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${c}, d2),\n                getW(wR, wC, ${c} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${c}),\n                  getX(batch, xR, xC, ${c} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${c}, xR, xC),\n                  getX(batch, ${c} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${c}, d2),\n                getW(wR, wC, ${c} + 1, d2),\n                getW(wR, wC, ${c} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${c}),\n                  getX(batch, xR, xC, ${c} + 1),\n                  getX(batch, xR, xC, ${c} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${c}, xR, xC),\n                  getX(batch, ${c} + 1, xR, xC),\n                  getX(batch, ${c} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${v}\n        ${w}\n        setOutput(result);\n      }\n    `}},QW=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,p=e.filterDepth,d=e.filterHeight,h=e.filterWidth,c=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${s}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${p}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${c}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${c}) *\n                  getW(wF, wR, wC, ${c}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${c}),\n                  getX(batch, xF, xR, xC, ${c} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${c}, d2),\n                  getW(wF, wR, wC, ${c} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${c}),\n                  getX(batch, xF, xR, xC, ${c} + 1),\n                  getX(batch, xF, xR, xC, ${c} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${c}, d2),\n                  getW(wF, wR, wC, ${c} + 1, d2),\n                  getW(wF, wR, wC, ${c} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},eV=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=VL(this.outputShape.length);let s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,p=u,d="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<u;e++)d+=`\n           vec4 xTexelC${2*e};\n           int xTexelC${2*e}Ready;\n           vec4 xTexelC${2*e+1};\n           int xTexelC${2*e+1}Ready;\n           vec4 xC${e};`;d+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let e=0;e<u;e++)d+=`\n           xTexelC${2*e} = vec4(0.0);\n           xTexelC${2*e}Ready = 0;\n           xTexelC${2*e+1} = vec4(0.0);\n           xTexelC${2*e+1}Ready = 0;\n           xC${e} = vec4(0.0);`;d+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let t=0;t<(p+1)/2;t++){let n=2*t;if(d+=`\n           xC = xCCorner + ${n*o};\n           `,1===i){if(n<u&&(s%2==1?(d+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n               `,d+=1===o&&n>0?`\n                 xC${n} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${n} = vec4(previous.zw, xTexelC${n}.xy);\n                   } else {\n                     xC${n} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                   }\n                   `):d+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xC${n} = xTexelC${n};\n                 `,n+1<u)){let e=s%2==0?ka.nearestLargerEven(o):o;o%2==0&&s%2==1||o%2!=0&&s%2!=1?(d+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                     xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${n+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${n+1}Ready = 1;\n                   }\n                   `,d+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${n+1} = vec4(previous.zw, xTexelC${n+1}.xy);\n                     } else {\n                      xC${n+1} = vec4(0.0, 0.0, xTexelC${n+1}.xy);\n                     }\n                     `:`\n                     xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.xy);\n                     `):d+=1===e?`\n                     xC${n+1} = xTexelC${n};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                       xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${n+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${n+1}Ready = 1;\n                     }\n\n                     xC${n+1} = xTexelC${n+1};\n                     `}}else n<u&&(s%2==1?(d+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n               `,n+1<u&&(d+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${n+1} = vec4(xTexelC${n+1}.xy, final.xy);\n                 `)):(d+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(\n                   xTexelC${n}.xy, xTexelC${n+1}.xy);\n               `,n+1<u&&(d+=`\n                   xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n                 `)));n<u&&(d+=`\n             wTexel = getW(r, ${n}, d1, d2);\n             dotProd += xC${n}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${n}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,n+1<u&&(d+=`\n               wTexel = getW(r, ${n+1}, d1, d2);\n               dotProd += xC${n+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${n+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}d+="\n     }\n   ",d+="\n     }\n   ",d+="\n     }\n   ";let h="",c="";n&&(h=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:a?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,c="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${h}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${d}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${c}\n         setOutput(result);\n       }\n     `}},tV=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=VL(this.outputShape.length);let{dataFormat:n}=t,r=xL(),a="channelsLast"===n,s=a?1:2,i=a?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)l+=`\n          blockIndex = rc.z + ${t};\n          pos = rc.y + ${e};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}};function nV(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function rV({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let l,u=e.shape,p=r.texData.get(e.dataId),d=n.inChannels,h=u[0]*u[1]*u[2],c=n.outChannels,f="channelsLast"===n.dataFormat,m=[];if(null!=s){let e=nV(s.shape,f);null!=e&&(s=gB({inputs:{x:s},backend:r,attrs:{shape:e}}),m.push(s))}if(null!=a){let e=nV(a.shape,f);null!=e&&(a=gB({inputs:{x:a},backend:r,attrs:{shape:e}}),m.push(a))}if((1!==h&&1!==c||!(d>CB))&&p.isPacked&&f&&null!=p.texture&&u[2]%2!=0&&ka.arraysEqual(p.shape.slice(-3),u.slice(-3))){let d=u[0]*u[1]*(u[2]+1),h={dataId:e.dataId,shape:[1,d,n.inChannels],dtype:e.dtype},c=p.shape;p.shape=p.shape.slice(),p.shape[p.shape.length-2]++,ka.assert(sL(p.shape,h.shape),(()=>`packed reshape ${p.shape} to ${h.shape} isn't free`));let f=gB({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});m.push(f);let g=EB({a:h,b:f,backend:r,transposeA:false,transposeB:false,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),y=r.texData.get(g.dataId);ka.assert(y.isPacked,(()=>"batchMatMul result is expected to be packed")),p.shape=c,y.shape=n.outShape,l=YP({inputs:{x:g},backend:r}),l.shape=n.outShape,m.push(g)}else{let u=n.outHeight*n.outWidth,p=gB({inputs:{x:e},backend:r,attrs:{shape:f?[n.batchSize,u,n.inChannels]:[n.batchSize,n.inChannels,u]}}),d=gB({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),h=EB({a:f?p:d,b:f?d:p,transposeA:!f,transposeB:false,backend:r,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i});l=gB({inputs:{x:h},backend:r,attrs:{shape:n.outShape}}),m.push(p),m.push(d),m.push(h)}for(let e of m)r.disposeIntermediateTensorInfo(e);return l}function aV({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:l,filterHeight:u,inChannels:p,outWidth:d,outHeight:h,dataFormat:c}=n,f="channelsLast"===c,m=l*u*p,g=h*d,y=[n.batchSize,m,g],b=[];if(null!=s){let e=nV(s.shape,f);null!=e&&(s=gB({inputs:{x:s},backend:r,attrs:{shape:e}}),b.push(s))}if(null!=a){let e=nV(a.shape,f);null!=e&&(a=gB({inputs:{x:a},backend:r,attrs:{shape:e}}),b.push(a))}let x=gB({inputs:{x:t},backend:r,attrs:{shape:[1,m,ka.sizeFromShape(t.shape)/m]}});b.push(x);let w=new tV(y,n),v=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],k=r.runWebGLProgram(w,[e],"float32",v),I=gB({inputs:{x:k},backend:r,attrs:{shape:y}});b.push(k),b.push(I);let S=null!=a,N=null!=s,T="leakyrelu"===o,_=o?uB(o,!0):null,C=new pB(f?I.shape:x.shape,f?x.shape:I.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],!0,!1,S,_,N,T),E=f?[I,x]:[x,I];if(a&&E.push(a),N&&E.push(s),T){let e=r.makeTensorInfo([],"float32",ka.createScalarValue(i,"float32"));E.push(e),b.push(e)}let $=r.runWebGLProgram(C,E,"float32"),A=gB({inputs:{x:$},backend:r,attrs:{shape:n.outShape}});b.push($);for(let e of b)r.disposeIntermediateTensorInfo(e);return A}var sV={kernelName:wt,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i}=n,{strides:o,pad:l,dataFormat:u,dilations:p,dimRoundingMode:d}=a,h=Jf.convertConv2DDataFormat(u),c=Jf.computeConv2DInfo(s.shape,i.shape,o,p,l,d,!1,h);if(1!==c.filterHeight||1!==c.filterWidth||1!==c.dilationHeight||1!==c.dilationWidth||1!==c.strideHeight||1!==c.strideWidth||"SAME"!==c.padInfo.type&&"VALID"!==c.padInfo.type)if(c.strideWidth<=2&&"channelsLast"===h&&Pe().getBool("WEBGL_EXP_CONV")){let e=new eV(c),n=[[c.padInfo.top,c.padInfo.left],[c.strideHeight,c.strideWidth],[c.dilationHeight,c.dilationWidth],[c.inHeight,c.inWidth]];t=r.runWebGLProgram(e,[s,i],"float32",n)}else if(Pe().getBool("WEBGL_CONV_IM2COL"))t=aV({x:s,filter:i,convInfo:c,backend:r});else{let e=new JW(c);t=r.runWebGLProgram(e,[s,i],"float32")}else t=rV({x:s,filter:i,convInfo:c,backend:r});let f=gB({inputs:{x:t},backend:r,attrs:{shape:c.outShape}});return r.disposeIntermediateTensorInfo(t),f}},iV=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${s?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},oV=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,u=s?2:3,p=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${p}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},lV=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${a};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},uV=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${a}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var pV={kernelName:vt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:p}=r,d=Jf.convertConv2DDataFormat(l),h=Jf.computeConv2DInfo(a.shape,p,i,1,o,u,!1,d),c=new iV(h);return n.runWebGLProgram(c,[a,s],"float32")}},dV=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=VL(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}};var hV={kernelName:kt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:p}=r,d=Jf.convertConv2DDataFormat(u),h=Jf.computeConv2DInfo(i,s.shape,o,1,l,p,!1,d);if(Pe().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){let e=[[h.strideHeight,h.strideWidth]],t=new dV(h);return n.runWebGLProgram(t,[a,s],"float32",e)}{let e=new oV(h);return n.runWebGLProgram(e,[a,s],"float32")}}};var cV={kernelName:It,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=Jf.computeConv3DInfo(a.shape,s.shape,i,l,o),p=new QW(u);return n.runWebGLProgram(p,[a,s],"float32")}};var fV={kernelName:St,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r,u=Jf.computeConv3DInfo(a.shape,l,i,1,o),p=new lV(u);return n.runWebGLProgram(p,[a,s],"float32")}};var mV,gV={kernelName:Nt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r,u=Jf.computeConv3DInfo(l,s.shape,o,1,i),p=new uV(u);return n.runWebGLProgram(p,[a,s],"float32")}},yV=oB({opSnippet:iB+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${KP}\n  return result;\n`}),bV={kernelName:Tt,backendName:"webgl",kernelFunc:yV},xV=oB({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),wV={kernelName:_t,backendName:"webgl",kernelFunc:xV},vV=class{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[s,i,o,l]=e,[u]=t,[p,d]=n;this.outputShape=[u,p,d,l];let h="bilinear"===r?1:0,[c,f]=[i-1+".0",o-1+".0"],[m,g,y]=p>1?[""+(i-1)/(p-1),"(y2-y1) * height_ratio",`y1*${c} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${c}`],[b,x,w]=d>1?[""+(o-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${x};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${c} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}},kV={kernelName:$t,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,p=new vV(a.shape,s.shape,o,l,u);return n.runWebGLProgram(p,[a,s,i],"float32")}};!function(e){e.Prod="*",e.Sum="+"}(mV||(mV={}));var IV=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let a=this.outputShape.length,s=this.op===mV.Prod?"1.0":"0.0",i=n?s:`getX(${SV(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${OL(a)} coords = getOutputCoords();\n        int end = ${NV(a,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${NV(a,"coords",this.op)} = idx;\n          val ${this.op}= getX(${SV(a,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}};function SV(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function NV(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function TV(e,t,n,r,a,s){let i=t.shape.length,o=Jf.getAxesPermutation([r],i),l=t;null!=o&&(l=TB({inputs:{x:t},backend:n,attrs:{perm:o}}));let u=Jf.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let p=l.shape[u],d=YP({inputs:{x:l},backend:n});for(let t=0;t<=Math.ceil(Math.log2(p))-1;t++){let r=new IV(e,l.shape,!1,s),a=[[t]],i=d;d=n.runWebGLProgram(r,[d],d.dtype,a),n.disposeIntermediateTensorInfo(i)}if(a){let t=new IV(e,l.shape,a,s),r=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){let e=TB({inputs:{x:d},backend:n,attrs:{perm:Jf.getUndoAxesPermutation(o)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),e}return d}var _V={kernelName:Ct,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return TV(mV.Prod,a,n,s,i,o)}};var CV={kernelName:Et,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return TV(mV.Sum,a,n,s,i,o)}};var EV={kernelName:At,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){let e=n.readSync(a.dataId),t=n.readSync(s.dataId),r=vz(e,t,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,r)}if(2===a.shape.length){let e=n.bufferSync(a),t=n.bufferSync(s),r=kz(e,t,i,o);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}},$V=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};var AV={kernelName:Ft,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=("NHWC"===i?a.shape[1]:a.shape[2])*s,u=("NHWC"===i?a.shape[2]:a.shape[3])*s,p=("NHWC"===i?a.shape[3]:a.shape[1])/(s*s),d=new $V("NHWC"===i?[o,l,u,p]:[o,p,l,u],s,i);return n.runWebGLProgram(d,[a],a.dtype)}},FV=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=VL(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");let p=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${p}\n        ${u}\n        setOutput(result);\n      }\n    `}},RV=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=VL(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,p=e.filterWidth,d=p,h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<p;e++)h+=`\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;h+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let e=0;e<p;e++)h+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let e=0;e<(d+1)/2;e++){let t=2*e;if(h+=`\n          xC = xCCorner + ${t*l};\n          `,1===o){if(t<p&&(i%2==1?(h+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n              `,h+=1===l&&t>0?`\n                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                  }\n                  `):h+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xC${t} = xTexelC${t};\n                `,t+1<p)){let e=i%2==0?ka.nearestLargerEven(l):l;l%2==0&&i%2==1||l%2!=0&&i%2!=1?(h+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${t+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${t+1}Ready = 1;\n                  }\n                  `,h+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                    } else {\n                     xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                    }\n                    `:`\n                    xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                    `):h+=1===e?`\n                    xC${t+1} = xTexelC${t};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${t+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${t+1}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${t+1};\n                    `}}else t<p&&(i%2==1?(h+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n              `,t+1<p&&(h+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                `)):(h+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${t}.xy, xTexelC${t+1}.xy);\n              `,t+1<p&&(h+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                `)));t<p&&(h+=`\n            wTexel = getW(r, ${t}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,t+1<p&&(h+=`\n              wTexel = getW(r, ${t+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}h+="\n    }\n  ",h+="\n      }\n    ";let c="",f="";n&&(c=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${c}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${h}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}};var DV={kernelName:Rt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r,p=l;null==p&&(p=[1,1]),ka.assert(Jf.eitherStridesOrDilationsAreOne(i,p),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`));let d,h=Jf.computeConv2DInfo(a.shape,s.shape,i,p,o,u,!0);d=Pe().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new RV(h):new FV(h);let c=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[a,s],"float32",c)}},MV=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},OV=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var LV={kernelName:Dt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:p}=r,d=Jf.computeConv2DInfo(a.shape,p,i,o,l,u,!0),h=new MV(d);return n.runWebGLProgram(h,[a,s],"float32")}};var zV={kernelName:Mt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:p}=r,d=Jf.computeConv2DInfo(p,s.shape,i,o,l,u,!0),h=new OV(d);return n.runWebGLProgram(h,[a,s],"float32")}},PV=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}};var BV={kernelName:Ot,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=ka.sizeFromShape(r.shape),i=gB({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new PV(s),l=n.runWebGLProgram(o,[i],i.dtype),u=gB({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}},WV=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:p,left:d}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${s});\n      const ivec2 pads = ivec2(${p}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}};var VV={kernelName:Lt,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i}=n,{strides:o,pad:l,dilations:u}=a,p=Jf.computeDilation2DInfo(s.shape,i.shape,o,l,"NHWC",u),d=new WV(p);t=r.runWebGLProgram(d,[s,i],"float32");let h=gB({inputs:{x:t},backend:r,attrs:{shape:p.outShape}});return r.disposeIntermediateTensorInfo(t),h}};var UV={kernelName:Vt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=Jf.decodeEinsumEquation(a,s.length);Jf.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:p}=Jf.getEinsumComputePath(o,l),d=p.length,h=null,c=i.length,f=[];for(let e=0;e<d;++e){for(let t of p[e]){let e,{permutationIndices:r,expandDims:a}=Jf.getEinsumPermutation(c,l[t]);Jf.isIdentityPermutation(r)?e=s[t]:(e=TB({inputs:{x:s[t]},backend:n,attrs:{perm:r}}),f.push(e));let i=e.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);ka.arraysEqual(e.shape,i)||(e=gB({inputs:{x:e},backend:n,attrs:{shape:i}}),f.push(e)),null===h?h=e:(h=fB({inputs:{a:e,b:h},backend:n}),f.push(h))}e<d-1&&(u[e]>=0&&(h=SB({inputs:{x:h},backend:n,attrs:{axis:u[e]-(i.length-c),keepDims:!1}}),f.push(h)),c--)}for(let e of f)e!==h&&n.disposeIntermediateTensorInfo(e);return h}},GV=oB({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),HV={kernelName:Ut,backendName:"webgl",kernelFunc:GV},jV={kernelName:Gt,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=Pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new XP("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new qP("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)}},qV=lB({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:_z}),KV={kernelName:jt,backendName:"webgl",kernelFunc:qV},XV=oB({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${Jf.ERF_P};\n  float a1 = ${Jf.ERF_A1};\n  float a2 = ${Jf.ERF_A2};\n  float a3 = ${Jf.ERF_A3};\n  float a4 = ${Jf.ERF_A4};\n  float a5 = ${Jf.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),YV={kernelName:Ht,backendName:"webgl",kernelFunc:XV},ZV=oB({opSnippet:iB+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Cz,dtype:"float32"}),JV={kernelName:qt,backendName:"webgl",kernelFunc:ZV};function QV(e){let{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(ka.assert(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+a+1),o.splice(l,0,1),gB({inputs:{x:s},backend:r,attrs:{shape:o}})}var eU={kernelName:Kt,backendName:"webgl",kernelFunc:QV},tU="return exp(x) - 1.0;",nU=oB({opSnippet:tU,packedOpSnippet:tU,cpuKernelImpl:Ez}),rU={kernelName:Xt,backendName:"webgl",kernelFunc:nU},aU=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let a,s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${r}.0`:"1.0";if("real"===e)a="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}};function sU(e,t,n){let r=n.texData.get(e.dataId),a=ka.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=gB({inputs:{x:e},backend:n,attrs:{shape:[a/s,s]}}),o=i.shape,l=new aU("real",o,t),u=new aU("imag",o,t),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],d=n.runWebGLProgram(l,p,"float32"),h=n.runWebGLProgram(u,p,"float32"),c=JP({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);let f=gB({inputs:{x:c},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(c),f}var iU={kernelName:Yt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t;return sU(r,!1,n)}},oU=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}};function lU(e){let{backend:t,attrs:n}=e,{shape:r,value:a}=n,{dtype:s}=n;if(s=s||ka.inferDtype(a),"string"===s){let e=ka.getArrayFromDType(s,ka.sizeFromShape(r));return e.fill(a),t.makeTensorInfo(r,s,e)}{let e=new oU(r,a),n=[[a]];return t.runWebGLProgram(e,[],s,n)}}var uU,pU={kernelName:Zt,backendName:"webgl",kernelFunc:lU},dU=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},hU={kernelName:Jt,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,a=new dU(n.shape);return r.runWebGLProgram(a,[n],n.dtype)}},cU="return floor(x);",fU=oB({opSnippet:cU,packedOpSnippet:cU,cpuKernelImpl:$z}),mU={kernelName:Qt,backendName:"webgl",kernelFunc:fU},gU=lB({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),yU={kernelName:en,backendName:"webgl",kernelFunc:gU},bU=class{constructor(e){this.variableNames=["A"];let t=xL(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}},xU=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=xL(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}},wU={kernelName:aa,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:a}=t,{numChannels:s}=r,i="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,[l,u]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],p=[u,l],d=[u,l,s];if(o||i){let e=Pe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==uU||e!==vU)&&(vU=e,uU=document.createElement("canvas").getContext("2d",{willReadFrequently:vU})),uU.canvas.width=l,uU.canvas.height=u,uU.drawImage(a,0,0,l,u),a=uU.canvas}let h=n.makeTensorInfo(p,"int32");n.texData.get(h.dataId).usage=pO.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),a);let c=Pe().getBool("WEBGL_PACK")?new xU(d):new bU(d),f=n.runWebGLProgram(c,[h],"int32");return n.disposeData(h.dataId),f}},vU=Pe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");var kU={kernelName:oa,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i,bias:o,preluActivationWeights:l}=n,{strides:u,pad:p,dataFormat:d,dilations:h,dimRoundingMode:c,activation:f,leakyreluAlpha:m}=a,g=Jf.convertConv2DDataFormat(d),y=Jf.computeConv2DInfo(s.shape,i.shape,u,h,p,c,!1,g),b=[],x=null!=o,w=null!=l,v="leakyrelu"===f,k=()=>{let e=[s,i],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){let t=gB({inputs:{x:e},backend:r,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(x&&e.push(t(o,d)),w&&e.push(t(l,d)),v){let t=r.makeTensorInfo([],"float32",ka.createScalarValue(m,"float32"));e.push(t),b.push(t)}return e};if(1!==y.filterHeight||1!==y.filterWidth||1!==y.dilationHeight||1!==y.dilationWidth||1!==y.strideHeight||1!==y.strideWidth||"SAME"!==y.padInfo.type&&"VALID"!==y.padInfo.type)if(y.strideWidth<=2&&"channelsLast"===g&&Pe().getBool("WEBGL_EXP_CONV")){let e=f?uB(f,!0):null,n=new eV(y,x,e,w,v),a=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],s=k();t=r.runWebGLProgram(n,s,"float32",a)}else if(Pe().getBool("WEBGL_CONV_IM2COL"))t=aV({x:s,filter:i,convInfo:y,backend:r,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});else{let e=f?uB(f,!1):null,n=new JW(y,x,e,w,v),a=k();t=r.runWebGLProgram(n,a,"float32")}else t=rV({x:s,filter:i,convInfo:y,backend:r,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});let I=gB({inputs:{x:t},backend:r,attrs:{shape:y.outShape}});return b.push(t),b.forEach((e=>r.disposeIntermediateTensorInfo(e))),I}};var IU={kernelName:la,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:p,dimRoundingMode:d,activation:h,leakyreluAlpha:c}=r,f=[],m=p;null==m&&(m=[1,1]),ka.assert(Jf.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));let g,y=Jf.computeConv2DInfo(a.shape,s.shape,l,m,u,d,!0),b=Pe().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels==1,x=h?uB(h,b):null,w=[a,s],v=null!=i,k=null!=o,I="leakyrelu"===h;if(v&&w.push(i),k&&w.push(o),I){let e=n.makeTensorInfo([],"float32",ka.createScalarValue(c,"float32"));w.push(e),f.push(e)}g=b?new RV(y,v,x,k,I):new FV(y,v,x,k,I);let S=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],N=n.runWebGLProgram(g,w,"float32",S);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),N}},SU=class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let a=OL(n.length),s="\n    int index;";for(let e=0;e<this.sliceDim;e++)s+=`\n          index = round(getIndices(coords[0], ${e}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[e]};\n          flattenIndex += index * ${this.strides[e]};`;this.userCode=`\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${s}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}};var NU={kernelName:rn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,i=s[s.length-1],o=ka.sizeFromShape(r.shape),[l,u,p,d]=Jf.prepareAndValidate(r,a),h=gB({inputs:{x:a},backend:n,attrs:{shape:[u,i]}}),c=gB({inputs:{x:r},backend:n,attrs:{shape:[ka.sizeFromShape(r.shape)/p,p]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){let e=n.readSync(a.dataId),t=n.bufferSync(r),s=Az(e,t,r.dtype,u,i,p,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,s.values)}let f=new SU(i,d,[u,p],r.shape),m=n.runWebGLProgram(f,[c,h],c.dtype),g=gB({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(m),g}},TU=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=OL(this.rank),r=function(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let t=0;t<e.length;t++)2===t?r.push("index"):r.push(`${n[t]}`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}};function _U(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r,l=ka.parseAxisParam(i,a.shape)[0];if(Pe().get("DEBUG")){let e=n.readSync(s.dataId),t=a.shape[l];for(let n=0;n<e.length;++n){let r=e[n];ka.assert(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}let u=Jf.segment_util.collectGatherOpShapeInfo(a,s,l,o),p=ka.sizeFromShape(s.shape),d=[],h=gB({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),c=gB({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,p/u.batchSize]}});d.push(h),d.push(c);let f=[u.batchSize,u.outerSize,p/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){let e=n.bufferSync(c),t=n.bufferSync(h),r=Fz(t,e,f);return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}let m=new TU(h.shape,f),g=n.runWebGLProgram(m,[h,c],h.dtype);d.push(g);let y=gB({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}var CU={kernelName:nn,backendName:"webgl",kernelFunc:_U},EU=lB({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Rz,dtype:"bool"}),$U={kernelName:an,backendName:"webgl",kernelFunc:EU},AU=lB({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:Dz}),FU={kernelName:sn,backendName:"webgl",kernelFunc:AU};var RU={kernelName:ln,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t;return sU(r,!0,n)}},DU=oB({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),MU={kernelName:pn,backendName:"webgl",kernelFunc:DU},OU=oB({opSnippet:"return float(isinf(x));",dtype:"bool"}),LU={kernelName:dn,backendName:"webgl",kernelFunc:OU},zU=oB({opSnippet:"return float(isnan(x));",dtype:"bool"}),PU={kernelName:hn,backendName:"webgl",kernelFunc:zU},BU=lB({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Mz,dtype:"bool"}),WU={kernelName:fn,backendName:"webgl",kernelFunc:BU},VU=lB({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:Oz,dtype:"bool"}),UU={kernelName:mn,backendName:"webgl",kernelFunc:VU};var GU={kernelName:gn,backendName:"webgl",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=Lz(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}},HU=oB({opSnippet:iB+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:zz}),jU={kernelName:yn,backendName:"webgl",kernelFunc:HU},qU=oB({opSnippet:iB+"\n  return log(1.0 + x);\n"}),KU={kernelName:bn,backendName:"webgl",kernelFunc:qU},XU=lB({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),YU={kernelName:xn,backendName:"webgl",kernelFunc:XU},ZU=oB({opSnippet:"return float(!(x >= 1.0));"}),JU={kernelName:wn,backendName:"webgl",kernelFunc:ZU},QU=lB({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),eG={kernelName:vn,backendName:"webgl",kernelFunc:QU},tG=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}},nG=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}},rG={kernelName:Nn,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r,u=Pe().getBool("WEBGL_PACK_NORMALIZATION")?new nG(a.shape,s,i,o,l):new tG(a.shape,s,i,o,l);return n.runWebGLProgram(u,[a],a.dtype)}},aG=class{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}},sG={kernelName:Tn,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:p}=r,d=new aG(a.shape,o,l,u,p);return n.runWebGLProgram(d,[a,s,i],a.dtype)}};function iG(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=a.shape.length,l=ka.parseAxisParam(s,a.shape),u=l,p=Jf.getAxesPermutation(u,o),d=null!=p,h=n.shouldExecuteOnCPU([a]),c=a;if(d){if(h){let e=n.texData.get(c.dataId).values,t=new Array(o);for(let e=0;e<t.length;e++)t[e]=a.shape[p[e]];let r=cP(e,a.shape,a.dtype,p,t);c=n.makeTensorInfo(t,a.dtype),n.texData.get(c.dataId).values=r}else c=IB(a,p,n);u=Jf.getInnerMostAxes(u.length,o)}Jf.assertAxesAreInnerMostDims("max",u,o);let f,[m,g]=Jf.computeOutAndReduceShapes(c.shape,u),y=m;if(i&&(y=Jf.expandShapeToKeepDim(m,l)),h){let e=n.texData.get(c.dataId).values,t=Pz(e,ka.sizeFromShape(g),y,a.dtype);f=n.makeTensorInfo(y,a.dtype),n.texData.get(f.dataId).values=t}else f=function(e,t,n,r){let a=ka.sizeFromShape(t),s=gB({inputs:{x:e},attrs:{shape:[ka.sizeFromShape(e.shape)/a,a]},backend:r}),i=wB(s,e.dtype,"max",r),o=gB({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}(c,g,y,n);return d&&n.disposeIntermediateTensorInfo(c),f}var oG={kernelName:Cn,backendName:"webgl",kernelFunc:iG},lG=lB({opSnippet:jP+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+KP+"\n  return result;\n",cpuKernelImpl:Bz}),uG={kernelName:En,backendName:"webgl",kernelFunc:lG};var pG={kernelName:$n,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;yL(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;ka.assert(Jf.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));let u=Jf.computePool2DInfo(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&ka.arraysEqual(u.inShape,u.outShape))return YP({inputs:{x:a},backend:n});let p=new lW(u,"max",!1);return n.runWebGLProgram(p,[a],a.dtype)}};var dG={kernelName:Fn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,p=Jf.computePool3DInfo(a.shape,s,i,[1,1,1],o,u,l),d=new uW(p,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}},hG=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=a-1-e.padInfo.top,o=s-1-e.padInfo.left,l=a*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},cG=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,p=o-1-e.padInfo.front,d=l-1-e.padInfo.top,h=u-1-e.padInfo.left,c=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${d}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${c} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var fG={kernelName:Rn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:p}=r,d=Jf.computePool3DInfo(i.shape,o,l,[1,1,1],u,p),h=new uW(d,"max",!0),c=n.runWebGLProgram(h,[i],i.dtype),f=new cG(d),m=n.runWebGLProgram(f,[a,c],i.dtype);return n.disposeIntermediateTensorInfo(c),m}};var mG={kernelName:An,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;yL([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:p,dimRoundingMode:d}=r,h=Jf.computePool2DInfo(o.shape,l,u,1,p,d),c=new lW(h,"max",!0),f=n.runWebGLProgram(c,[o],o.dtype),m=new hG(h),g=n.runWebGLProgram(m,[a,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}};var gG={kernelName:Dn,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;ka.assert(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));let u=[1,1];ka.assert(Jf.eitherStridesOrDilationsAreOne(s,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`));let p=Jf.computePool2DInfo(r.shape,a,s,u,i),[d,h]=function(e,t,n,r){let a=new lW(n,"max",!1),s=r.runWebGLProgram(a,[e],"float32");return a=new lW(n,"max",!0,!0,t),[s,r.runWebGLProgram(a,[e],"float32")]}(r,o,p,l);return[d,h]}};var yG={kernelName:Mn,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:a,axis:s}=t,i=n,o=r.shape.length,l=ka.parseAxisParam(s,r.shape),u=l,p=Jf.getAxesPermutation(u,o),d=null!=p,h=i.shouldExecuteOnCPU([r]),c=[],f=r;if(d){if(h){let e=i.texData.get(f.dataId).values,t=new Array(o);for(let e=0;e<t.length;e++)t[e]=r.shape[p[e]];let n=cP(e,r.shape,r.dtype,p,t);f=i.makeTensorInfo(t,r.dtype),i.texData.get(f.dataId).values=n}else f=IB(r,p,i);c.push(f),u=Jf.getInnerMostAxes(u.length,o)}Jf.assertAxesAreInnerMostDims("sum",u,o);let[m,g]=Jf.computeOutAndReduceShapes(f.shape,u),y=m;a&&(y=Jf.expandShapeToKeepDim(m,l));let b=function(e,t,n,r){let a=ka.sizeFromShape(t),s=gB({inputs:{x:e},attrs:{shape:[ka.sizeFromShape(e.shape)/a,a]},backend:r}),i=wB(s,"float32","mean",r),o=gB({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}(f,g,y,i);for(let e of c)i.disposeIntermediateTensorInfo(e);return b}};var bG={kernelName:On,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=ka.parseAxisParam(s,a.shape),u=l,p=Jf.getAxesPermutation(u,o),d=a;null!=p&&(d=TB({inputs:{x:a},backend:n,attrs:{perm:p}}),u=Jf.getInnerMostAxes(u.length,a.shape.length)),Jf.assertAxesAreInnerMostDims("min",u,o);let h,[c,f]=Jf.computeOutAndReduceShapes(d.shape,u),m=gB({inputs:{x:d},backend:n,attrs:{shape:[-1,ka.sizeFromShape(f)]}}),g=wB(m,m.dtype,"min",n);if(i){h=gB({inputs:{x:g},backend:n,attrs:{shape:Jf.expandShapeToKeepDim(c,l)}})}else h=gB({inputs:{x:g},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=p&&n.disposeIntermediateTensorInfo(d),h}},xG=lB({opSnippet:jP+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+KP+"\n  return result;\n",cpuKernelImpl:Wz}),wG={kernelName:Ln,backendName:"webgl",kernelFunc:xG},vG=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=OL(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}},kG=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=OL(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=gP("rc",r),l=gP("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,p=1===r?"source":`vec2(${l.slice(-2).join()})`,d="reflect"===n?0:1,h="";if(1===r){let e=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;h=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${p});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${p});\n        }\n      `}else{let e=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;h=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${p});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${p});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${p});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${p});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}},IG={kernelName:zn,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:a,mode:s}=n,i=Pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kG(r.shape,a,s):new vG(r.shape,a,s);return t.runWebGLProgram(i,[r],r.dtype)}},SG=lB({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+KP+"\n  return result;\n"}),NG={kernelName:Pn,backendName:"webgl",kernelFunc:SG},TG=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}},_G=lB({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),CG={kernelName:Wt,backendName:"webgl",kernelFunc:_G},EG="return a - b;",$G=lB({opSnippet:EG,packedOpSnippet:EG,supportsComplex:!0,cpuKernelImpl:pP}),AG={kernelName:Hr,backendName:"webgl",kernelFunc:$G};function FG(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=ka.parseAxisParam([s],a.shape),o=iG({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=Jf.expandShapeToKeepDim(o.shape,i),u=gB({inputs:{x:o},backend:n,attrs:{shape:l}}),p=$G({inputs:{a:a,b:u},backend:n}),d=ZV({inputs:{x:p},backend:n}),h=SB({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),c=gB({inputs:{x:h},backend:n,attrs:{shape:l}}),f=_G({inputs:{a:d,b:c},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(c),f}var RG={kernelName:Fr,backendName:"webgl",kernelFunc:FG};var DG={kernelName:Bn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r,l=o?a:FG({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),u=l.shape[0],p=l.shape[1],d=new TG(u,p,s),h=[[i]],c=n.runWebGLProgram(d,[l],"int32",h);return o||n.disposeIntermediateTensorInfo(l),c}},MG=SP+"\n  return -x;\n";var OG={kernelName:Vn,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])){let e=r.texData.get(a.dataId),[t,n]=Uz(e.values,a.shape,a.dtype);return r.makeTensorInfo(n,a.dtype,t)}return t=Pe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new LP(a.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new IP(a.shape,MG),r.runWebGLProgram(t,[a],a.dtype)}},LG=ag.nonMaxSuppressionV3Impl;var zG={kernelName:Gn,backendName:"webgl",kernelFunc:function(e){Jf.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(a.dataId),p=n.readSync(s.dataId),{selectedIndices:d}=LG(u,p,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},PG=ag.nonMaxSuppressionV4Impl;var BG={kernelName:Hn,backendName:"webgl",kernelFunc:function(e){Jf.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,p=n.readSync(a.dataId),d=n.readSync(s.dataId),{selectedIndices:h,validOutputs:c}=PG(p,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([c]))]}},WG=ag.nonMaxSuppressionV5Impl;var VG={kernelName:jn,backendName:"webgl",kernelFunc:function(e){Jf.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,p=n.readSync(a.dataId),d=n.readSync(s.dataId),h=i,c=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=WG(p,d,h,c,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},UG=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}},GG={kernelName:Kn,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,u=ka.sizeFromShape(a.shape),p=new UG(u,i,o,l),d=gB({inputs:{x:a},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(p,[d],s);n.disposeIntermediateTensorInfo(d);let c=gB({inputs:{x:h},backend:n,attrs:{shape:[...a.shape,i]}});return n.disposeIntermediateTensorInfo(h),c}};function HG(e){let{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){let e=AW({inputs:{input:r},backend:n}),t=HG({inputs:{x:e},backend:n}),a=qW({inputs:{input:r},backend:n}),s=HG({inputs:{x:a},backend:n}),i=JP({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return lU({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}var jG={kernelName:na,backendName:"webgl",kernelFunc:HG};var qG={kernelName:qn,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){let t=AW({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=qW({inputs:{input:a},backend:r}),i=HG({inputs:{x:s},backend:r}),o=JP({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}return lU({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}};var KG={kernelName:Xn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return QV({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{ka.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),ka.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=YW({inputs:t.map((e=>{let t=QV({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}},XG=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=OL(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}},YG=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=OL(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=gP("rc",r),l=gP("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,p=1===r?"source":`vec2(${l.slice(-2).join()})`,d=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],h=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",c="";for(let e=0,t=1===r?2:4;e<t;e++)c+=`\n        ${d[e]}\n        if (${h}) {\n          result[${e}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${e}] = getChannel(getX(${l.join()}), ${p});\n        }\n      `;c+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${c}\n        setOutput(result);\n      }\n    `}},ZG=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;if(0===ka.sizeFromShape(a.shape)){return lU({backend:n,attrs:{shape:s.map(((e,t)=>e[0]+a.shape[t]+e[1])),value:i,dtype:a.dtype}})}let o=Pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new YG(a.shape,s,i):new XG(a.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[a],a.dtype,l)},JG={kernelName:Yn,backendName:"webgl",kernelFunc:ZG},QG=lB({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+KP+"\n  return result;\n"}),eH={kernelName:Jn,backendName:"webgl",kernelFunc:QG};var tH={kernelName:er,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a,l=s.shape.length,u=[],p=ka.parseAxisParam(i,s.shape),d=p,h=Jf.getAxesPermutation(d,l),c=s;if(null!=h&&(c=TB({inputs:{x:s},backend:r,attrs:{perm:h}}),d=Jf.getInnerMostAxes(d.length,l),u.push(c)),Jf.assertAxesAreInnerMostDims("prod",d,l),r.shouldExecuteOnCPU([c])){let e=r.texData.get(c.dataId).values,{outVals:n,outShape:a,outDtype:s}=Hz(c.shape,c.dtype,e,d);t=r.makeTensorInfo(a,s,n)}else{let[e,n]=Jf.computeOutAndReduceShapes(c.shape,d),a=ka.sizeFromShape(n),i=gB({inputs:{x:c},backend:r,attrs:{shape:[-1,a]}}),o=wB(i,ys(s.dtype),"prod",r);t=gB({inputs:{x:o},backend:r,attrs:{shape:e}}),u.push(i),u.push(o)}if(o){u.push(t);let e=Jf.expandShapeToKeepDim(t.shape,p);t=gB({inputs:{x:t},backend:r,attrs:{shape:e}})}return u.forEach((e=>r.disposeIntermediateTensorInfo(e))),t}};var nH={kernelName:tr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.readSync(e.dataId))),u=a.map((e=>e.shape)),p=n.readSync(s.dataId),d=n.readSync(i.dataId),[h,c,f]=jz(l,u,p,s.shape,s.dtype,d,i.shape,o),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,c);return m.concat([g])}};var rH={kernelName:nr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,p]=qz(i,r.shape,r.dtype,o,a.shape,l,s.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([p.length],r.dtype,p)]}};var aH={kernelName:rr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(a.dataId),p=n.readSync(s.dataId),d=n.readSync(i.dataId),h=o.map((e=>n.readSync(e.dataId))),c=o.map((e=>e.shape)),[f,m]=Kz(u,a.shape,p,s.shape,s.dtype,d,i.shape,h,c,l);return n.makeTensorInfo(f,s.dtype,m)}},sH=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=Xz(r,a,s,i);return t.makeTensorInfo([o.length],i,o)},iH={kernelName:ar,backendName:"webgl",kernelFunc:sH},oH=oB({opSnippet:"return 1.0 / x;"}),lH={kernelName:ir,backendName:"webgl",kernelFunc:oH},uH=oB({opSnippet:SP+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),pH={kernelName:or,backendName:"webgl",kernelFunc:uH},dH=oB({opSnippet:SP+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),hH={kernelName:cr,backendName:"webgl",kernelFunc:dH},cH=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,p=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n];u=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${p[0]/d[0]},\n          ${p[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${u};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}},fH=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,p=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n];u=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${p[0]/d[0]},\n          ${p[1]/d[1]},\n          ${p[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${u};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}};var mH={kernelName:dr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,p=Pe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new fH(a.shape,l,u,s,i):new cH(a.shape,l,u,s,i);return n.runWebGLProgram(p,[a],"float32")}},gH=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],p=o[1]/l[1],d=1/u,h=1/p,c=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${p});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${c});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};var yH={kernelName:hr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new gH(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}},bH=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,p=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";u=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${p[0]/d[0]},\n          ${p[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${u};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}},xH=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,p=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";u=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${p[0]/d[0]},\n          ${p[1]/d[1]},\n          ${p[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${u};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}};var wH={kernelName:ur,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,p=Pe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new xH(a.shape,l,u,s,i):new bH(a.shape,l,u,s,i);return n.runWebGLProgram(p,[a],a.dtype)}},vH=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],p=o[1]/l[1],d=1/u,h=1/p,c=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${p});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${c});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};var kH={kernelName:pr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new vH(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}},IH=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);let r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),a=OL(n);this.userCode=`\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}},SH=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=gP("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=OL(n);var o;function l(n){let r=e.map(((r,a)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(a,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${o=r.slice(),l(o)};\n          if(${a}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",l(e)}(r.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",l(e)}(r.slice())};\n            if(${a}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",l(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}};var NH={kernelName:fr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=a.shape.length,o=ka.parseAxisParam(s,a.shape);if(0===i)return YP({inputs:{x:a},backend:n});let l=Pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new SH(a.shape,o):new IH(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}},TH=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let a="";a="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},_H={kernelName:sa,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=n,l=new TH(r.shape,s),[u,p]=Jf.getImageCenter(i,r.shape[1],r.shape[2]),d=[[u,p,Math.sin(a),Math.cos(a)]];return o.runWebGLProgram(l,[r],r.dtype,d)}},CH=oB({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),EH={kernelName:mr,backendName:"webgl",kernelFunc:CH},$H=oB({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Yz}),AH={kernelName:gr,backendName:"webgl",kernelFunc:$H},FH=class{constructor(e,t,n,r,a,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;let l=OL(a.length),u=OL(s.length),p="";1===n?p="i":2===n&&(p="i, j");let d=`getIndices(${p})`,h="";1===r?h="i":2===r&&(h="i, coords[1]");let c=`getUpdates(${h})`,f="";o&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides";this.userCode=`\n        ${l} strides = ${l}(${a});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${d});\n              flattenedIndex += index * ${g};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${c};\n              found = true;\n            }\n          }\n          setOutput(mix(${m}, sum, float(found)));\n        }\n      `}},RH=class{constructor(e,t,n,r,a,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;let l=OL(a.length),u=OL(s.length),p="";1===n?p="i":2===n&&(p="i, j");let d=`getIndices(${p})`,h="";1===r?h="i":2===r&&(h="i, coords[1]");let c=`getUpdates(${h})`,f="";o&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides",y=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${l} strides = ${l}(${a});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${d});\n              flattenedIndex += index.xz * ${g};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${y};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${c};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${m}, sum, found));\n        }\n      `}};var DH={kernelName:yr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:p,outputSize:d}=Jf.calculateShapes(s,a,i),h=[d/u,u];if(0===d)return n.makeTensorInfo(i,a.dtype);let c,f=gB({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),m=gB({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));c=Pe().getBool("WEBGL_PACK")?new RH(l,o,f.shape.length,m.shape.length,p,h):new FH(l,o,f.shape.length,m.shape.length,p,h);let y=n.runWebGLProgram(c,[m,f,g],m.dtype),b=gB({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(g),b}},MH=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,s=2===Pe().getNumber("WEBGL_VERSION")?"while (left < right) {":a,i="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${s}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${i} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}};var OH={kernelName:xr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=new MH(a.shape[0],a.shape[1],s.shape[1],i),l=[[a.shape[1]]];return n.runWebGLProgram(o,[a,s],"int32",l)}},LH=class{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{let n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&s.push(`${n[r]}`);r=s.join(),a=i.join()}let s=OL(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}};var zH={kernelName:wr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=new LH(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,s],gs(a.dtype,s.dtype))}},PH=oB({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Jf.SELU_SCALEALPHA};\n  float scale = ${Jf.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),BH={kernelName:vr,backendName:"webgl",kernelFunc:PH},WH=oB({opSnippet:iB+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Jz}),VH={kernelName:Tr,backendName:"webgl",kernelFunc:WH},UH=oB({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),GH={kernelName:Nr,backendName:"webgl",kernelFunc:UH},HH=oB({opSnippet:iB+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${KP}\n  return result;\n`}),jH={kernelName:Ir,backendName:"webgl",kernelFunc:HH},qH=oB({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),KH={kernelName:Sr,backendName:"webgl",kernelFunc:qH},XH=oB({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),YH={kernelName:_r,backendName:"webgl",kernelFunc:XH},ZH={kernelName:$r,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;ka.assert(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));let o=s.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...i);for(let e=1+s.length;e<a.shape.length;++e)l.push([0,0]);let u=[],p=ZG({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),d=Jf.getReshaped(p.shape,s,o,!1),h=Jf.getPermuted(d.length,s.length,!1),c=Jf.getReshapedPermuted(p.shape,s,o,!1),f=gB({inputs:{x:p},backend:n,attrs:{shape:d}}),m=TB({inputs:{x:f},backend:n,attrs:{perm:h}}),g=gB({inputs:{x:m},backend:n,attrs:{shape:c}});return u.push(p),u.push(f),u.push(m),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};var JH={kernelName:Rr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n         ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);let o=n.readSync(r.dataId),l=n.readSync(a.dataId),u=n.readSync(s.dataId),p=n.readSync(i.dataId)[0],[d,h,c,f,m]=tP(o,r.shape,r.dtype,l,a.dtype,u,p);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,c),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};var QH={kernelName:Dr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[u,p,d]=nP(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(p,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};var ej={kernelName:Mr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,p]=rP(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(p,r.dtype,u)}};var tj={kernelName:Or,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,p]=rP(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(p,r.dtype,u)}};var nj={kernelName:Lr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:p,strides:d,outputSize:h}=Jf.calculateShapes(s,a,o);if("string"===s.dtype){let e=n.bufferSync(a),t=n.bufferSync(s),r=ka.decodeString(n.readSync(i.dataId)[0]),c=Zz(e,t,o,h,p,u,l,d,r,false);return n.makeTensorInfo(o,c.dtype,c.values)}let c=new FH(u,l,a.shape.length,s.shape.length,d,[h,1],false),f=n.runWebGLProgram(c,[s,a,i],s.dtype),m=gB({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),m}};var rj={kernelName:Ar,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=ka.parseAxisParam(i,a.shape)[0],l=Jf.prepareSplitSize(a,s,o),u=a.shape.length,p=new Array(u).fill(0),d=a.shape.slice();return l.map((e=>{let t=[...d];t[o]=e;let r=IW({inputs:{x:a},backend:n,attrs:{begin:p,size:t}});return p[o]+=e,r}))}},aj="return sqrt(x);",sj=oB({opSnippet:aj,packedOpSnippet:aj,cpuKernelImpl:aP}),ij={kernelName:Cr,backendName:"webgl",kernelFunc:sj},oj=oB({opSnippet:"return x * x;"}),lj={kernelName:Pr,backendName:"webgl",kernelFunc:oj},uj="return (a - b) * (a - b);",pj=lB({opSnippet:uj,packedOpSnippet:uj}),dj={kernelName:zr,backendName:"webgl",kernelFunc:pj};var hj={kernelName:Br,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");let s=n.readSync(a.dataId),i=Jf.fromUint8ToStringArray(s),o=sP(i,"string",r);return n.makeTensorInfo(a.shape,"string",o)}};var cj={kernelName:ra,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){let{x:r}=e,a=SP+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,s=new IP(r.shape,a);return n.runWebGLProgram(s,[r],r.dtype)}},fj=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,a=OL(n.length),s=OL(n.length),i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${a} begin = ${a}(${e});\n      ${a} strides = ${a}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}};var mj={kernelName:Wr,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{begin:i,end:o,strides:l,beginMask:u,endMask:p,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:c}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:x,end:w,strides:v}=Tf.sliceInfo(s.shape,i,o,l,u,p,d,h,c);if(g)t=gB({inputs:{x:s},backend:r,attrs:{shape:m}});else if(y||b){ka.assert(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));let e=Tf.computeOutShape(x,w,v),n=IW({inputs:{x:s},backend:r,attrs:{begin:x,size:e}});t=gB({inputs:{x:n},backend:r,attrs:{shape:m}}),r.disposeIntermediateTensorInfo(n)}else if(r.shouldExecuteOnCPU([s])){let e=r.readSync(s.dataId),n=mo(s.shape,s.dtype,e),a=iP(f,n,v,x);t=r.makeTensorInfo(m,s.dtype,a.values)}else{let e=new fj(x,v,f);t=r.runWebGLProgram(e,[s],s.dtype)}let k=gB({inputs:{x:t},backend:r,attrs:{shape:m}});return r.disposeIntermediateTensorInfo(t),k}};var gj={kernelName:Vr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:p,dataSplits:d}=t,h=n.readSync(p.dataId),c=n.readSync(d.dataId),[f,m]=oP(h,c,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};var yj={kernelName:Ur,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[u,p,d]=lP(o,l,a),h=p.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",p),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};var bj={kernelName:Gr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(s.dataId),o=uP(i,a);return n.makeTensorInfo(s.shape,"int32",o)}},xj=oB({opSnippet:"return tan(x);"}),wj={kernelName:jr,backendName:"webgl",kernelFunc:xj},vj=oB({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),kj={kernelName:qr,backendName:"webgl",kernelFunc:vj};var Ij={kernelName:br,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=t,{}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:p,outputSize:d}=Jf.calculateShapes(i,s,a.shape),h=[d/u,u];if(0===d)return n.makeTensorInfo(a.shape,s.dtype);let c=gB({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=gB({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=gB({inputs:{x:a},backend:n,attrs:{shape:h}}),g=new FH(l,o,c.shape.length,f.shape.length,p,h,!1,!0),y=n.runWebGLProgram(g,[f,c,m],m.dtype),b=gB({inputs:{x:y},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}},Sj=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;let r=OL(this.rank),a=function(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let t=0;t<e.length;t++)r.push(`imod(${n[t]}, ${e[t]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}};function Nj(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){let e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>ka.decodeString(e))):e,r=mo(a.shape,a.dtype,t),i=dP(r,s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}let i=new Sj(a.shape,s);return n.runWebGLProgram(i,[a],a.dtype)}var Tj={kernelName:Kr,backendName:"webgl",kernelFunc:Nj},_j=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}},Cj=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}};function Ej(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function $j(e){let t=1;for(;t<e;)t*=2;return t}var Aj={kernelName:Xr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=Pe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Pe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=a.shape,p=u[u.length-1];if(n.shouldExecuteOnCPU([a])||p<o||s>l){let e=n.readSync(a.dataId),[t,r]=hP(e,u,a.dtype,s,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===p)return[a,lU({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let d=n.texData.get(a.dataId),h=null!==d&&d.isPacked,c=h?n.unpackTensor(a):a,f=ka.sizeFromShape(u)/p,m=gB({inputs:{x:c},attrs:{shape:[f,p]},backend:n});h&&Ej(n,c);let g=$j(s),y=$j(p),b=null,x=()=>null===b?[m,m]:[m,b],w=(e,t,r)=>{let a=x(),s=new _j(r),i=[[p],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=b;b=n.runWebGLProgram(s,a,"int32",i),Ej(n,o)};for(let e=1;e<g;e*=2){let t=2*e;for(let n=e;n>=1;n/=2)w(t,n,[f,y])}for(let e=y;e>g;e/=2){let t=x(),r=new Cj([f,e/2]),a=[[p],[null===b?1:0],[g]],s=b;b=n.runWebGLProgram(r,t,"int32",a),Ej(n,s);let i=g/2,o=2*i;for(let e=i;e>=1;e/=2)w(o,e,b.shape)}let v=b;b=IW({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,s]}}),Ej(n,v);let k=_U({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});Ej(n,m);let I=u.slice(0,-1);I.push(s),v=b,b=gB({inputs:{x:b},attrs:{shape:I},backend:n}),Ej(n,v);let S=k;return k=gB({inputs:{x:k},attrs:{shape:I},backend:n}),Ej(n,S),[k,b]}},Fj=class{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;let i,o="nearest"===n?1:2;switch(r){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${i} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}};var Rj={kernelName:Yr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[p,d,h,c]=a.shape,[f,m]=null!=u?u:[d,h],g=new Fj(d,h,i,o,l,[p,f,m,c]);return n.runWebGLProgram(g,[a,s],"float32")}};var Dj={kernelName:Jr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;yL(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:u}=fP(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};var Mj={kernelName:Qr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a,o=i.shape.length,l=a.shape[s],u=new Array(o-1),p=0;for(let e=0;e<o;e++)e!==s&&(u[p++]=i.shape[e]);let d=[],h=new Array(o).fill(0),c=i.shape.slice();c[s]=1;let f=new Array(l);for(let e=0;e<f.length;e++){h[s]=e;let t=IW({inputs:{x:i},backend:n,attrs:{begin:h,size:c}}),r=gB({inputs:{x:t},backend:n,attrs:{shape:u}});f[e]=r,d.push(t)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}},Oj=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,i=s*Math.ceil(a/n);this.outputShape=[r,i];let o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ",p="";a%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let d="";a%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}};var Lj,zj,Pj,Bj={kernelName:ea,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r,o=a.shape.length,l=[],u=0,p=Jf.getAxesPermutation([u],o),d=a;null!=p&&(d=TB({inputs:{x:a},backend:n,attrs:{perm:p}}),l.push(d),u=Jf.getInnerMostAxes(1,o)[0]);let h=Jf.segment_util.computeOutShape(d.shape,u,i),c=ka.sizeFromShape([d.shape[u]]),f=gB({inputs:{x:d},backend:n,attrs:{shape:[-1,c]}});l.push(f);let m=ys(a.dtype),g=(e,t,r,a,s)=>{let i=e.shape[0],o=e.shape[1],u=Jf.segment_util.segOpComputeOptimalWindowSize(o,s),p=new Oj({windowSize:u,inSize:o,batchSize:i,numSegments:s},t),d=n.compileAndRun(p,[e,r],a);if(l.push(d),d.shape[1]===s)return d;let h=sH({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),c=Nj({inputs:{x:h},backend:n,attrs:{reps:[o/u]}});return l.push(h),l.push(c),g(d,t,c,a,s)},y=gB({inputs:{x:g(f,"unsortedSegmentSum",s,m,i)},backend:n,attrs:{shape:h}}),b=y;if(null!=p){l.push(y);let e=Jf.getUndoAxesPermutation(p);b=TB({inputs:{x:b},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},Wj=[$B,FB,DB,OB,PB,VB,UB,GB,YB,ZB,QB,tW,rW,sW,oW,pW,dW,fW,mW,gW,xW,NW,TW,_W,CW,DW,LW,BW,QP,UW,ZW,sV,pV,hV,cV,fV,gV,bV,wV,kV,_V,CV,EV,AV,DV,LV,zV,BV,VV,UV,HV,jV,KV,YV,JV,eU,rU,iU,pU,hU,mU,yU,wU,kU,IU,NU,CU,$U,FU,ZP,RU,KW,MU,LU,PU,nB,WU,UU,GU,jU,KU,YU,JU,eG,rG,sG,oG,uG,pG,dG,fG,mG,gG,yG,bG,wG,IG,NG,DG,mB,OG,zG,BG,VG,$W,GG,qG,KG,JG,eH,sB,tH,nH,rH,aH,iH,FW,CG,lH,pH,hH,yB,mH,yH,wH,kH,NH,_H,EH,AH,DH,OH,zH,BH,VH,GH,jH,KH,SW,RG,YH,ZH,JH,QH,ej,tj,nj,rj,ij,lj,dj,hj,cj,mj,gj,yj,bj,AG,NB,wj,kj,Ij,Tj,Aj,Rj,_B,Dj,Mj,Bj,jG];for(let e of Wj)ga(e);!function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"}(Lj||(Lj={})),function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"}(zj||(zj={}));var Vj={kernelName:ia,backendName:"wasm",setupFunc:function(e){Pj=e.wasm.cwrap(ia,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:u,activation:p,leakyreluAlpha:d}=r,h=n.dataIdMap.get(a.dataId).id,c=n.dataIdMap.get(s.dataId).id,f=0;if(null!=i){let e=n.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${e.shape.length}.`);f=e.id}let m=null==o?0:n.dataIdMap.get(o.dataId).id,g=zj[p];if(null==g)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let y=l?a.shape[2]:a.shape[1],b=u?s.shape[1]:s.shape[2],x=Pl.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)),w=n.makeOutput([...x,y,b],a.dtype),v=n.dataIdMap.get(w.dataId).id,k=new Uint8Array(new Int32Array(a.shape).buffer),I=new Uint8Array(new Int32Array(s.shape).buffer);return Pj(h,k,a.shape.length,c,I,s.shape.length,l,u,g,f,m,d||0,v),w}};function Uj(e,t){let n;return{kernelName:e,backendName:"wasm",setupFunc:function(t){n=t.wasm.cwrap(e,null,["number","number","number"])},kernelFunc:function(e){let{backend:r,inputs:{x:a}}=e,s=r.dataIdMap.get(a.dataId).id,i=r.makeOutput(a.shape,t||a.dtype),o=r.dataIdMap.get(i.dataId).id;return 0===ka.sizeFromShape(i.shape)||n(s,Lj[a.dtype],o),i}}}var Gj=Uj(Ge),Hj=Uj(He),jj=Uj(je);function qj(e,t,n){let r;return{kernelName:e,backendName:"wasm",setupFunc:function(t){r=t.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:a}=e,{a:s,b:i}=a,o=t.dataIdMap.get(s.dataId).id,l=t.dataIdMap.get(i.dataId).id,u=null!=n?n:s.dtype,p=Jf.assertAndGetBroadcastShape(s.shape,i.shape),d=t.makeOutput(p,u);if(0===ka.sizeFromShape(p))return d;let h=new Uint8Array(new Int32Array(s.shape).buffer),c=new Uint8Array(new Int32Array(i.shape).buffer),f=t.dataIdMap.get(d.dataId).id;return r(o,h,s.shape.length,l,c,i.shape.length,Lj[s.dtype],f),d}}}var Kj,Xj=qj(qe);var Yj={kernelName:Ke,backendName:"wasm",setupFunc:function(e){Kj=e.wasm.cwrap(Ke,null,["array","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(0===ka.sizeFromShape(r.shape))return r;let a=t.map((e=>n.dataIdMap.get(e.dataId).id)),s=new Uint8Array(new Int32Array(a).buffer),i=n.dataIdMap.get(r.dataId).id;return Kj(s,a.length,Lj[r.dtype],i),r}};function Zj(e){let{inputs:{x:t},backend:n}=e;if("string"===t.dtype)return js(n.readSync(t.dataId),t.shape,t.dtype);let r=n.makeOutput(t.shape,t.dtype),a=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(a),r}var Jj,Qj={kernelName:on,backendName:"wasm",kernelFunc:Zj};function eq(e){let{inputs:t,backend:n,attrs:r}=e,[a,s]=function(e,t){let n=[],r=[];for(let a=0;a<e.length;++a)1!==e[a]&&n.push(e[a]),1!==e[t[a]]&&r.push(t[a]);for(let e=0;e<r.length;++e){let t=-1;for(let n=0;n<r.length;++n)r[n]>=e&&(-1===t||r[t]>r[n])&&(t=n);r[t]=e}return[n,r]}(t.x.shape,r.perm),i=!0;for(let e=0;e<s.length;e++)s[e]!==e&&(i=!1);let o=function(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:a,dtype:t.x.dtype};if(i){let e=Zj({inputs:t,backend:n});return e.shape=o,e}let u=n.makeOutput(o,l.dtype),p=n.dataIdMap.get(l.dataId).id,d=n.dataIdMap.get(u.dataId).id,h=new Uint8Array(new Int32Array(s).buffer),c=new Uint8Array(new Int32Array(l.shape).buffer);return Jj(p,c,l.shape.length,Lj[l.dtype],d,h,s.length),u}var tq,nq={kernelName:Zr,backendName:"wasm",kernelFunc:eq,setupFunc:function(e){Jj=e.wasm.cwrap(Zr,null,["number","array","number","number","number","array","number"])}};function rq(e,t,n){let r=e.shape,a=e.shape.length,s=ka.parseAxisParam(t,r),i=s,o=Jf.getAxesPermutation(i,a),l=null,u=!1;if(null!=o){let t=new Array(a);for(let e=0;e<t.length;e++)t[e]=r[o[e]];i=Jf.getInnerMostAxes(i.length,a),l=eq({inputs:{x:e},attrs:{perm:o},backend:n});let s=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==s&&(u=!0)}return{transposed:l,originalAxes:s,axes:i,inputWasTransposed:u}}var aq,sq={kernelName:Xe,backendName:"wasm",setupFunc:function(e){tq=e.wasm.cwrap(Xe,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:p,originalAxes:d,inputWasTransposed:h}=rq(i,a,t);if(h){l=u,o=t.dataIdMap.get(u.dataId).id}let c=l.shape.length;Jf.assertAxesAreInnerMostDims("all",p,c);let[f,m]=Jf.computeOutAndReduceShapes(l.shape,p),g=ka.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==ka.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;tq(o,g,e)}if(h&&t.disposeData(u.dataId),s){let e=Jf.expandShapeToKeepDim(y.shape,d);y.shape=e}return y}};var iq={kernelName:Ye,backendName:"wasm",setupFunc:function(e){aq=e.wasm.cwrap(Ye,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:p,originalAxes:d,inputWasTransposed:h}=rq(i,a,t);if(h){l=u,o=t.dataIdMap.get(u.dataId).id}let c=l.shape.length;Jf.assertAxesAreInnerMostDims("any",p,c);let[f,m]=Jf.computeOutAndReduceShapes(l.shape,p),g=ka.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==ka.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;aq(o,g,e)}if(h&&t.disposeData(u.dataId),s){let e=Jf.expandShapeToKeepDim(y.shape,d);y.shape=e}return y}};function oq(e){let t;return{kernelName:e,backendName:"wasm",setupFunc:function(n){t=n.wasm.cwrap(e,null,["number","number","number","number","number"])},kernelFunc:function(e){let{backend:n,inputs:r,attrs:a}=e,{axis:s}=a,{x:i}=r,o=n.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:d,inputWasTransposed:h}=rq(i,s,n);if(h){let e=n.dataIdMap.get(p.dataId).id;e!==o&&(u=p,l=e)}let c=u.shape.slice(0,-1),f=n.makeOutput(c,"int32"),m=n.dataIdMap.get(f.dataId).id,g=ka.sizeFromShape(f.shape),y=u.shape[d[0]];return t(l,Lj[u.dtype],g,y,m),h&&n.disposeData(p.dataId),f}}}var lq,uq=oq(Ze),pq=oq(Je),dq=Uj(Qe),hq=Uj(et),cq=Uj(tt),fq=qj(rt),mq=Uj(nt);var gq,yq={kernelName:at,backendName:"wasm",setupFunc:function(e){lq=e.wasm.cwrap(at,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,p=Jf.computePool2DInfo(a.shape,i,o,1,l,u),d=p.filterHeight,h=p.filterWidth,c=p.padInfo.top,f=p.padInfo.right,m=p.padInfo.bottom,g=p.padInfo.left,y=p.strideHeight,b=p.strideWidth,x=p.inChannels;if("channelsLast"!==p.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);if(1!==p.dilationWidth||1!==p.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${p.dilationHeight}, ${p.dilationWidth}].`);let w=r.makeOutput(p.outShape,"float32"),v=r.dataIdMap.get(w.dataId).id;return lq(s,a.shape[0],a.shape[1],a.shape[2],d,h,c,f,m,g,y,b,x,v),w}};var bq,xq={kernelName:it,backendName:"wasm",setupFunc:function(e){gq=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,p=Jf.computePool3DInfo(a.shape,s,i,1,o,l,u),d=n.makeOutput(p.outShape,a.dtype);return gq(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),d}};var wq,vq={kernelName:ot,backendName:"wasm",setupFunc:function(e){bq=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,p=Jf.computePool3DInfo(s.shape,i,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return bq(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left,p.filterDepth,p.filterHeight,p.filterWidth),d}};var kq={kernelName:st,backendName:"wasm",setupFunc:function(e){wq=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l}=r,u=Jf.computePool2DInfo(s.shape,i,o,1,l),p=n.makeOutput(s.shape,s.dtype);return wq(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left,u.filterHeight,u.filterWidth),p}};function Iq(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,s=ka.sizeFromShape(r.shape),i=ka.inferFromImplicitShape(a,s);return ka.assert(s===ka.sizeFromShape(i),(()=>`new shape: ${i}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`)),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}var Sq,Nq={kernelName:lr,backendName:"wasm",kernelFunc:Iq};var Tq={kernelName:lt,backendName:"wasm",setupFunc:function(e){Sq=e.wasm.cwrap(lt,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=a.shape.length,u=s.shape.length,p=i?a.shape[l-2]:a.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],h=i?a.shape[l-1]:a.shape[l-2],c=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=ka.sizeFromShape(f),y=ka.sizeFromShape(m),b=Pl.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,c]);ka.assert(p===d,(()=>`Error in matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`));let x=o?[y,c,d]:[y,d,c],w=Iq({inputs:{x:a},backend:n,attrs:{shape:i?[g,p,h]:[g,h,p]}}),v=Iq({inputs:{x:s},backend:n,attrs:{shape:x}}),k=n.dataIdMap.get(w.dataId).id,I=n.dataIdMap.get(v.dataId).id,S=i?w.shape[2]:w.shape[1],N=o?v.shape[1]:v.shape[2],T=Math.max(g,y),_=n.makeOutput([T,S,N],w.dtype),C=n.dataIdMap.get(_.dataId).id,E=new Uint8Array(new Int32Array(w.shape).buffer),$=new Uint8Array(new Int32Array(v.shape).buffer);return Sq(k,E,w.shape.length,I,$,v.shape.length,i,o,C),n.disposeData(w.dataId),n.disposeData(v.dataId),_.shape=b,_}};function _q(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:a}=e,[s,i]=Tf.parseSliceParams(t,n,r),o=Tf.isSliceContinous(t.shape,s,i),l=a.readSync(t.dataId),u=a.makeOutput(i,t.dtype),p=ka.computeStrides(t.shape),d=a.dataIdMap.get(u.dataId);if(o){let e=Tf.computeFlatOffset(s,p);return"string"===t.dtype?d.stringBytes=l.slice(e,e+ka.sizeFromShape(i)):a.typedArrayFromHeap(u).set(l.subarray(e,e+ka.sizeFromShape(i))),u}if("string"===t.dtype){let e=NA(l,s,i,t.shape,t.dtype);return d.stringBytes=e,u}let h=a.typedArrayFromHeap(u),c=t.shape.length;if(2===c)!function(e,t,n,r,a){let s=0,i=r[0],o=r[1],l=i+a[0];for(let r=i;r<l;r++){let i=r*t+o;n.set(e.subarray(i,i+a[1]),s),s+=a[1]}}(l,p[0],h,s,i);else if(3===c)!function(e,t,n,r,a,s){let i=0,o=a[0],l=a[1],u=a[2],p=o+s[0],d=l+s[1];for(let a=o;a<p;a++)for(let o=l;o<d;o++){let l=a*t+o*n+u;r.set(e.subarray(l,l+s[2]),i),i+=s[2]}}(l,p[0],p[1],h,s,i);else if(4===c)!function(e,t,n,r,a,s,i){let o=0,l=s[0],u=s[1],p=s[2],d=l+i[0],h=u+i[1],c=p+i[2],f=s[3];for(let s=l;s<d;s++)for(let l=u;l<h;l++)for(let u=p;u<c;u++){let p=s*t+l*n+u*r+f;a.set(e.subarray(p,p+i[3]),o),o+=i[3]}}(l,p[0],p[1],p[2],h,s,i);else{let e=NA(l,s,i,t.shape,t.dtype);h.set(e)}return u}var Cq={kernelName:kr,backendName:"wasm",kernelFunc:_q};var Eq,$q={kernelName:ut,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r,o=s.reduce(((e,t)=>e*t)),l=Jf.getReshaped(a.shape,s,o),u=Jf.getPermuted(l.length,s.length),p=Jf.getReshapedPermuted(a.shape,s,o),d=Jf.getSliceBeginCoords(i,s.length),h=Jf.getSliceSize(p,i,s.length),c=Iq({inputs:{x:a},backend:n,attrs:{shape:l}}),f=eq({inputs:{x:c},backend:n,attrs:{perm:u}}),m=Iq({inputs:{x:f},backend:n,attrs:{shape:p}}),g=_q({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeData(c.dataId),n.disposeData(f.dataId),n.disposeData(m.dataId),g}};var Aq={kernelName:pt,backendName:"wasm",setupFunc:function(e){Eq=e.wasm.cwrap(pt,null,["number","number","boolean","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:s}=n,{size:i}=r,o=0!==s.shape.reduce(((e,t)=>e*t),1),l=1===a.shape.length?[i]:[a.shape[0],i],u=t.makeOutput(l,s.dtype);function p(e){return t.dataIdMap.get(e.dataId).id}return Eq(p(a),i,o,p(s),Lj[s.dtype],p(u)),u}},Fq=qj(dt);var Rq={kernelName:ct,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.typedArrayFromHeap(r),i=n.typedArrayFromHeap(a),o=Jf.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}};function Dq(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,a=r.makeOutput(t.shape,n),s=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(a).set(s),a}var Mq,Oq={kernelName:ft,backendName:"wasm",kernelFunc:Dq},Lq=Uj(mt);var zq={kernelName:gt,backendName:"wasm",setupFunc:function(e){Mq=e.wasm.cwrap(gt,null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r,o=n.dataIdMap.get(a.dataId).id,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(l.dataId).id;return Mq(o,s,i,u),l}};function Pq(e){let{inputs:t,backend:n}=e,r=ka.parseAxisParam(e.attrs.axis,t[0].shape)[0],a=t.map((e=>e.shape));Jf.assertParamsConsistent(a,r);let s=Jf.computeOutShape(t.map((e=>e.shape)),r),i=t.filter((e=>ka.sizeFromShape(e.shape)>0));if(1===i.length)return Zj({inputs:{x:i[0]},backend:n});let o=n.makeOutput(s,t[0].dtype);if(0===ka.sizeFromShape(s))return o;if("string"===i[0].dtype){let e=i.map((e=>{let t=[-1,ka.sizeFromShape(e.shape.slice(r))];return Iq({inputs:{x:e},backend:n,attrs:{shape:t}})})),a=e.map((e=>({vals:n.readSync(e.dataId),shape:e.shape})));s=Jf.computeOutShape(e.map((e=>e.shape)),1);let l=1===e[0].shape[0],u=s$(a,s,t[0].dtype,l),p=Jf.computeOutShape(i.map((e=>e.shape)),r);return o.shape=p,n.dataIdMap.get(o.dataId).stringBytes=Jf.fromStringArrayToUint8(u),e.forEach((e=>n.disposeData(e.dataId))),o}let l=ka.sizeFromShape(i[0].shape.slice(0,r)),u=0,p=i.map((e=>{let t=ka.sizeFromShape(e.shape.slice(r));return u+=t,t})),d=i.map((e=>n.typedArrayFromHeap(e))),h=n.typedArrayFromHeap(o);for(let e=0;e<l;e++){let t=e*u;for(let n=0;n<d.length;n++){let r=p[n],a=e*r,s=d[n].subarray(a,a+r);h.set(s,t),t+=r}}return o}var Bq,Wq={kernelName:xt,backendName:"wasm",kernelFunc:Pq};var Vq,Uq={kernelName:wt,backendName:"wasm",setupFunc:function(e){Bq=e.wasm.cwrap(wt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:p,dimRoundingMode:d,dataFormat:h}=n,c=Jf.convertConv2DDataFormat(h),f=Jf.computeConv2DInfo(a.shape,s.shape,l,u,p,d,!1,c),m=f.filterHeight,g=f.filterWidth,y=f.padInfo.top,b=f.padInfo.right,x=f.padInfo.bottom,w=f.padInfo.left,v=f.dilationHeight,k=f.dilationWidth,I=f.strideHeight,S=f.strideWidth,N=f.inChannels,T=f.outChannels,_="SAME"===f.padInfo.type?1:0;if("channelsLast"!==f.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let C=r.makeOutput(f.outShape,"float32"),E=r.dataIdMap.get(C.dataId).id;return Bq(i,a.shape[0],a.shape[1],a.shape[2],o,m,g,y,b,x,w,_,v,k,I,S,N,T,E),C}};var Gq,Hq={kernelName:kt,backendName:"wasm",setupFunc:function(e){Vq=e.wasm.cwrap(kt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{dy:a,filter:s}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,inputShape:p}=r,d=Jf.convertConv2DDataFormat(l),h=Jf.computeConv2DInfo(p,s.shape,i,1,o,u,!1,d),{batchSize:c,filterHeight:f,filterWidth:m,inChannels:g,inHeight:y,inWidth:b,outChannels:x,outHeight:w,outWidth:v,strideHeight:k,strideWidth:I}=h,S=f-1-h.padInfo.top,N=m-1-h.padInfo.left,T="channelsLast"===h.dataFormat,_=ka.computeStrides(h.inShape),C=ka.computeStrides(a.shape),[E,$,A]=ka.computeStrides(s.shape),F=_[0],R=T?_[1]:_[2],D=T?_[2]:1,M=T?1:_[1],O=C[0],L=T?C[1]:C[2],z=T?C[2]:1,P=T?1:C[1],B=t.makeOutput(h.inShape,"float32"),W=t.dataIdMap.get(B.dataId).id,V=t.dataIdMap.get(a.dataId).id,U=t.dataIdMap.get(s.dataId).id;return Vq(V,U,c,f,m,y,b,g,w,v,x,k,I,S,N,E,$,A,F,R,D,M,O,L,z,P,W),B}};var jq,qq={kernelName:It,backendName:"wasm",setupFunc:function(e){Gq=e.wasm.cwrap(It,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor x must have dtype float32, got ${a.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=Jf.computeConv3DInfo(a.shape,s.shape,i,l,o),p=n.makeOutput(u.outShape,a.dtype);return Gq(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),p}};var Kq,Xq={kernelName:St,backendName:"wasm",setupFunc:function(e){jq=e.wasm.cwrap(St,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=Jf.computeConv3DInfo(a.shape,l,i,1,o),p=n.makeOutput(u.filterShape,s.dtype);return jq(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),p}};var Yq,Zq,Jq={kernelName:Nt,backendName:"wasm",setupFunc:function(e){Kq=e.wasm.cwrap(Nt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=Jf.computeConv3DInfo(l,s.shape,o,1,i),p=n.makeOutput(u.inShape,a.dtype);return Kq(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),p}},Qq=Uj(Tt),eK=Uj(_t);!function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"}(Yq||(Yq={}));var tK,nK={kernelName:$t,backendName:"wasm",setupFunc:function(e){Zq=e.wasm.cwrap($t,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{method:s,extrapolationValue:i,cropSize:o}=a,{image:l,boxes:u,boxInd:p}=r,d=u.shape[0],[h,c]=o,f=[d,h,c,l.shape[3]],m=n.dataIdMap.get(l.dataId);"float32"!==l.dtype&&(t=Dq({backend:n,inputs:{x:l},attrs:{dtype:"float32"}}),m=n.dataIdMap.get(t.dataId));let g=m.id,y=n.dataIdMap.get(u.dataId).id,b=n.dataIdMap.get(p.dataId).id,x=n.makeOutput(f,"float32"),w=n.dataIdMap.get(x.dataId).id,v=new Uint8Array(new Int32Array(l.shape).buffer);return Zq(g,y,b,d,v,h,c,Yq[s],i,w),null!=t&&n.disposeData(t.dataId),x}};var rK,aK={kernelName:Ct,backendName:"wasm",setupFunc:function(e){tK=e.wasm.cwrap(Ct,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;ka.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`));let u=Jf.getAxesPermutation([s],l),p=a;null!==u&&(p=eq({inputs:{x:a},attrs:{perm:u},backend:n}));let d=Jf.getInnerMostAxes(1,l)[0];Jf.assertAxesAreInnerMostDims("cumprod",[d],l);let h=n.makeOutput(p.shape,p.dtype),c=p.shape[d],f=n.dataIdMap.get(p.dataId).id,m=n.dataIdMap.get(h.dataId).id;tK(f,i?1:0,o?1:0,c,m,Lj[a.dtype]);let g=h;if(null!==u){g=eq({inputs:{x:h},attrs:{perm:Jf.getUndoAxesPermutation(u)},backend:n}),n.disposeData(p.dataId),n.disposeData(h.dataId)}return g}};var sK,iK={kernelName:Et,backendName:"wasm",setupFunc:function(e){rK=e.wasm.cwrap(Et,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;ka.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`));let u=Jf.getAxesPermutation([s],l),p=a;null!==u&&(p=eq({inputs:{x:a},attrs:{perm:u},backend:n}));let d=Jf.getInnerMostAxes(1,l)[0];Jf.assertAxesAreInnerMostDims("cumsum",[d],l);let h=n.makeOutput(p.shape,p.dtype),c=p.shape[d],f=n.dataIdMap.get(p.dataId).id,m=n.dataIdMap.get(h.dataId).id;rK(f,i?1:0,o?1:0,c,m,Lj[a.dtype]);let g=h;if(null!==u){g=eq({inputs:{x:h},attrs:{perm:Jf.getUndoAxesPermutation(u)},backend:n}),n.disposeData(p.dataId),n.disposeData(h.dataId)}return g}};var oK,lK={kernelName:At,backendName:"wasm",setupFunc:function(e){sK=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:s}=n,{size:i,binaryOutput:o}=r,l=0!==s.shape.reduce(((e,t)=>e*t),1),u=1===a.shape.length?[i]:[a.shape[0],i],p=t.makeOutput(u,s.dtype);function d(e){return t.dataIdMap.get(e.dataId).id}return sK(d(a),new Uint8Array(new Int32Array(a.shape).buffer),a.shape.length,i,l,d(s),Lj[s.dtype],o,d(p)),p}};var uK,pK={kernelName:Ft,backendName:"wasm",setupFunc:function(e){oK=e.wasm.cwrap(Ft,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=("NHWC"===i?a.shape[1]:a.shape[2])*s,u=("NHWC"===i?a.shape[2]:a.shape[3])*s,p=("NHWC"===i?a.shape[3]:a.shape[1])/(s*s),d="NHWC"===i?[o,l,u,p]:[o,p,l,u],h=t.makeOutput(d,"float32"),c=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(ka.computeStrides(a.shape)).buffer),m=new Uint8Array(new Int32Array(d).buffer),g=new Uint8Array(new Int32Array(ka.computeStrides(d)).buffer),y=t.dataIdMap.get(h.dataId).id;return oK(c,s,"NHWC"===i?1:0,f,a.shape.length-1,m,g,d.length,y),h}};var dK,hK={kernelName:Rt,backendName:"wasm",setupFunc:function(e){uK=e.wasm.cwrap(Rt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:p,dimRoundingMode:d}=n,h=null==u?[1,1]:u,c=Jf.computeConv2DInfo(a.shape,s.shape,l,h,p,d,!0),f=c.filterHeight,m=c.filterWidth,g=c.padInfo.top,y=c.padInfo.right,b=c.padInfo.bottom,x=c.padInfo.left,w=c.dilationHeight,v=c.dilationWidth,k=c.strideHeight,I=c.strideWidth,S=c.inChannels,N=c.outChannels,T="SAME"===c.padInfo.type?1:0;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let _=r.makeOutput(c.outShape,"float32"),C=r.dataIdMap.get(_.dataId).id;return uK(i,a.shape[0],a.shape[1],a.shape[2],o,f,m,g,y,b,x,T,w,v,k,I,S,N,C),_}};var cK,fK={kernelName:Ot,backendName:"wasm",setupFunc:function(e){dK=e.wasm.cwrap("Diag",null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=ka.sizeFromShape(r.shape),s=n.makeOutput([...r.shape,...r.shape],r.dtype);return dK(n.dataIdMap.get(r.dataId).id,Lj[r.dtype],a,n.dataIdMap.get(s.dataId).id),s}};var mK,gK={kernelName:Lt,backendName:"wasm",setupFunc:function(e){cK=e.wasm.cwrap(Lt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;if(a.dtype!==s.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${a.dtype} and ${s.dtype}`);let u=Jf.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l),p=n.makeOutput(u.outShape,a.dtype);return cK(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,Lj[a.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),p}};var yK,bK={kernelName:Pt,backendName:"wasm",setupFunc:function(e){mK=e.wasm.cwrap(Pt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r;if(a.dtype!==s.dtype||a.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${i.dtype}`);let p=Jf.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u),d=n.makeOutput(s.shape,s.dtype);return mK(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,Lj[a.dtype],p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.filterHeight,p.filterWidth,p.padInfo.top,p.padInfo.left),d}};var xK,wK={kernelName:zt,backendName:"wasm",setupFunc:function(e){yK=e.wasm.cwrap(zt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r;if(a.dtype!==s.dtype||a.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${i.dtype}`);let p=Jf.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u),d=n.makeOutput(a.shape,a.dtype);return yK(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,Lj[a.dtype],p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.filterHeight,p.filterWidth,p.padInfo.top,p.padInfo.left),d}},vK=Uj(Ut);var kK={kernelName:Gt,backendName:"wasm",setupFunc:function(e){xK=e.wasm.cwrap(Gt,null,["number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=n.makeOutput(a.shape,"float32"),i=e=>n.dataIdMap.get(e.dataId).id;return xK(i(a),i(r),i(s)),s}},IK=qj(jt,0,"bool"),SK=Uj(Ht),NK=Uj(qt,"float32");function TK(e){let{inputs:t,attrs:n,backend:r}=e,{input:a}=t,{dim:s}=n,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(ka.assert(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),Iq({inputs:{x:a},backend:r,attrs:{shape:o}})}var _K={kernelName:Kt,backendName:"wasm",kernelFunc:TK},CK=Uj(Xt,"float32");function EK(e){let{attrs:{shape:t,value:n},backend:r}=e,{attrs:{dtype:a}}=e;a=a||ka.inferDtype(n);let s=r.makeOutput(t,a);return r.typedArrayFromHeap(s).fill(n),s}var $K,AK={kernelName:Zt,backendName:"wasm",kernelFunc:EK};var FK,RK={kernelName:Jt,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{image:r}=t,a=n.makeOutput(r.shape,r.dtype),s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,[o,l,u,p]=r.shape;return $K(s,o,l,u,p,i),a},setupFunc:function(e){$K=e.wasm.cwrap(Jt,null,["number","number","number","number","number","number"])}},DK=Uj(Qt),MK=qj(en);var OK,LK={kernelName:tn,backendName:"wasm",setupFunc:function(e){FK=e.wasm.cwrap(tn,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:a}=r,{x:s,mean:i,variance:o,offset:l,scale:u}=n,p=t.dataIdMap.get(s.dataId).id,d=t.dataIdMap.get(i.dataId).id,h=t.dataIdMap.get(o.dataId).id,c=null!=l?t.dataIdMap.get(l.dataId).id:0,f=null!=u?t.dataIdMap.get(u.dataId).id:0,m=t.makeOutput(s.shape,s.dtype);if(0===ka.sizeFromShape(s.shape))return m;let g=t.dataIdMap.get(m.dataId).id;return FK(p,d,h,c,f,a,g),m}};var zK,PK={kernelName:oa,backendName:"wasm",setupFunc:function(e){OK=e.wasm.cwrap(oa,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:p,dataFormat:d,dimRoundingMode:h,activation:c,leakyreluAlpha:f}=n,m=Jf.computeConv2DInfo(a.shape,s.shape,l,p,u,h),g=zj[c];if(null==g)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,x=m.outChannels,w=0;if(null!=i){let e=r.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==x)throw new Error(`FusedConv2D bias shape (${e.shape}) does not match the number of output channels (${x})`);w=e.id}let v=m.filterHeight,k=m.filterWidth,I=m.padInfo.top,S=m.padInfo.right,N=m.padInfo.bottom,T=m.padInfo.left,_=m.dilationHeight,C=m.dilationWidth,E=m.strideHeight,$=m.strideWidth,A=m.inChannels,F="SAME"===m.padInfo.type?1:0,R=m.batchSize,D=m.inHeight,M=m.inWidth;if("NHWC"!==d)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),L=r.dataIdMap.get(O.dataId).id,z=null==o?0:r.dataIdMap.get(o.dataId).id;return OK(y,R,D,M,b,v,k,w,I,S,N,T,F,_,C,E,$,A,x,g,z,f||0,L),O}};var BK,WK={kernelName:la,backendName:"wasm",setupFunc:function(e){zK=e.wasm.cwrap(la,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:p,dataFormat:d,dimRoundingMode:h,activation:c,leakyreluAlpha:f}=n,m=Jf.computeConv2DInfo(a.shape,s.shape,l,p,u,h,!0),g=zj[c];if(null==g)throw new Error(`${c} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,x=m.outChannels,w=0;if(null!=i){let e=r.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==x)throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not match the number of output channels (${x})`);w=e.id}let v=m.filterHeight,k=m.filterWidth,I=m.padInfo.top,S=m.padInfo.right,N=m.padInfo.bottom,T=m.padInfo.left,_=m.dilationHeight,C=m.dilationWidth,E=m.strideHeight,$=m.strideWidth,A=m.inChannels,F="SAME"===m.padInfo.type?1:0,R=m.batchSize,D=m.inHeight,M=m.inWidth;if("NHWC"!==d)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),L=r.dataIdMap.get(O.dataId).id,z=null==o?0:r.dataIdMap.get(o.dataId).id;return zK(y,R,D,M,b,v,k,w,I,S,N,T,F,_,C,E,$,A,x,g,z,f||0,L),O}};var VK,UK={kernelName:rn,backendName:"wasm",setupFunc:function(e){BK=e.wasm.cwrap(rn,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function(e){let{backend:t,inputs:n}=e,{params:r,indices:a}=n,[s,i,o,l]=Sf.prepareAndValidate(r,a),u=t.makeOutput(s,r.dtype);if(0===i)return u;let p=a.shape,d=p[p.length-1],h=t.dataIdMap.get(r.dataId).id,c=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),m=t.dataIdMap.get(u.dataId).id;return BK(h,Lj[r.dtype],c,i,d,o,f,m),u}};var GK,HK={kernelName:nn,backendName:"wasm",setupFunc:function(e){VK=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,indices:s}=n,{axis:i,batchDims:o}=r,l=ka.parseAxisParam(i,a.shape)[0],u=t.readSync(s.dataId),p=a.shape[l];for(let e=0;e<u.length;++e){let t=u[e];ka.assert(t<=p-1&&t>=0,(()=>`GatherV2: the index value ${t} is not in [0, ${p-1}]`))}let d=Jf.segment_util.collectGatherOpShapeInfo(a,s,l,o),h=Iq({inputs:{x:a},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:t}),c=ka.sizeFromShape(s.shape),f=Iq({inputs:{x:s},attrs:{shape:[d.batchSize,c/d.batchSize]},backend:t}),m=[d.batchSize,d.outerSize,c/d.batchSize,d.sliceSize],g=t.makeOutput(m,a.dtype);if(0===ka.sizeFromShape(a.shape))return g;let y=h.shape.length-1,b=t.dataIdMap.get(h.dataId).id,x=t.dataIdMap.get(f.dataId).id,w=t.dataIdMap.get(g.dataId).id,v=new Uint8Array(new Int32Array(ka.computeStrides(h.shape)).buffer),k=new Uint8Array(new Int32Array(ka.computeStrides(m)).buffer);return VK(b,Lj[a.dtype],v,y,x,d.batchSize,k,w),t.disposeData(h.dataId),t.disposeData(f.dataId),g.shape=d.outputShape,g}},jK=qj(an,0,"bool"),qK=qj(sn,0,"bool"),KK=Uj(pn,"bool"),XK=Uj(dn,"bool"),YK=Uj(hn,"bool");var ZK,JK={kernelName:cn,backendName:"wasm",setupFunc:function(e){GK=e.wasm.cwrap(cn,null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,a=r.dataIdMap.get(t.dataId).id,s=r.makeOutput(t.shape,"float32");if(0!==ka.sizeFromShape(t.shape)){let e=r.dataIdMap.get(s.dataId).id;GK(a,Lj[t.dtype],n,e)}return s}},QK=qj(fn,0,"bool"),eX=qj(mn,0,"bool");var tX,nX={kernelName:gn,backendName:"wasm",setupFunc:function(e){ZK=e.wasm.cwrap(gn,null,["number","number","number","number"])},kernelFunc:function(e){let{attrs:t,backend:n}=e,{start:r,stop:a,num:s}=t,i=Math.floor(s),o=n.makeOutput([i],"float32");return ZK(n.dataIdMap.get(o.dataId).id,r,a,i),o}},rX=Uj(yn),aX=Uj(bn),sX=qj(xn,0,"bool"),iX=Uj(wn),oX=qj(vn,0,"bool"),lX=qj(kn,0,"bool");var uX,pX={kernelName:Nn,backendName:"wasm",setupFunc:function(e){tX=e.wasm.cwrap(Nn,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;if("float32"!==a.dtype)throw new Error("LRN error: x must have dtype float32");let u=n.makeOutput(a.shape,a.dtype);return tX(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(u.dataId).id,a.shape[3],s,i,o,l),u}};var dX,hX={kernelName:Tn,backendName:"wasm",setupFunc:function(e){uX=e.wasm.cwrap(Tn,null,["number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:p}=r;if("float32"!==a.dtype||"float32"!==s.dtype||"float32"!==i.dtype)throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let d=n.makeOutput(a.shape,a.dtype);return uX(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,i.shape[3],o,l,u,p),d}};var cX,fX={kernelName:Cn,backendName:"wasm",setupFunc:function(e){dX=e.wasm.cwrap(Cn,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:p,originalAxes:d,inputWasTransposed:h}=rq(i,a,t);if(h){l=u,o=t.dataIdMap.get(u.dataId).id}let c=l.shape.length;Jf.assertAxesAreInnerMostDims("max",p,c);let[f,m]=Jf.computeOutAndReduceShapes(l.shape,p),g=ka.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==ka.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;dX(o,Lj[i.dtype],g,e)}if(h&&t.disposeData(u.dataId),s){let e=Jf.expandShapeToKeepDim(y.shape,d);y.shape=e}return y}},mX=qj(En);var gX,yX={kernelName:$n,backendName:"wasm",setupFunc:function(e){cX=e.wasm.cwrap($n,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id;ka.assert("float32"===a.dtype,(()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`));let{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,p=Jf.computePool2DInfo(a.shape,i,o,1,l,u),d=p.filterHeight,h=p.filterWidth,c=p.padInfo.top,f=p.padInfo.right,m=p.padInfo.bottom,g=p.padInfo.left,y=p.dilationHeight,b=p.dilationWidth,x=p.strideHeight,w=p.strideWidth,v=p.inChannels,k=p.outChannels;if("channelsLast"!==p.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let I=r.makeOutput(p.outShape,"float32"),S=r.dataIdMap.get(I.dataId).id;return cX(s,a.shape[0],a.shape[1],a.shape[2],d,h,c,f,m,g,y,b,x,w,v,k,S),I}};var bX,xX={kernelName:Fn,backendName:"wasm",setupFunc:function(e){gX=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,p=Jf.computePool3DInfo(a.shape,s,i,1,o,l,u),d=n.makeOutput(p.outShape,a.dtype);return gX(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),d}};var wX,vX={kernelName:Rn,backendName:"wasm",setupFunc:function(e){bX=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,p=Jf.computePool3DInfo(s.shape,i,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return bX(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),d}};var kX,IX={kernelName:An,backendName:"wasm",setupFunc:function(e){wX=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,p=Jf.computePool2DInfo(s.shape,i,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return wX(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.top,p.padInfo.left),d}};var SX,NX={kernelName:Dn,backendName:"wasm",setupFunc:function(e){kX=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=r;ka.assert(4===a.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`));let u=[1,1];ka.assert(Jf.eitherStridesOrDilationsAreOne(i,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));let p=Jf.computePool2DInfo(a.shape,s,i,[1,1],o),d=n.makeOutput(p.outShape,a.dtype),h=n.makeOutput(p.outShape,"int32");return kX(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,n.dataIdMap.get(h.dataId).id,Lj[a.dtype],l,p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.top,p.padInfo.left),[d,h]}};var TX,_X={kernelName:Mn,backendName:"wasm",setupFunc:function(e){SX=e.wasm.cwrap(Mn,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:d,originalAxes:h,inputWasTransposed:c}=rq(i,a,t),f=d;if(c){let e=t.dataIdMap.get(p.dataId).id;e!==o&&(u=p,l=e,f=Jf.getInnerMostAxes(f.length,u.shape.length))}Jf.assertAxesAreInnerMostDims("mean",f,u.shape.length);let[m,g]=Jf.computeOutAndReduceShapes(u.shape,f),y=ka.sizeFromShape(g),b=u;"float32"!==u.dtype&&(b=Dq({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(b.dataId).id);let x=t.makeOutput(m,"float32");if(0!==ka.sizeFromShape(u.shape)){let e=t.dataIdMap.get(x.dataId).id;SX(l,y,e)}if(c&&t.disposeData(p.dataId),s){let e=Jf.expandShapeToKeepDim(x.shape,h);x.shape=e}return"float32"!==u.dtype&&t.disposeData(b.dataId),x}};var CX,EX,$X={kernelName:On,backendName:"wasm",setupFunc:function(e){TX=e.wasm.cwrap(On,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:d,originalAxes:h,inputWasTransposed:c}=rq(i,a,t);if(c){let e=t.dataIdMap.get(p.dataId).id;e!==o&&(u=p,l=e)}let f=u.shape.length;Jf.assertAxesAreInnerMostDims("min",d,f);let[m,g]=Jf.computeOutAndReduceShapes(u.shape,d),y=ka.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==ka.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;TX(l,Lj[i.dtype],y,e)}if(c&&t.disposeData(p.dataId),s){let e=Jf.expandShapeToKeepDim(b.shape,h);b.shape=e}return b}},AX=qj(Ln);!function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"}(CX||(CX={}));var FX,RX={kernelName:zn,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:a}}=e,s=r.map(((e,n)=>e[0]+t.shape[n]+e[1])),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),p=r.map((e=>e[0])),d=r.map((e=>e[1])),h=new Uint8Array(new Int32Array(p).buffer),c=new Uint8Array(new Int32Array(d).buffer);return EX(i,u,t.shape.length,Lj[t.dtype],h,c,CX[a],l),o},setupFunc:function(e){EX=e.wasm.cwrap(zn,null,["number","array","number","number","array","array","number","number"])}};function DX(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,a=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,o=n.shape[r],l=ka.sizeFromShape(n.shape)/o;return 0===ka.sizeFromShape(s.shape)||FX(a,i,o,l),s}var MX,OX={kernelName:Fr,backendName:"wasm",setupFunc:function(e){FX=e.wasm.cwrap(Fr,null,["number","number","number","number"])},kernelFunc:DX};var LX,zX={kernelName:Bn,backendName:"wasm",setupFunc:function(e){MX=e.wasm.cwrap(Bn,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;if("float32"!==a.dtype)throw new Error(`Tensor logits must have dtype float32, got ${a.dtype}`);let l=o?a:DX({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),[u,p]=l.shape,d=n.makeOutput([u,s],"int32");return MX(n.dataIdMap.get(l.dataId).id,u,p,s,i,n.dataIdMap.get(d.dataId).id),o||n.disposeData(l.dataId),d}},PX=qj(Pn),BX=qj(Wn),WX=Uj(Vn);function VX(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],a=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:a,pSelectedScores:s,pValidOutputs:i}}var UX,GX={kernelName:Gn,backendName:"wasm",setupFunc:function(e){LX=e.wasm.cwrap(Gn,"number",["number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i}=r,{boxes:o,scores:l}=n,u=t.dataIdMap.get(o.dataId).id,p=t.dataIdMap.get(l.dataId).id,d=LX(u,p,s,a,i),{pSelectedIndices:h,selectedSize:c,pSelectedScores:f,pValidOutputs:m}=VX(t,d);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([c],"int32",h)}};var HX,jX={kernelName:Hn,backendName:"wasm",setupFunc:function(e){UX=e.wasm.cwrap(Hn,"number",["number","number","number","number","number","bool"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=r,{boxes:l,scores:u}=n,p=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,h=UX(p,d,s,a,i,o),{pSelectedIndices:c,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=VX(t,h);return t.wasm._free(m),[t.makeOutput([f],"int32",c),t.makeOutput([],"int32",g)]}};var qX,KX={kernelName:jn,backendName:"wasm",setupFunc:function(e){HX=e.wasm.cwrap(jn,"number",["number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=r,{boxes:l,scores:u}=n,p=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,h=HX(p,d,s,a,i,o),{pSelectedIndices:c,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=VX(t,h);return t.wasm._free(g),[t.makeOutput([f],"int32",c),t.makeOutput([f],"float32",m)]}},XX=qj(Un,0,"bool");var YX={kernelName:Kn,backendName:"wasm",setupFunc:function(e){qX=e.wasm.cwrap(Kn,null,["number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,u=n.makeOutput([...a.shape,i],s),p=n.dataIdMap.get(u.dataId).id,d=n.dataIdMap.get(a.dataId).id;return qX(d,i,o,l,p),u}};var ZX={kernelName:qn,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}};var JX,QX={kernelName:Xn,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return TK({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{ka.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),ka.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=Pq({inputs:t.map((e=>{let t=TK({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeData(e.dataId))),l}};var eY,tY={kernelName:Yn,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:a}}=e,s=r.map(((e,n)=>e[0]+t.shape[n]+e[1]));if(0===ka.sizeFromShape(t.shape))return EK({backend:n,attrs:{shape:s,value:a,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),p=r.map((e=>e[0])),d=r.map((e=>e[1])),h=new Uint8Array(new Int32Array(p).buffer),c=new Uint8Array(new Int32Array(d).buffer);return JX(i,u,t.shape.length,Lj[t.dtype],h,c,a,l),o},setupFunc:function(e){JX=e.wasm.cwrap(Yn,null,["number","array","number","number","array","array","number","number"])}},nY=qj(Jn);var rY,aY={kernelName:Qn,backendName:"wasm",setupFunc:function(e){eY=e.wasm.cwrap(Qn,null,["number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,o=s,l=r,u=l;"float32"!==l.dtype&&(u=Dq({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(u.dataId).id);let p=n.makeOutput(r.shape,"float32"),d=n.dataIdMap.get(p.dataId).id;return eY(o,i,d),"float32"!==l.dtype&&n.disposeData(u.dataId),p}};var sY,iY={kernelName:er,backendName:"wasm",setupFunc:function(e){rY=e.wasm.cwrap(er,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:d,originalAxes:h,inputWasTransposed:c}=rq(i,a,t),f=d;if(c){let e=t.dataIdMap.get(p.dataId).id;e!==o&&(u=p,l=e,f=Jf.getInnerMostAxes(f.length,u.shape.length))}Jf.assertAxesAreInnerMostDims("prod",f,u.shape.length);let[m,g]=Jf.computeOutAndReduceShapes(u.shape,f),y=ka.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==ka.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;rY(l,y,Lj[b.dtype],e)}if(c&&t.disposeData(p.dataId),s){let e=Jf.expandShapeToKeepDim(b.shape,h);b.shape=e}return b}},oY={kernelName:ar,backendName:"wasm",kernelFunc:e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=yA(r,a,s,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l}},lY=qj(Wt),uY=Uj(ir),pY=Uj(or),dY=Uj(cr);var hY,cY={kernelName:dr,backendName:"wasm",setupFunc:function(e){sY=e.wasm.cwrap(dr,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{images:s}=r,{alignCorners:i,halfPixelCenters:o,size:l}=a,[u,p]=l,[d,h,c,f]=s.shape,m=[d,u,p,f],g=n.dataIdMap.get(s.dataId);"float32"!==g.dtype&&(t=Dq({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),g=n.dataIdMap.get(t.dataId));let y=g.id,b=n.makeOutput(m,"float32");if(0===ka.sizeFromShape(s.shape))return b;let x=n.dataIdMap.get(b.dataId).id;return sY(y,d,h,c,f,u,p,i?1:0,o?1:0,x),null!=t&&n.disposeData(t.dataId),b}};var fY,mY={kernelName:hr,backendName:"wasm",setupFunc:function(e){hY=e.wasm.cwrap(hr,null,["number","number","number","array","array","boolean"])},kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{images:s,dy:i}=n,{alignCorners:o}=a,l=r.makeOutput(s.shape,"float32"),u=r.dataIdMap.get(s.dataId);return"float32"!==u.dtype&&(t=Dq({backend:r,inputs:{x:s},attrs:{dtype:"float32"}}),u=r.dataIdMap.get(t.dataId)),hY(r.dataIdMap.get(s.dataId).id,r.dataIdMap.get(i.dataId).id,r.dataIdMap.get(l.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(i.shape).buffer),o),null!=t&&r.disposeData(t.dataId),l}};var gY,yY={kernelName:ur,backendName:"wasm",setupFunc:function(e){fY=e.wasm.cwrap(ur,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,[p,d,h,c]=a.shape,f=[p,l,u,c],m=t.makeOutput(f,"float32");if(0===ka.sizeFromShape(a.shape))return m;let g,y=t.dataIdMap.get(a.dataId);"float32"!==y.dtype&&(g=Dq({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),y=t.dataIdMap.get(g.dataId));let b=y.id,x=t.dataIdMap.get(m.dataId).id;return fY(b,p,d,h,c,l,u,s?1:0,i?1:0,x),null!=g&&t.disposeData(g.dataId),m}};var bY,xY={kernelName:pr,backendName:"wasm",setupFunc:function(e){gY=e.wasm.cwrap(pr,null,["number","number","number","array","array","boolean"])},kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{images:s,dy:i}=n,{alignCorners:o}=a,l=r.makeOutput(s.shape,"float32"),u=r.dataIdMap.get(s.dataId);return"float32"!==u.dtype&&(t=Dq({backend:r,inputs:{x:s},attrs:{dtype:"float32"}}),u=r.dataIdMap.get(t.dataId)),gY(r.dataIdMap.get(s.dataId).id,r.dataIdMap.get(i.dataId).id,r.dataIdMap.get(l.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(i.shape).buffer),o),null!=t&&r.disposeData(t.dataId),l}};var wY,vY={kernelName:fr,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=ka.parseAxisParam(s,a.shape);if(0===a.shape.length)return Zj({inputs:{x:a},backend:n});let o=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(o.dataId).id,p=new Uint8Array(new Int32Array(i).buffer),d=new Uint8Array(new Int32Array(a.shape).buffer);bY(l,p,i.length,d,a.shape.length,u);let h=Iq({inputs:{x:o},attrs:{shape:a.shape},backend:n});return n.disposeData(o.dataId),h},setupFunc:function(e){bY=e.wasm.cwrap(fr,null,["number","array","number","array","number","number"])}};var kY,IY={kernelName:sa,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{radians:s,fillValue:i,center:o}=r,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(l.dataId).id,[d,h,c,f]=a.shape,[m,g]=Jf.getImageCenter(o,h,c),y="number"==typeof i?[i,i,i,0===i?0:255]:[...i,255],b=new Uint8Array(new Int32Array(y).buffer);return wY(u,d,h,c,f,s,m,g,b,y.length,p),l},setupFunc:function(e){wY=e.wasm.cwrap(sa,null,["number","number","number","number","number","number","number","number","array","number","number"])}},SY=Uj(mr),NY=Uj(gr);var TY,_Y={kernelName:yr,backendName:"wasm",setupFunc:function(e){kY=e.wasm.cwrap(yr,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{indices:a,updates:s}=n,{shape:i}=r,o=t.makeOutput(i,s.dtype);if(0===ka.sizeFromShape(i))return o;let{sliceRank:l,numUpdates:u,sliceSize:p,strides:d,outputSize:h}=Ud.calculateShapes(s,a,i),c=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(s.dataId).id,m=new Uint8Array(new Int32Array(d).buffer),g=t.dataIdMap.get(o.dataId).id;return kY(c,f,Lj[s.dtype],l,u,p,m,h,g),o}};var CY,EY={kernelName:xr,backendName:"wasm",setupFunc:function(e){TY=e.wasm.cwrap(xr,null,["number","number","number","number","number","number","bool","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r;if(a.dtype!==s.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${a.dtype} and ${s.dtype}`);let o=n.makeOutput(s.shape,"int32");function l(e){return n.dataIdMap.get(e.dataId).id}return TY(l(a),l(s),a.shape[0],a.shape[1],s.shape[1],Lj[a.dtype],"left"===i,l(o)),o}};var $Y,AY={kernelName:wr,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,l=n.dataIdMap.get(s.dataId).id,u=n.makeOutput(a.shape,a.dtype),p=n.dataIdMap.get(u.dataId).id,d=r.shape.length,h=a.shape.length,c=0===d||d>1||1===h?1:ka.sizeFromShape(a.shape.slice(1));return CY(i,o,l,c,p),u},setupFunc:function(e){CY=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}},FY=Uj(vr);var RY={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function(e){$Y=e.wasm.cwrap(Tr,null,["number","number"])},kernelFunc:function(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(a.dataId).id;return 0===ka.sizeFromShape(a.shape)||$Y(r,s),a}},DY=Uj(Nr),MY=Uj(Ir),OY=Uj(Sr),LY=Uj(_r);var zY,PY={kernelName:$r,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r,o=ka.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let e=1+s.length;e<a.shape.length;++e)l.push([0,0]);let u=tY.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),p=Jf.getReshaped(u.shape,s,o,!1),d=Jf.getPermuted(p.length,s.length,!1),h=Jf.getReshapedPermuted(u.shape,s,o,!1),c=Iq({inputs:{x:u},backend:n,attrs:{shape:p}}),f=eq({inputs:{x:c},backend:n,attrs:{perm:d}}),m=Iq({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeData(u.dataId),n.disposeData(c.dataId),n.disposeData(f.dataId),m}};var BY,WY={kernelName:Rr,backendName:"wasm",setupFunc:function(e){zY=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r}=e,{indices:a,values:s,denseShape:i,defaultValue:o}=r,l=a.shape[0],u=a.shape[1],p=n.readSync(i.dataId)[0],d=[l+p,u],h=n.dataIdMap.get(a.dataId).id,c=n.dataIdMap.get(s.dataId).id,f=n.dataIdMap.get(o.dataId).id,m=n.makeOutput(d,a.dtype),g=n.dataIdMap.get(m.dataId).id,y=n.makeOutput(d.slice(0,1),s.dtype),b=n.dataIdMap.get(y.dataId).id,x=n.makeOutput([p],"bool"),w=n.dataIdMap.get(x.dataId).id,v=n.makeOutput([l],a.dtype),k=n.dataIdMap.get(v.dataId).id,I=n.makeOutput([4],"int32"),S=n.dataIdMap.get(I.dataId).id,N=zY(h,c,Lj[s.dtype],l,p,u,f,g,b,w,k,S),T=n.readSync(I.dataId);switch(T[0]){case 1:t=Jf.getSparseFillEmptyRowsIndicesDenseShapeMismatch(T[1]);break;case 2:t=Jf.getSparseFillEmptyRowsNegativeIndexErrorMessage(T[1],T[2]);break;case 3:t=Jf.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(T[1],T[2],T[3]);break;default:t=""}if(n.disposeData(I.dataId),t)throw n.disposeData(m.dataId),n.disposeData(y.dataId),n.disposeData(x.dataId),n.disposeData(v.dataId),new Error(t);let _=m,C=y;return N!==d[0]&&(_=_q({inputs:{x:m},attrs:{begin:0,size:[N,u]},backend:n}),C=_q({inputs:{x:y},attrs:{begin:0,size:N},backend:n}),n.disposeData(m.dataId),n.disposeData(y.dataId)),[_,C,x,v]}};var VY,UY={kernelName:Dr,backendName:"wasm",setupFunc:function(e){BY=e.wasm.cwrap(Dr,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:a,newShape:s}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(a.dataId).id,l=t.dataIdMap.get(s.dataId).id,u=r.shape[0],p=ka.sizeFromShape(s.shape),d=t.makeOutput([u,p],r.dtype),h=t.dataIdMap.get(d.dataId).id,c=t.makeOutput([p],s.dtype),f=t.dataIdMap.get(c.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;BY(i,o,l,u,h,f,g);let y,b=t.readSync(m.dataId);switch(b[0]){case 0:y=Jf.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break;case 1:y=Jf.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break;case 2:y=Jf.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(c.dataId));y=Jf.getSparseReshapeInputOutputMultipleErrorMessage(e,n);break}case 4:{let e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(c.dataId));y=Jf.getSparseReshapeInputOutputMismatchErrorMessage(e,n);break}default:y=""}if(t.disposeData(m.dataId),y)throw t.disposeData(d.dataId),t.disposeData(c.dataId),new Error(y);return[d,c]}};function GY(e){VY=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function HY(e,t){let{backend:n,inputs:r}=e,{data:a,indices:s,segmentIds:i}=r,o=s.shape[0],l=n.readSync(i.dataId,o-1,o)[0],u=o>0?l+1:0;if(u<0)throw new Error(Jf.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let p=a.shape.slice();p[0]=u;let d=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(s.dataId).id,c=n.dataIdMap.get(i.dataId).id,f=n.makeOutput(p,a.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),y=n.dataIdMap.get(g.dataId).id;VY(d,Lj[a.dtype],a.shape[0],h,c,m,y,t,0);let b,x=n.readSync(g.dataId);switch(x[0]){case 0:b=Jf.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:b=Jf.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:b=Jf.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(x[1],x[2]);break;case 3:b=Jf.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x[1],x[2],x[3]);break;default:b=""}if(n.disposeData(g.dataId),b)throw n.disposeData(f.dataId),new Error(b);return f}var jY={kernelName:Mr,backendName:"wasm",setupFunc:GY,kernelFunc:function(e){return HY(e,!0)}};var qY,KY={kernelName:Or,backendName:"wasm",setupFunc:GY,kernelFunc:function(e){return HY(e,!1)}};var XY={kernelName:Lr,backendName:"wasm",setupFunc:function(e){qY=e.wasm.cwrap(Lr,null,["number","number","number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=n,{outputShape:o}=r,l=t.makeOutput(o,i.dtype);if(0===ka.sizeFromShape(o))return l;let{sliceRank:u,numUpdates:p,sliceSize:d,strides:h,outputSize:c}=Jf.calculateShapes(s,a,o),f=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(i.dataId).id,y=new Uint8Array(new Int32Array(h).buffer),b=t.dataIdMap.get(l.dataId).id;return qY(f,m,s.shape.length,g,Lj[i.dtype],u,p,d,y,c,b),l}};var YY,ZY={kernelName:Ar,backendName:"wasm",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=n,o=ka.parseAxisParam(i,a.shape)[0],l=Jf.prepareSplitSize(a,s,o),u=new Array(a.shape.length).fill(0),p=a.shape.slice();return l.map((e=>{let t=[...p];t[o]=e;let n=_q({inputs:{x:a},attrs:{begin:u,size:t},backend:r});return u[o]+=e,n}))}},JY=Uj(Cr),QY=Uj(Pr),eZ=qj(zr);var tZ,nZ={kernelName:ra,backendName:"wasm",setupFunc:function(e){YY=e.wasm.cwrap(ra,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:a}=r,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(o.dataId).id;return YY(i,a,Lj[s.dtype],l),o}};var rZ={kernelName:Wr,backendName:"wasm",setupFunc:function(e){tZ=e.wasm.cwrap(Wr,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{x:s}=r,{begin:i,end:o,strides:l,beginMask:u,endMask:p,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:c}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:x,end:w,strides:v}=Tf.sliceInfo(s.shape,i,o,l,u,p,d,h,c);if(g)t=Iq({inputs:{x:s},backend:n,attrs:{shape:m}});else if(y||b){ka.assert(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));let e=Tf.computeOutShape(x,w,v),r=_q({inputs:{x:s},backend:n,attrs:{begin:x,size:e}});t=Iq({inputs:{x:r},backend:n,attrs:{shape:m}}),n.disposeData(r.dataId)}else{let e=n.makeOutput(f,"float32"),r=n.dataIdMap.get(s.dataId).id,a=new Uint8Array(new Int32Array(ka.computeStrides(s.shape)).buffer),i=new Uint8Array(new Int32Array(x).buffer),o=new Uint8Array(new Int32Array(w).buffer),l=new Uint8Array(new Int32Array(v).buffer),u=new Uint8Array(new Int32Array(f).buffer),p=new Uint8Array(new Int32Array(ka.computeStrides(f)).buffer),d=n.dataIdMap.get(e.dataId).id;tZ(r,a,s.shape.length,i,o,l,u,p,f.length,d),t=Iq({inputs:{x:e},backend:n,attrs:{shape:m}}),n.disposeData(e.dataId)}return t}};var aZ={kernelName:Vr,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{data:a,dataSplits:s}=n,{separator:i,nGramWidths:o,leftPad:l,rightPad:u,padWidth:p,preserveShortSequences:d}=r,h=t.readSync(a.dataId),c=t.readSync(s.dataId),[f,m]=VA(h,c,i,o,l,u,p,d),g=t.makeOutput([f.length],"string");t.dataIdMap.get(g.dataId).stringBytes=f;let y=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(y).set(m),[g,y]}};var sZ={kernelName:Ur,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{input:a,delimiter:s}=n,{skipEmpty:i}=r,o=t.readSync(a.dataId),l=t.readSync(s.dataId),[u,p,d]=GA(o,l[0],i),h=p.length,c=t.makeOutput([h,2],"int32");t.typedArrayFromHeap(c).set(u);let f=t.makeOutput([h],"string");t.dataIdMap.get(f.dataId).stringBytes=p;let m=t.makeOutput([2],"int32");return t.typedArrayFromHeap(m).set(d),[c,f,m]}};var iZ,oZ={kernelName:Gr,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{input:a}=n,{numBuckets:s}=r,i=HA(t.readSync(a.dataId),s),o=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(o).set(i),o}},lZ=qj(Hr);var uZ,pZ={kernelName:Er,backendName:"wasm",setupFunc:function(e){iZ=e.wasm.cwrap(Er,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:d,originalAxes:h,inputWasTransposed:c}=rq(i,a,t),f=d;if(c){let e=t.dataIdMap.get(p.dataId).id;e!==o&&(u=p,l=e,f=Jf.getInnerMostAxes(f.length,u.shape.length))}Jf.assertAxesAreInnerMostDims("sum",f,u.shape.length);let[m,g]=Jf.computeOutAndReduceShapes(u.shape,f),y=ka.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==ka.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;iZ(l,y,Lj[b.dtype],e)}if(c&&t.disposeData(p.dataId),s){let e=Jf.expandShapeToKeepDim(b.shape,h);b.shape=e}return b}},dZ=Uj(jr),hZ=Uj(qr);var cZ,fZ={kernelName:br,backendName:"wasm",setupFunc:function(e){uZ=e.wasm.cwrap(br,null,["number","number","number","number","number","number","array","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=n,{}=r,o=t.makeOutput(a.shape,a.dtype);if(0===ka.sizeFromShape(a.shape))return o;let{sliceRank:l,numUpdates:u,sliceSize:p,strides:d,outputSize:h}=Ud.calculateShapes(i,s,a.shape),c=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(a.dataId).id,g=new Uint8Array(new Int32Array(d).buffer),y=t.dataIdMap.get(o.dataId).id;return uZ(c,f,Lj[i.dtype],l,u,p,g,h,y,m),o}};var mZ,gZ={kernelName:Kr,backendName:"wasm",setupFunc:function(e){cZ=e.wasm.cwrap(Kr,null,["number","array","number","array","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,s=n.dataIdMap.get(a.dataId).id,{reps:i}=r,o=new Array(a.shape.length);for(let e=0;e<o.length;e++)o[e]=a.shape[e]*i[e];let l=new Uint8Array(new Int32Array(a.shape).buffer),u=new Uint8Array(new Int32Array(o).buffer),p=n.makeOutput(o,a.dtype),d=n.dataIdMap.get(p.dataId).id;return cZ(s,l,a.shape.length,u,o.length,Lj[p.dtype],d),p}};var yZ,bZ={kernelName:Xr,backendName:"wasm",setupFunc:function(e){mZ=e.wasm.cwrap(Xr,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{k:a,sorted:s}=n,i=t.dataIdMap.get(r.dataId).id,o=new Uint8Array(new Int32Array(r.shape).buffer),l=r.shape.slice();l[l.length-1]=a;let u=t.makeOutput(l,r.dtype),p=t.dataIdMap.get(u.dataId).id,d=t.makeOutput(l,"int32"),h=t.dataIdMap.get(d.dataId).id;return mZ(i,o,r.shape.length,Lj[r.dtype],a,s,p,h),[u,d]}};var xZ={kernelName:Yr,backendName:"wasm",setupFunc:function(e){yZ=e.wasm.cwrap(Yr,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{image:s,transforms:i}=r,{interpolation:o,fillMode:l,fillValue:u,outputShape:p}=a,[d,h,c,f]=s.shape,[m,g]=null!=p?p:[h,c],y=[d,m,g,f],b=new Uint8Array(new Int32Array(ka.computeStrides(s.shape)).buffer),x=new Uint8Array(new Int32Array(ka.computeStrides(y)).buffer),w=n.makeOutput(y,s.dtype),v=n.dataIdMap.get(w.dataId).id,k=n.dataIdMap.get(s.dataId).id,I=n.dataIdMap.get(i.dataId).id,S="nearest"===o?1:2;switch(l){case"constant":default:t=1;break;case"reflect":t=2;break;case"wrap":t=3;break;case"nearest":t=4}return yZ(k,I,i.shape[0]>1,d,m,g,f,c,h,b,s.shape.length-1,x,y.length-1,S,t,u,v),w}};var wZ={kernelName:Jr,backendName:"wasm",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t,{outputValues:i,outputShape:o,indices:l}=eF(r.readSync(s.dataId),a,s.shape,s.dtype);return[r.makeOutput(o,s.dtype,void 0,i),r.makeOutput([l.length],"int32",void 0,l)]}};var vZ={kernelName:Qr,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape[s],o=a.shape.length,l=new Array(o-1),u=0;for(let e=0;e<o;e++)e!==s&&(l[u++]=a.shape[e]);let p=new Array(i),d=new Array(o).fill(0),h=a.shape.slice();h[s]=1;for(let e=0;e<p.length;e++)d[s]=e,p[e]=_q({inputs:{x:a},attrs:{begin:d,size:h},backend:n});return p.map((({dataId:e,dtype:t})=>({dataId:e,dtype:t,shape:l})))}};var kZ={kernelName:na,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}},IZ=[Vj,Gj,Hj,jj,Xj,Yj,sq,iq,uq,pq,dq,hq,cq,fq,mq,yq,kq,xq,vq,Tq,$q,Aq,Fq,Rq,Oq,Lq,zq,Wq,Uq,Hq,qq,Xq,Jq,Qq,eK,nK,aK,iK,lK,pK,hK,fK,gK,bK,wK,vK,kK,IK,SK,NK,_K,CK,AK,RK,DK,MK,LK,PK,WK,UK,HK,jK,qK,Qj,KK,XK,YK,JK,QK,eX,nX,aX,rX,sX,iX,oX,lX,pX,hX,fX,mX,yX,xX,vX,IX,NX,_X,$X,AX,RX,zX,PX,BX,WX,GX,jX,KX,XX,YX,ZX,QX,tY,nY,aY,iY,oY,lY,uY,pY,dY,Nq,cY,mY,yY,xY,vY,IY,SY,NY,_Y,EY,AY,FY,RY,DY,MY,OY,Cq,OX,LY,PY,WY,UY,jY,KY,XY,ZY,JY,QY,eZ,nZ,rZ,aZ,sZ,oZ,lZ,pZ,dZ,hZ,fZ,gZ,bZ,xZ,nq,wZ,vZ,kZ];for(let e of IZ)ga(e);var SZ=Pe();SZ.registerFlag("WASM_HAS_SIMD_SUPPORT",(async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch(e){return!1}})),SZ.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",(async()=>{if(SZ.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(e){return!1}}));var NZ=y(O()),TZ=y(L()),_Z=y(z()),CZ=NZ.default||NZ,EZ=_Z.default||_Z,$Z=class extends B{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(WZ),VZ=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new P(this,ei())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=ka.now();return e(),{kernelMs:ka.now()-t}}move(e,t,n,r,a){let s=this.dataIdNextNumber++;if("string"===r){let i=t;return void this.dataIdMap.set(e,{id:s,stringBytes:i,shape:n,dtype:r,memoryOffset:null,refCount:a})}let i=ka.sizeFromShape(n),o=i*ka.bytesPerElement(r),l=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:s,memoryOffset:l,shape:n,dtype:r,refCount:a}),this.wasm.tfjs.registerTensor(s,i,l),null!=t&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:a,shape:s,stringBytes:i}=this.dataIdMap.get(e);if("string"===a)return null!=t&&0!==t||!(null==n||n>=i.length)?i.slice(t,n):i;t=t||0,n=n||ka.sizeFromShape(s);let o=ka.bytesPerElement(a);return function(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}(this.wasm.HEAPU8.slice(r+t*o,r+n*o).buffer,a)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);null!=t&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,r){let a;if(null==n)a=this.write(null!=r?r:null,e,t);else{let r=this.dataIdNextNumber++;a={id:r},this.dataIdMap.set(a,{id:r,memoryOffset:n,shape:e,dtype:t,refCount:1});let s=ka.sizeFromShape(e);this.wasm.tfjs.registerTensor(r,s,n)}return{dataId:a,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(n),s=ka.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,a,s);case"int32":return new Int32Array(r,a,s);case"bool":return new Uint8Array(r,a,s);default:throw new Error(`Unknown dtype ${t}`)}}};function AZ(e,t,n){if(null!=DZ)return DZ;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),null!=OZ&&null!=OZ[r]?OZ[r]:n+r}async function FZ(){let[e,t]=await Promise.all([Pe().getAsync("WASM_HAS_SIMD_SUPPORT"),Pe().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise(((n,r)=>{let a={locateFile:(n,r)=>{if(n.endsWith(".worker.js")){let e=TZ.wasmWorkerContents.replace(/\n/g,"\\n"),t=new Blob([e],{type:"application/javascript"});return URL.createObjectURL(t)}return n.endsWith(".wasm")?AZ(e,t,null!=MZ?MZ:r):r+n}};zZ&&(a.instantiateWasm=function(e){return(t,n)=>(ka.fetch(e,{credentials:"same-origin"}).then((r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then((e=>{WebAssembly.instantiate(e,t).then((e=>{n(e.instance,e.module)}))}))})),{})}(AZ(e,t,null!=MZ?MZ:"")));let s,i=!1;a.onAbort=()=>{i||LZ||(LZ=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},t&&e&&null==DZ?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+CZ.toString()],{type:"text/javascript"}),s=CZ(a)):s=EZ(a),s.then((e=>{i=!0,LZ=!1;e.tfjs={init:e.cwrap("init",null,[]),initWithThreadsCount:e.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:e.cwrap("get_threads_count","number",[]),registerTensor:e.cwrap("register_tensor",null,["number","number","number"]),disposeData:e.cwrap("dispose_data",null,["number"]),dispose:e.cwrap("dispose",null,[])},n({wasm:e})})).catch(r)}))}var RZ=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],DZ=null,MZ=null,OZ={},LZ=!1,zZ=!1;function PZ(e,t=!1){if(Js("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),LZ)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");DZ=e,zZ=t}function BZ(e,t=!1){if(LZ)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof e)MZ=e;else{OZ=e;let t=RZ.filter((e=>null==OZ[e]));if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}zZ=t}var WZ=-1,VZ=-1;function UZ(e){WZ=e}function GZ(){if(-1===VZ)throw new Error("WASM backend not initialized.");return VZ}var HZ="4.22.0";ci("wasm",(async()=>{let{wasm:e}=await FZ();return new $Z(e)}),2);var jZ="4.22.0",qZ={tfjs:jZ,"tfjs-core":jZ,"tfjs-converter":"4.22.0","tfjs-backend-cpu":"4.22.0","tfjs-backend-webgl":"4.22.0","tfjs-backend-wasm":"4.22.0"},KZ={};function XZ(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach((({x:n,y:r},a)=>{let s=t[a];e.moveTo(s.x,s.y),e.lineTo(n,r)})),n){let n=t[t.length-1],r=t[0];if(!n||!r)return;e.moveTo(n.x,n.y),e.lineTo(r.x,r.y)}e.stroke()}i(KZ,{AnchorPosition:()=>qJ,DrawBox:()=>ZJ,DrawBoxOptions:()=>YJ,DrawFaceLandmarks:()=>XQ,DrawFaceLandmarksOptions:()=>KQ,DrawTextField:()=>XJ,DrawTextFieldOptions:()=>KJ,drawContour:()=>XZ,drawDetections:()=>JJ,drawFaceExpressions:()=>HQ,drawFaceLandmarks:()=>YQ});var YZ={};i(YZ,{computeReshapedDimensions:()=>oJ,getCenterPoint:()=>lJ,isDimensions:()=>iJ,isEven:()=>aJ,isFloat:()=>rJ,isTensor:()=>JZ,isTensor1D:()=>QZ,isTensor2D:()=>eJ,isTensor3D:()=>tJ,isTensor4D:()=>nJ,isValidNumber:()=>pJ,isValidProbablitiy:()=>dJ,range:()=>uJ,round:()=>sJ});var ZZ=class e{constructor(e,t){if(!pJ(e)||!pJ(t))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:e,height:t})}`);this._width=e,this._height=t}get width(){return this._width}get height(){return this._height}reverse(){return new e(1/this.width,1/this.height)}};function JZ(e,t){return e instanceof is&&e.shape.length===t}function QZ(e){return JZ(e,1)}function eJ(e){return JZ(e,2)}function tJ(e){return JZ(e,3)}function nJ(e){return JZ(e,4)}function rJ(e){return e%1!=0}function aJ(e){return e%2==0}function sJ(e,t=2){let n=10**t;return Math.floor(e*n)/n}function iJ(e){return e&&e.width&&e.height}function oJ({width:e,height:t},n){let r=n/Math.max(t,e);return new ZZ(Math.round(e*r),Math.round(t*r))}function lJ(e){return e.reduce(((e,t)=>e.add(t)),new hJ(0,0)).div(new hJ(e.length,e.length))}function uJ(e,t,n){return Array(e).fill(0).map(((e,r)=>t+r*n))}function pJ(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||0===e}function dJ(e){return pJ(e)&&e>=0&&e<=1}var hJ=class e{constructor(e,t){this._x=e,this._y=t}get x(){return this._x}get y(){return this._y}add(t){return new e(this.x+t.x,this.y+t.y)}sub(t){return new e(this.x-t.x,this.y-t.y)}mul(t){return new e(this.x*t.x,this.y*t.y)}div(t){return new e(this.x/t.x,this.y/t.y)}abs(){return new e(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new e(Math.floor(this.x),Math.floor(this.y))}},cJ=class e{static isRect(e){return!!e&&[e.x,e.y,e.width,e.height].every(pJ)}static assertIsValidBox(t,n,r=!1){if(!e.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!r&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t,n=!0){let r=t||{},a=[r.left,r.top,r.right,r.bottom].every(pJ),s=[r.x,r.y,r.width,r.height].every(pJ);if(!s&&!a)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(r)}`);let[i,o,l,u]=s?[r.x,r.y,r.width,r.height]:[r.left,r.top,r.right-r.left,r.bottom-r.top];e.assertIsValidBox({x:i,y:o,width:l,height:u},"Box.constructor",n),this._x=i,this._y=o,this._width=l,this._height=u}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new hJ(this.left,this.top)}get topRight(){return new hJ(this.right,this.top)}get bottomLeft(){return new hJ(this.left,this.bottom)}get bottomRight(){return new hJ(this.right,this.bottom)}round(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map((e=>Math.round(e)));return new e({x:t,y:n,width:r,height:a})}floor(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map((e=>Math.floor(e)));return new e({x:t,y:n,width:r,height:a})}toSquare(){let{x:t,y:n,width:r,height:a}=this,s=Math.abs(r-a);return r<a&&(t-=s/2,r+=s),a<r&&(n-=s/2,a+=s),new e({x:t,y:n,width:r,height:a})}rescale(t){let n=iJ(t)?t.width:t,r=iJ(t)?t.height:t;return new e({x:this.x*n,y:this.y*r,width:this.width*n,height:this.height*r})}pad(t,n){let[r,a,s,i]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new e({x:r,y:a,width:s,height:i})}clipAtImageBorders(t,n){let{x:r,y:a,right:s,bottom:i}=this,o=Math.max(r,0),l=Math.max(a,0),u=s-o,p=i-l,d=Math.min(u,t-o),h=Math.min(p,n-l);return new e({x:o,y:l,width:d,height:h}).floor()}shift(t,n){let{width:r,height:a}=this,s=this.x+t,i=this.y+n;return new e({x:s,y:i,width:r,height:a})}padAtBorders(e,t){let n=this.width+1,r=this.height+1,a=n,s=r,i=this.left,o=this.top,l=this.right,u=this.bottom;return l>t&&(a=-l+t+n,l=t),u>e&&(s=-u+e+r,u=e),i<1&&(s=2-i,i=1),o<1&&(s=2-o,o=1),{dy:1,edy:s,dx:1,edx:a,y:o,ey:u,x:i,ex:l,w:n,h:r}}calibrate(t){return new e({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},fJ=class extends cJ{constructor(e,t,n,r,a=!1){super({left:e,top:t,right:n,bottom:r},a)}},mJ=class e{constructor(e,t,n,r,a){this._imageDims=new ZZ(a.width,a.height),this._score=e,this._classScore=t,this._className=n,this._box=new cJ(r).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new cJ(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new e(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}},gJ=class e extends mJ{constructor(e,t,n){super(e,e,"",t,n)}forSize(t,n){let{score:r,relativeBox:a,imageDims:s}=super.forSize(t,n);return new e(r,a,s)}};function yJ(e,t,n=!0){let r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left))*Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top));return n?r/(e.area+t.area-r):r/Math.min(e.area,t.area)}function bJ(e){let t=e.map((e=>e.x)),n=e.map((e=>e.y)),r=t.reduce(((e,t)=>t<e?t:e),1/0),a=n.reduce(((e,t)=>t<e?t:e),1/0),s=t.reduce(((e,t)=>e<t?t:e),0),i=n.reduce(((e,t)=>e<t?t:e),0);return new fJ(r,a,s,i)}function xJ(e,t,n,r=!0){let a=t.map(((e,t)=>({score:e,boxIndex:t}))).sort(((e,t)=>e.score-t.score)).map((e=>e.boxIndex)),s=[];for(;a.length>0;){let t=a.pop();s.push(t);let i=a,o=[];for(let n=0;n<i.length;n++){let a=i[n],s=e[t],l=e[a];o.push(yJ(s,l,r))}a=a.filter(((e,t)=>o[t]<=n))}return s}function wJ(e,t){return ri((()=>{let[n,r,a]=t,s=yl([...e.shape.slice(0,3),1],n,"float32"),i=yl([...e.shape.slice(0,3),1],r,"float32"),o=yl([...e.shape.slice(0,3),1],a,"float32"),l=el([s,i,o],3);return ju(e,l)}))}function vJ(e,t=!1){return ri((()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let a=Math.abs(n-r),s=Math.round(a*(t?.5:1)),i=n>r?2:1,o=t=>{let n=e.shape.slice();return n[i]=t,yl(n,0,"float32")},l=o(s),u=a-l.shape[i],p=[t&&u?o(u):null,e,l].filter((e=>!!e)).map((e=>go(e,"float32")));return el(p,i)}))}function kJ(e){let t=e.slice();for(let e=t.length-1;e>0;e--){let n=Math.floor(Math.random()*(e+1)),r=t[e];t[e]=t[n],t[n]=r}return t}function IJ(e){return 1/(1+Math.exp(-e))}function SJ(e){return Math.log(e/(1-e))}var NJ,TJ=class extends cJ{constructor(e,t,n,r,a=!1){super({x:e,y:t,width:n,height:r},a)}},_J=class{constructor(e,t,n=new hJ(0,0)){let{width:r,height:a}=t;this._imgDims=new ZZ(r,a),this._shift=n,this._positions=e.map((e=>e.mul(new hJ(r,a)).add(n)))}get shift(){return new hJ(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map((e=>e.sub(this._shift).div(new hJ(this.imageWidth,this.imageHeight))))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new hJ(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let n=e instanceof gJ?e.box.floor():new cJ(e);return this.shiftBy(n.x,n.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,a=e=>r.sub(e).magnitude(),s=(a(t)+a(n))/2,i=Math.floor(s/.45),o=lJ(e),l=Math.floor(Math.max(0,o.x-.5*i)),u=Math.floor(Math.max(0,o.y-.43*i));return new TJ(l,u,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+u))}alignMinBbox(e){let t=bJ(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},CJ=class extends _J{getRefPointsForAlignment(){let e=this.positions;return[e[0],e[1],lJ([e[3],e[4]])]}},EJ=class extends _J{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(lJ)}},$J=class{constructor(e,t){this._label=e,this._distance=t}get label(){return this._label}get distance(){return this._distance}toString(e=!0){return`${this.label}${e?` (${sJ(this.distance)})`:""}`}},AJ=class extends cJ{static assertIsValidLabeledBox(e,t){if(cJ.assertIsValidBox(e,t),!pJ(e.label))throw new Error(`${t} - expected property label (${e.label}) to be a number`)}constructor(e,t){super(e),this._label=t}get label(){return this._label}},FJ=class e{constructor(e,t){if("string"!=typeof e)throw new Error("LabeledFaceDescriptors - constructor expected label to be a string");if(!Array.isArray(t)||t.some((e=>!(e instanceof Float32Array))))throw new Error("LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array");this._label=e,this._descriptors=t}get label(){return this._label}get descriptors(){return this._descriptors}toJSON(){return{label:this.label,descriptors:this.descriptors.map((e=>Array.from(e)))}}static fromJSON(t){let n=t.descriptors.map((e=>new Float32Array(e)));return new e(t.label,n)}},RJ=class extends AJ{static assertIsValidPredictedBox(e,t){if(AJ.assertIsValidLabeledBox(e,t),!dJ(e.score)||!dJ(e.classScore))throw new Error(`${t} - expected properties score (${e.score}) and (${e.classScore}) to be a number between [0, 1]`)}constructor(e,t,n,r){super(e,t),this._score=n,this._classScore=r}get score(){return this._score}get classScore(){return this._classScore}};function DJ(e){return e.detection instanceof gJ}function MJ(e,t){return{...e,detection:t}}function OJ(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D:CanvasRenderingContext2D,Image:HTMLImageElement,ImageData:ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function LJ(){return"object"==typeof global&&"undefined"!=typeof process&&null!=process.versions&&null!=process.versions.node}function zJ(e){let t="";if(!e&&LJ())try{e=s("fs")}catch(e){t=e.toString()}return{readFile:e?t=>new Promise(((n,r)=>{e.readFile(t,((e,t)=>e?r(e):n(t)))})):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function PJ(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,r=global.fetch,a=zJ();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},createImageElement:()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},createVideoElement:()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},fetch:r,...a}}function BJ(){return"object"==typeof window&&"undefined"!=typeof document&&"undefined"!=typeof HTMLImageElement&&"undefined"!=typeof HTMLCanvasElement&&"undefined"!=typeof HTMLVideoElement&&"undefined"!=typeof ImageData&&"undefined"!=typeof CanvasRenderingContext2D}function WJ(e){NJ=e}function VJ(){return BJ()?WJ(OJ()):LJ()?WJ(PJ()):null}var UJ={getEnv:function(){if(!NJ)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return NJ},setEnv:WJ,initialize:VJ,createBrowserEnv:OJ,createFileSystem:zJ,createNodejsEnv:PJ,monkeyPatch:function(e){if(NJ||VJ(),!NJ)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=NJ.Canvas,Image:n=NJ.Image}=e;NJ.Canvas=t,NJ.Image=n,NJ.createCanvasElement=e.createCanvasElement||(()=>new t),NJ.createImageElement=e.createImageElement||(()=>new n),NJ.ImageData=e.ImageData||NJ.ImageData,NJ.Video=e.Video||NJ.Video,NJ.fetch=e.fetch||NJ.fetch,NJ.readFile=e.readFile||NJ.readFile},isBrowser:BJ,isNodejs:LJ};function GJ(e){return UJ.isNodejs()||"string"!=typeof e?e:document.getElementById(e)}function HJ(e){let{Canvas:t,CanvasRenderingContext2D:n}=UJ.getEnv();if(e instanceof n)return e;let r=GJ(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let a=r.getContext("2d",{willReadFrequently:!0});if(!a)throw new Error("resolveContext2d - canvas 2d context is null");return a}VJ();var jJ,qJ=((jJ=qJ||{}).TOP_LEFT="TOP_LEFT",jJ.TOP_RIGHT="TOP_RIGHT",jJ.BOTTOM_LEFT="BOTTOM_LEFT",jJ.BOTTOM_RIGHT="BOTTOM_RIGHT",jJ),KJ=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:a,fontStyle:s,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=a||14,this.fontStyle=s||"Georgia",this.padding=i||4}},XJ=class e{constructor(t,n,r={}){this.text="string"==typeof t?[t]:t instanceof e?t.text:t,this.anchor=n,this.options=new KJ(r)}measureWidth(e){let{padding:t}=this.options;return this.text.map((t=>e.measureText(t).width)).reduce(((e,t)=>e<t?t:e),0)+2*t}measureHeight(){let{fontSize:e,padding:t}=this.options;return this.text.length*e+2*t}getUpperLeft(e,t){let{anchorPosition:n}=this.options,r="BOTTOM_RIGHT"===n||"TOP_RIGHT"===n,a="BOTTOM_LEFT"===n||"BOTTOM_RIGHT"===n,s=this.measureWidth(e),i=this.measureHeight(),o=r?this.anchor.x-s:this.anchor.x,l=a?this.anchor.y-i:this.anchor.y;if(t){let{width:e,height:n}=t;return{x:Math.max(Math.min(o,e-s),0),y:Math.max(Math.min(l,n-i),0)}}return{x:o,y:l}}draw(e){let t=GJ(e),n=HJ(t),{backgroundColor:r,fontColor:a,fontSize:s,fontStyle:i,padding:o}=this.options;n.font=`${s}px ${i}`;let l=this.measureWidth(n),u=this.measureHeight();n.fillStyle=r;let p=this.getUpperLeft(n,t);n.fillRect(p.x,p.y,l,u),n.fillStyle=a,this.text.forEach(((e,t)=>{let r=o+p.x,a=o+p.y+(t+1)*s;n.fillText(e,r,a)}))}},YJ=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:r,drawLabelOptions:a}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let s={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new KJ({...s,...a})}},ZJ=class{constructor(e,t={}){this.box=new cJ(e),this.options=new YJ(t)}draw(e){let t=HJ(e),{boxColor:n,lineWidth:r}=this.options,{x:a,y:s,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(a,s,i,o);let{label:l}=this.options;l&&new XJ([l],{x:a-r/2,y:s},this.options.drawLabelOptions).draw(e)}};function JJ(e,t){(Array.isArray(t)?t:[t]).forEach((t=>{let n=t instanceof gJ?t.score:DJ(t)?t.detection.score:void 0,r=t instanceof gJ?t.box:DJ(t)?t.detection.box:new cJ(t),a=n?`${sJ(n)}`:void 0;new ZJ(r,{label:a}).draw(e)}))}function QJ(e){let{Image:t,Video:n}=UJ.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function eQ(e){return new Promise(((t,n)=>{function r(e){e.currentTarget&&(e.currentTarget.removeEventListener("load",a),e.currentTarget.removeEventListener("error",r),n(e))}function a(e){e.currentTarget&&(e.currentTarget.removeEventListener("load",a),e.currentTarget.removeEventListener("error",r),t(e))}e instanceof UJ.getEnv().Canvas||QJ(e)?t(null):(e.addEventListener("load",a),e.addEventListener("error",r))}))}function tQ(e){return new Promise(((t,n)=>{e instanceof Blob||n(new Error("bufferToImage - expected buf to be of type: Blob"));let r=new FileReader;r.onload=()=>{"string"!=typeof r.result&&n(new Error("bufferToImage - expected reader.result to be a string, in onload"));let e=UJ.getEnv().createImageElement();e.onload=()=>t(e),e.onerror=n,e.src=r.result},r.onerror=n,r.readAsDataURL(e)}))}function nQ(e){let{Image:t,Video:n}=UJ.getEnv();return e instanceof t?new ZZ(e.naturalWidth,e.naturalHeight):e instanceof n?new ZZ(e.videoWidth,e.videoHeight):new ZZ(e.width,e.height)}function rQ({width:e,height:t}){let{createCanvasElement:n}=UJ.getEnv(),r=n();return r.width=e,r.height=t,r}function aQ(e,t){let{ImageData:n}=UJ.getEnv();if(!(e instanceof n||QJ(e)))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:a}=t||nQ(e),s=rQ({width:r,height:a});return e instanceof n?HJ(s).putImageData(e,0,0):HJ(s).drawImage(e,0,0,r,a),s}async function sQ(e,t){let n=t||UJ.getEnv().createCanvasElement(),[r,a,s]=e.shape.slice(nJ(e)?1:0),i=ri((()=>e.as3D(r,a,s).toInt()));return await ff.toPixels(i,n),i.dispose(),n}function iQ(e){let{Image:t,Canvas:n,Video:r}=UJ.getEnv();return e instanceof t||e instanceof n||e instanceof r}function oQ(e,t,n=!1){let{Image:r,Canvas:a}=UJ.getEnv();if(!(e instanceof r||e instanceof a))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return rQ({width:1,height:1});let s=nQ(e),i=t/Math.max(s.height,s.width),o=i*s.width,l=i*s.height,u=rQ({width:t,height:t}),p=e instanceof a?e:aQ(e),d=Math.abs(o-l)/2,h=n&&o<l?d:0,c=n&&l<o?d:0;return p.width>0&&p.height>0&&HJ(u).drawImage(p,h,c,o,l),u}var lQ=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach(((e,t)=>{if(tJ(e))return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape);if(nJ(e)){let n=e.shape[0];if(1!==n)throw new Error(`NetInput - tf.Tensor4D with batchSize ${n} passed, but not supported in input array`);return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape.slice(1))}let n=e instanceof UJ.getEnv().Canvas?e:aQ(e);this._canvases[t]=n,this._inputDimensions[t]=[n.height,n.width,3]}))}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return uJ(this.batchSize,0,1).map(((e,t)=>this.getReshapedInputDimensions(t)))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if("number"!=typeof this.inputSize)throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");return oJ({width:this.getInputWidth(e),height:this.getInputHeight(e)},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,ri((()=>{let n=uJ(this.batchSize,0,1).map((n=>{let r=this.getInput(n);if(r instanceof is){let n=nJ(r)?r:yu(r);return n=vJ(n,t),(n.shape[1]!==e||n.shape[2]!==e)&&(n=Ic.resizeBilinear(n,[e,e],!1,!1)),n.as3D(e,e,3)}if(r instanceof UJ.getEnv().Canvas)return ff.fromPixels(oQ(r,e,t));throw new Error(`toBatchTensor - at batchIdx ${n}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${r}`)}));return Rd(n.map((e=>go(e,"float32")))).as4D(this.batchSize,e,e,3)}))}};async function uQ(e){if(e instanceof lQ)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=t=>Array.isArray(e)?` at input index ${t}:`:"",r=t.map(GJ);return r.forEach(((e,r)=>{if(!iQ(e)&&!tJ(e)&&!nJ(e))throw"string"==typeof t[r]?new Error(`toNetInput -${n(r)} string passed, but could not resolve HTMLElement for element id ${t[r]}`):new Error(`toNetInput -${n(r)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(nJ(e)){let t=e.shape[0];if(1!==t)throw new Error(`toNetInput -${n(r)} tf.Tensor4D with batchSize ${t} passed, but not supported in input array`)}})),await Promise.all(r.map((e=>iQ(e)&&eQ(e)))),new lQ(r,Array.isArray(e))}async function pQ(e,t){let{Canvas:n}=UJ.getEnv(),r=e;if(!(e instanceof n)){let t=await uQ(e);if(t.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let a=t.getInput(0);r=a instanceof n?a:await sQ(a)}let a=HJ(r);return t.map((e=>e instanceof gJ?e.forSize(r.width,r.height).box.floor():e)).map((e=>e.clipAtImageBorders(r.width,r.height))).map((({x:e,y:t,width:n,height:r})=>{let s=rQ({width:n,height:r});return n>0&&r>0&&HJ(s).putImageData(a.getImageData(e,t,n,r),0,0),s}))}async function dQ(e,t){if(!tJ(e)&&!nJ(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(nJ(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return ri((()=>{let[n,r,a]=e.shape.slice(nJ(e)?1:0);return t.map((e=>e instanceof gJ?e.forSize(r,n).box:e)).map((e=>e.clipAtImageBorders(r,n))).filter((e=>e.width>0&&e.height>0)).map((({x:t,y:s,width:i,height:o})=>Id(e.as3D(n,r,a),[s,t,0],[o,i,a])))}))}async function hQ(e,t){let{fetch:n}=UJ.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}async function cQ(e){let t=await hQ(e),n=await t.blob();if(!n.type.startsWith("image/"))throw new Error(`fetchImage - expected blob type to be of type image/*, instead have: ${n.type}, for url: ${t.url}`);return tQ(n)}async function fQ(e){return(await hQ(e)).json()}async function mQ(e){return new Float32Array(await(await hQ(e)).arrayBuffer())}async function gQ(e){let t=await hQ(e),n=await t.blob();if(!n.type.startsWith("video/"))throw new Error(`fetchVideo - expected blob type to be of type video/*, instead have: ${n.type}, for url: ${t.url}`);return function(e){return new Promise(((t,n)=>{e instanceof Blob||n(new Error("bufferToVideo - expected buf to be of type: Blob"));let r=UJ.getEnv().createVideoElement();r.oncanplay=()=>t(r),r.onerror=n,r.playsInline=!0,r.muted=!0,r.src=URL.createObjectURL(e),r.play()}))}(n)}function yQ(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if("/"===e)return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"",a=(e=e.replace(r,"")).split("/").filter((e=>e)),s=e.endsWith(".json")?a[a.length-1]:n,i=r+(e.endsWith(".json")?a.slice(0,a.length-1):a).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:"/"===i?`/${s}`:`${i}/${s}`}}async function bQ(e,t){let{manifestUri:n,modelBaseUri:r}=yQ(e,t),a=await fQ(n);return Gc.loadWeights(a,r)}function xQ(e,t,n=!1){let{width:r,height:a}=n?nQ(t):t;return e.width=r,e.height=a,{width:r,height:a}}var wQ=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map((({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)})))}getTrainableParams(){return this.getParamList().filter((e=>e.tensor instanceof ls))}getFrozenParams(){return this.getParamList().filter((e=>!(e.tensor instanceof ls)))}variable(){this.getFrozenParams().forEach((({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())}))}freeze(){this.getTrainableParams().forEach((({path:e,tensor:t})=>{let n=js(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)}))}dispose(e=!0){this.getParamList().forEach((t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()})),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map((({tensor:e})=>Array.from(e.dataSync()))).reduce(((e,t)=>e.concat(t))))}async load(e){e instanceof Float32Array?this.extractWeights(e):await this.loadFromUri(e)}async loadFromUri(e){if(e&&"string"!=typeof e)throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await bQ(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&"string"!=typeof e)throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=UJ.getEnv(),{manifestUri:n,modelBaseUri:r}=yQ(e,this.getDefaultModelName()),a=Gc.weightsLoaderFactory((e=>Promise.all(e.map((e=>t(e).then((e=>"string"==typeof e?Buffer.from(e):e.buffer))))))),s=JSON.parse((await t(n)).toString()),i=await a(s,r);this.loadFromWeightMap(i)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce(((t,n)=>{if(!t.nextObj.hasOwnProperty(n))throw new Error(`traversePropertyPath - object does not have property ${n}, for path ${e}`);return{obj:t.nextObj,objProp:n,nextObj:t.nextObj[n]}}),{nextObj:this.params}),{obj:n,objProp:r}=t;if(!(n&&r&&n[r]instanceof is))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function vQ(e,t,n){return ri((()=>{let r=gd(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=xo(r,t.bias),r}))}function kQ(e,t,n=!1){return ri((()=>{let r=id(n?xo(Il(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):vQ(e,t.conv0,[2,2])),a=vQ(r,t.conv1,[1,1]),s=vQ(id(xo(r,a)),t.conv2,[1,1]);return id(xo(r,xo(a,s)))}))}function IQ(e,t,n=!1,r=!0){return ri((()=>{let a=id(n?xo(Il(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):vQ(e,t.conv0,r?[2,2]:[1,1])),s=vQ(a,t.conv1,[1,1]),i=vQ(id(xo(a,s)),t.conv2,[1,1]),o=vQ(id(xo(a,xo(s,i))),t.conv3,[1,1]);return id(xo(a,xo(s,xo(i,o))))}))}function SQ(e,t,n="same",r=!1){return ri((()=>{let a=xo(Il(e,t.filters,[1,1],n),t.bias);return r?id(a):a}))}function NQ(e,t){Object.keys(e).forEach((n=>{t.some((e=>e.originalPath===n))||e[n].dispose()}))}function TQ(e,t){return(n,r,a,s)=>{let i=Bd(e(n*r*a*a),[a,a,n,r]),o=Ld(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}}function _Q(e,t){return(n,r,a)=>{let s=zd(e(n*r),[n,r]),i=Ld(e(r));return t.push({paramPath:`${a}/weights`},{paramPath:`${a}/bias`}),{weights:s,bias:i}}}var CQ=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function EQ(e,t){return(n,r,a)=>{let s=Bd(e(9*n),[3,3,n,1]),i=Bd(e(n*r),[1,1,n,r]),o=Ld(e(r));return t.push({paramPath:`${a}/depthwise_filter`},{paramPath:`${a}/pointwise_filter`},{paramPath:`${a}/bias`}),new CQ(s,i,o)}}function $Q(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),a=e(`${t}/bias`,1);return new CQ(n,r,a)}}function AQ(e,t){return(n,r,a)=>{let s=e[n];if(!JZ(s,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${s}`);return t.push({originalPath:n,paramPath:a||n}),s}}function FQ(e){let t=e;return{extractWeights:function(e){let n=t.slice(0,e);return t=t.slice(e),n},getRemainingWeights:function(){return t}}}function RQ(e,t){let n=TQ(e,t),r=EQ(e,t);function a(e,t,a,s=!1){return{conv0:s?n(e,t,3,`${a}/conv0`):r(e,t,`${a}/conv0`),conv1:r(t,t,`${a}/conv1`),conv2:r(t,t,`${a}/conv2`)}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:function(e,t,n,s=!1){let{conv0:i,conv1:o,conv2:l}=a(e,t,n,s);return{conv0:i,conv1:o,conv2:l,conv3:r(t,t,`${n}/conv3`)}}}}function DQ(e){return t=>({filters:e(`${t}/filters`,4),bias:e(`${t}/bias`,1)})}function MQ(e,t){let n=AQ(e,t),r=DQ(n),a=$Q(n);return{extractDenseBlock3Params:function(e,t=!1){return{conv0:t?r(`${e}/conv0`):a(`${e}/conv0`),conv1:a(`${e}/conv1`),conv2:a(`${e}/conv2`)}},extractDenseBlock4Params:function(e,t=!1){return{conv0:t?r(`${e}/conv0`):a(`${e}/conv0`),conv1:a(`${e}/conv1`),conv2:a(`${e}/conv2`),conv3:a(`${e}/conv3`)}}}}var OQ=class extends wQ{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return ri((()=>{let n=IQ(wJ(go(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),t.dense0,!0);return n=IQ(n,t.dense1),n=IQ(n,t.dense2),n=IQ(n,t.dense3),n=Jo(n,[7,7],[2,2],"valid"),n}))}async forward(e){return this.forwardInput(await uQ(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractDenseBlock4Params:n}=MQ(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return NQ(e,t),{params:r,paramMappings:t}}(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=FQ(e),{extractDenseBlock4Params:a}=RQ(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2"),l=a(128,256,"dense3");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:l}}}(e)}};function LQ(e,t){return ri((()=>xo(tl(e,t.weights),t.bias)))}function zQ(e){let t={},n={};return Object.keys(e).forEach((r=>{(r.startsWith("fc")?n:t)[r]=e[r]})),{featureExtractorMap:t,classifierMap:n}}var PQ=class extends wQ{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return ri((()=>{let n=e instanceof lQ?this.faceFeatureExtractor.forwardInput(e):e;return LQ(n.as2D(n.shape[0],-1),t.fc)}))}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return function(e,t,n){let r=[],{extractWeights:a,getRemainingWeights:s}=FQ(e),i=_Q(a,r)(t,n,"fc");if(0!==s().length)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:r,params:{fc:i}}}(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=zQ(e);return this.faceFeatureExtractor.loadFromWeightMap(t),function(e){let t=[],n=AQ(e,t),r={fc:(a="fc",{weights:n(`${a}/weights`,2),bias:n(`${a}/bias`,1)})};var a;return NQ(e,t),{params:r,paramMappings:t}}(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,a=e.slice(0,e.length-r),s=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(s)}},BQ=["neutral","happy","sad","angry","fearful","disgusted","surprised"],WQ=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,7!==e.length)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);BQ.forEach(((t,n)=>{this[t]=e[n]}))}asSortedArray(){return BQ.map((e=>({expression:e,probability:this[e]}))).sort(((e,t)=>t.probability-e.probability))}},VQ=class extends PQ{constructor(e=new OQ){super("FaceExpressionNet",e)}forwardInput(e){return ri((()=>Nd(this.runNet(e))))}async forward(e){return this.forwardInput(await uQ(e))}async predictExpressions(e){let t=await uQ(e),n=await this.forwardInput(t),r=await Promise.all(Jd(n).map((async e=>{let t=e.dataSync();return e.dispose(),t})));n.dispose();let a=r.map((e=>new WQ(e)));return t.isBatchInput?a:a[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function UQ(e){return e.expressions instanceof WQ}function GQ(e,t){return{...e,expressions:t}}function HQ(e,t,n=.1,r){(Array.isArray(t)?t:[t]).forEach((t=>{let a=t instanceof WQ?t:UQ(t)?t.expressions:void 0;if(!a)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let s=a.asSortedArray().filter((e=>e.probability>n)),i=DJ(t)?t.detection.box.bottomLeft:r||new hJ(0,0);new XJ(s.map((e=>`${e.expression} (${sJ(e.probability)})`)),i).draw(e)}))}function jQ(e){return DJ(e)&&e.landmarks instanceof _J&&e.unshiftedLandmarks instanceof _J&&e.alignedRect instanceof gJ}function qQ(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),a=r.align(),{imageDims:s}=e.detection,i=new gJ(e.detection.score,a.rescale(s.reverse()),s),o=function(e){let t=e=>180*e/Math.PI,n=(e,t)=>Math.sqrt((e.x-t.x)**2+(e.y-t.y)**2),r={roll:void 0,pitch:void 0,yaw:void 0};if(!e||!e.positions||68!==e.positions.length)return r;let a=e.positions;return r.roll=((e,n)=>{let r=Math.hypot(n.x-e.x,n.y-e.y),a=n.y-e.y,s=Math.asin(a/r),i=t(s);return Math.floor(90-i)*(n.x-e.x<0?-1:1)})(a[27],a[66]),r.pitch=((e,r,a)=>{let s=n(e,a),i=new hJ((e.x+a.x)/2,(e.y+a.y)/2),o=n(r,i),l=Math.atan(o/s);return Math.floor(t(l))*(i.y-r.y<0?-1:1)})(a[14],a[30],a[2]),r.yaw=(s=a[14],i=a[33],o=a[2],Math.floor(s.x-i.x)-Math.floor(i.x-o.x)),r;var s,i,o}(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:i,angle:o}}var KQ=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:a,pointSize:s,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=s||2,this.lineColor=a||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},XQ=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new KQ(t)}draw(e){let t=HJ(e),{drawLines:n,drawPoints:r,lineWidth:a,lineColor:s,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof EJ&&(t.strokeStyle=s,t.lineWidth=a,XZ(t,this.faceLandmarks.getJawOutline()),XZ(t,this.faceLandmarks.getLeftEyeBrow()),XZ(t,this.faceLandmarks.getRightEyeBrow()),XZ(t,this.faceLandmarks.getNose()),XZ(t,this.faceLandmarks.getLeftEye(),!0),XZ(t,this.faceLandmarks.getRightEye(),!0),XZ(t,this.faceLandmarks.getMouth(),!0)),r){t.strokeStyle=o,t.fillStyle=o;let e=e=>{t.beginPath(),t.arc(e.x,e.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(e)}}};function YQ(e,t){(Array.isArray(t)?t:[t]).forEach((t=>{let n=t instanceof _J?t:jQ(t)?t.landmarks:void 0;if(!n)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new XQ(n).draw(e)}))}function ZQ(e,t){let n=[],{extractWeights:r,getRemainingWeights:a}=FQ(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=function(e,t){let n=TQ(e,t),r=EQ(e,t);return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:function(e,t,a){return{separable_conv0:r(e,t,`${a}/separable_conv0`),separable_conv1:r(t,t,`${a}/separable_conv1`),expansion_conv:n(e,t,1,`${a}/expansion_conv`)}},extractMainBlockParams:function(e,t){return{separable_conv0:r(e,e,`${t}/separable_conv0`),separable_conv1:r(e,e,`${t}/separable_conv1`),separable_conv2:r(e,e,`${t}/separable_conv2`)}}}}(r,n),u={conv_in:s(3,32,3,"entry_flow/conv_in"),reduction_block_0:o(32,64,"entry_flow/reduction_block_0"),reduction_block_1:o(64,128,"entry_flow/reduction_block_1")},p={};uJ(t,0,1).forEach((e=>{p[`main_block_${e}`]=l(128,`middle_flow/main_block_${e}`)}));let d={reduction_block:o(128,256,"exit_flow/reduction_block"),separable_conv:i(256,512,"exit_flow/separable_conv")};if(0!==a().length)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:n,params:{entry_flow:u,middle_flow:p,exit_flow:d}}}function JQ(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}=function(e,t){let n=AQ(e,t),r=DQ(n),a=$Q(n);return{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:function(e){return{separable_conv0:a(`${e}/separable_conv0`),separable_conv1:a(`${e}/separable_conv1`),expansion_conv:r(`${e}/expansion_conv`)}},extractMainBlockParams:function(e){return{separable_conv0:a(`${e}/separable_conv0`),separable_conv1:a(`${e}/separable_conv1`),separable_conv2:a(`${e}/separable_conv2`)}}}}(e,n),o={conv_in:r("entry_flow/conv_in"),reduction_block_0:s("entry_flow/reduction_block_0"),reduction_block_1:s("entry_flow/reduction_block_1")},l={};uJ(t,0,1).forEach((e=>{l[`main_block_${e}`]=i(`middle_flow/main_block_${e}`)}));let u={reduction_block:s("exit_flow/reduction_block"),separable_conv:a("exit_flow/separable_conv")};return NQ(e,n),{params:{entry_flow:o,middle_flow:l,exit_flow:u},paramMappings:n}}function QQ(e,t,n){return xo(Il(e,t.filters,n,"same"),t.bias)}function e0(e,t,n=!0){let r=n?id(e):e;return r=vQ(r,t.separable_conv0,[1,1]),r=vQ(id(r),t.separable_conv1,[1,1]),r=np(r,[3,3],[2,2],"same"),r=xo(r,QQ(e,t.expansion_conv,[2,2])),r}var t0=class extends wQ{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return ri((()=>{let n=wJ(go(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),r=id(QQ(n,t.entry_flow.conv_in,[2,2]));return r=e0(r,t.entry_flow.reduction_block_0,!1),r=e0(r,t.entry_flow.reduction_block_1),uJ(this._numMainBlocks,0,1).forEach((e=>{r=function(e,t){let n=vQ(id(e),t.separable_conv0,[1,1]);return n=vQ(id(n),t.separable_conv1,[1,1]),n=vQ(id(n),t.separable_conv2,[1,1]),n=xo(n,e),n}(r,t.middle_flow[`main_block_${e}`])})),r=e0(r,t.exit_flow.reduction_block),r=id(vQ(r,t.exit_flow.separable_conv,[1,1])),r}))}async forward(e){return this.forwardInput(await uQ(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return JQ(e,this._numMainBlocks)}extractParams(e){return ZQ(e,this._numMainBlocks)}};var n0,r0=((n0=r0||{}).FEMALE="female",n0.MALE="male",n0),a0=class extends wQ{constructor(e=new t0(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return ri((()=>{let n=e instanceof lQ?this.faceFeatureExtractor.forwardInput(e):e,r=Jo(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1);return{age:LQ(r,t.fc.age).as1D(),gender:LQ(r,t.fc.gender)}}))}forwardInput(e){return ri((()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:Nd(n)}}))}async forward(e){return this.forwardInput(await uQ(e))}async predictAgeAndGender(e){let t=await uQ(e),n=await this.forwardInput(t),r=Jd(n.age),a=Jd(n.gender),s=r.map(((e,t)=>({ageTensor:e,genderTensor:a[t]}))),i=await Promise.all(s.map((async({ageTensor:e,genderTensor:t})=>{let n=e.dataSync()[0],r=t.dataSync()[0],a=r>.5,s=a?"male":"female",i=a?r:1-r;return e.dispose(),t.dispose(),{age:n,gender:s,genderProbability:i}})));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=FQ(e),a=_Q(n,t),s=a(512,1,"fc/age"),i=a(512,2,"fc/gender");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:s,gender:i}}}}(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=zQ(e);return this.faceFeatureExtractor.loadFromWeightMap(t),function(e){let t=[],n=AQ(e,t);function r(e){return{weights:n(`${e}/weights`,2),bias:n(`${e}/bias`,1)}}let a={fc:{age:r("fc/age"),gender:r("fc/gender")}};return NQ(e,t),{params:a,paramMappings:t}}(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}},s0=class extends PQ{postProcess(e,t,n){let r=n.map((({width:e,height:n})=>{let r=t/Math.max(n,e);return{width:e*r,height:n*r}})),a=r.length;return ri((()=>{let n=(e,t)=>Rd([yl([68],e,"float32"),yl([68],t,"float32")],1).as2D(1,136).as1D(),s=(e,t)=>{let{width:n,height:a}=r[e];return t(n,a)?Math.abs(n-a)/2:0};return e.mul(yl([a,136],t,"float32")).sub(Rd(Array.from(Array(a),((e,t)=>n((e=>s(e,((e,t)=>e<t)))(t),(e=>s(e,((e,t)=>t<e)))(t)))))).div(Rd(Array.from(Array(a),((e,t)=>n(r[t].width,r[t].height)))))}))}forwardInput(e){return ri((()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map((([e,t])=>({height:e,width:t}))))}))}async forward(e){return this.forwardInput(await uQ(e))}async detectLandmarks(e){let t=await uQ(e),n=ri((()=>Jd(this.forwardInput(t)))),r=await Promise.all(n.map((async(e,n)=>{let r=Array.from(e.dataSync()),a=r.filter(((e,t)=>aJ(t))),s=r.filter(((e,t)=>!aJ(t)));return new EJ(Array(68).fill(0).map(((e,t)=>new hJ(a[t],s[t]))),{height:t.getInputHeight(n),width:t.getInputWidth(n)})})));return n.forEach((e=>e.dispose())),t.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},i0=class extends s0{constructor(e=new OQ){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};var o0=class extends wQ{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return ri((()=>{let n=kQ(wJ(go(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),t.dense0,!0);return n=kQ(n,t.dense1),n=kQ(n,t.dense2),n=Jo(n,[14,14],[2,2],"valid"),n}))}async forward(e){return this.forwardInput(await uQ(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractDenseBlock3Params:n}=MQ(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return NQ(e,t),{params:r,paramMappings:t}}(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=FQ(e),{extractDenseBlock3Params:a}=RQ(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}(e)}},l0=class extends s0{constructor(e=new o0){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}},u0=class extends i0{};function p0(e,t,n,r,a="same"){let{filters:s,bias:i}=t.conv,o=Il(e,s,n,a);return o=xo(o,i),o=function(e,t){return xo(ko(e,t.weights),t.biases)}(o,t.scale),r?id(o):o}function d0(e,t){return p0(e,t,[1,1],!1)}function h0(e,t){return p0(e,t,[2,2],!0,"valid")}function c0(e,t){function n(n,r,a,s){let i=function(t,n,r){let a=e(t),s=a.length/(n*r*r);if(rJ(s))throw new Error(`depth has to be an integer: ${s}, weights.length: ${a.length}, numFilters: ${n}, filterSize: ${r}`);return ri((()=>ah(Bd(a,[n,s,r,r]),[2,3,1,0])))}(n,r,a),o=Ld(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}function r(r,a,s,i){let o=n(r,a,s,`${i}/conv`),l=function(n,r){let a=Ld(e(n)),s=Ld(e(n));return t.push({paramPath:`${r}/weights`},{paramPath:`${r}/biases`}),{weights:a,biases:s}}(a,`${i}/scale`);return{conv:o,scale:l}}return{extractConvLayerParams:r,extractResidualLayerParams:function(e,t,n,a,s=!1){return{conv1:r((s?.5:1)*e,t,n,`${a}/conv1`),conv2:r(e,t,n,`${a}/conv2`)}}}}function f0(e,t){let n=AQ(e,t);function r(e){let t=n(`${e}/conv/filters`,4),r=n(`${e}/conv/bias`,1),a=function(e){return{weights:n(`${e}/scale/weights`,1),biases:n(`${e}/scale/biases`,1)}}(e);return{conv:{filters:t,bias:r},scale:a}}return{extractConvLayerParams:r,extractResidualLayerParams:function(e){return{conv1:r(`${e}/conv1`),conv2:r(`${e}/conv2`)}}}}function m0(e,t){let n=function(e,t){return p0(e,t,[1,1],!0)}(e,t.conv1);return n=d0(n,t.conv2),n=xo(n,e),n=id(n),n}function g0(e,t){let n=h0(e,t.conv1);n=d0(n,t.conv2);let r=Jo(e,2,2,"valid"),a=op(r.shape),s=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let e=[...n.shape];e[1]=1;let t=op(e);n=el([n,t],1);let r=[...n.shape];r[2]=1;let a=op(r);n=el([n,a],2)}return r=s?el([r,a],3):r,n=xo(r,n),n=id(n),n}var y0=class extends wQ{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return ri((()=>{let n=h0(wJ(go(e.toBatchTensor(150,!0),"float32"),[122.782,117.001,104.298]).div(255),t.conv32_down);n=np(n,3,2,"valid"),n=m0(n,t.conv32_1),n=m0(n,t.conv32_2),n=m0(n,t.conv32_3),n=g0(n,t.conv64_down),n=m0(n,t.conv64_1),n=m0(n,t.conv64_2),n=m0(n,t.conv64_3),n=g0(n,t.conv128_down),n=m0(n,t.conv128_1),n=m0(n,t.conv128_2),n=g0(n,t.conv256_down),n=m0(n,t.conv256_1),n=m0(n,t.conv256_2),n=g0(n,t.conv256_down_out);let r=n.mean([1,2]);return tl(r,t.fc)}))}async forward(e){return this.forwardInput(await uQ(e))}async computeFaceDescriptor(e){var t;if(null!=(t=null==e?void 0:e.shape)&&t.some((e=>e<=0)))return new Float32Array(128);let n=await uQ(e),r=ri((()=>Jd(this.forwardInput(n)))),a=await Promise.all(r.map((e=>e.data())));return r.forEach((e=>e.dispose())),n.isBatchInput?a:a[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=f0(e,t),a=n("conv32_down"),s=r("conv32_1"),i=r("conv32_2"),o=r("conv32_3"),l=r("conv64_down"),u=r("conv64_1"),p=r("conv64_2"),d=r("conv64_3"),h=r("conv128_down"),c=r("conv128_1"),f=r("conv128_2"),m=r("conv256_down"),g=r("conv256_1"),y=r("conv256_2"),b=r("conv256_down_out"),{fc:x}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!eJ(x))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${x}`);let w={conv32_down:a,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:u,conv64_2:p,conv64_3:d,conv128_down:h,conv128_1:c,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:y,conv256_down_out:b,fc:x};return NQ(e,t),{params:w,paramMappings:t}}(e)}extractParams(e){return function(e){let{extractWeights:t,getRemainingWeights:n}=FQ(e),r=[],{extractConvLayerParams:a,extractResidualLayerParams:s}=c0(t,r),i=a(4704,32,7,"conv32_down"),o=s(9216,32,3,"conv32_1"),l=s(9216,32,3,"conv32_2"),u=s(9216,32,3,"conv32_3"),p=s(36864,64,3,"conv64_down",!0),d=s(36864,64,3,"conv64_1"),h=s(36864,64,3,"conv64_2"),c=s(36864,64,3,"conv64_3"),f=s(147456,128,3,"conv128_down",!0),m=s(147456,128,3,"conv128_1"),g=s(147456,128,3,"conv128_2"),y=s(589824,256,3,"conv256_down",!0),b=s(589824,256,3,"conv256_1"),x=s(589824,256,3,"conv256_2"),w=s(589824,256,3,"conv256_down_out"),v=ri((()=>ah(zd(t(32768),[128,256]),[1,0])));if(r.push({paramPath:"fc"}),0!==n().length)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:u,conv64_down:p,conv64_1:d,conv64_2:h,conv64_3:c,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:y,conv256_1:b,conv256_2:x,conv256_down_out:w,fc:v},paramMappings:r}}(e)}};function b0(e){let t=new y0;return t.extractWeights(e),t}function x0(e,t){return{...e,descriptor:t}}function w0(e){return"number"==typeof e.age}function v0(e,t){return{...e,age:t}}function k0(e){return("male"===e.gender||"female"===e.gender)&&dJ(e.genderProbability)}function I0(e,t,n){return{...e,gender:t,genderProbability:n}}function S0(e,t){function n(n,r,a,s,i){let o=Bd(e(n*r*a*a),[a,a,n,r]),l=Ld(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/${i?"batch_norm_offset":"bias"}`}),{filters:o,bias:l}}function r(e,t,r,a){let{filters:s,bias:i}=n(e,t,r,a,!0);return{filters:s,batch_norm_offset:i}}function a(n,a,s){let i=function(n,r){let a=Bd(e(9*n),[3,3,n,1]),s=Ld(e(n)),i=Ld(e(n)),o=Ld(e(n)),l=Ld(e(n));return t.push({paramPath:`${r}/filters`},{paramPath:`${r}/batch_norm_scale`},{paramPath:`${r}/batch_norm_offset`},{paramPath:`${r}/batch_norm_mean`},{paramPath:`${r}/batch_norm_variance`}),{filters:a,batch_norm_scale:s,batch_norm_offset:i,batch_norm_mean:o,batch_norm_variance:l}}(n,`${s}/depthwise_conv`);return{depthwise_conv:i,pointwise_conv:r(n,a,1,`${s}/pointwise_conv`)}}return{extractMobilenetV1Params:function(){return{conv_0:r(3,32,3,"mobilenetv1/conv_0"),conv_1:a(32,64,"mobilenetv1/conv_1"),conv_2:a(64,128,"mobilenetv1/conv_2"),conv_3:a(128,128,"mobilenetv1/conv_3"),conv_4:a(128,256,"mobilenetv1/conv_4"),conv_5:a(256,256,"mobilenetv1/conv_5"),conv_6:a(256,512,"mobilenetv1/conv_6"),conv_7:a(512,512,"mobilenetv1/conv_7"),conv_8:a(512,512,"mobilenetv1/conv_8"),conv_9:a(512,512,"mobilenetv1/conv_9"),conv_10:a(512,512,"mobilenetv1/conv_10"),conv_11:a(512,512,"mobilenetv1/conv_11"),conv_12:a(512,1024,"mobilenetv1/conv_12"),conv_13:a(1024,1024,"mobilenetv1/conv_13")}},extractPredictionLayerParams:function(){return{conv_0:r(1024,256,1,"prediction_layer/conv_0"),conv_1:r(256,512,3,"prediction_layer/conv_1"),conv_2:r(512,128,1,"prediction_layer/conv_2"),conv_3:r(128,256,3,"prediction_layer/conv_3"),conv_4:r(256,128,1,"prediction_layer/conv_4"),conv_5:r(128,256,3,"prediction_layer/conv_5"),conv_6:r(256,64,1,"prediction_layer/conv_6"),conv_7:r(64,128,3,"prediction_layer/conv_7"),box_predictor_0:{box_encoding_predictor:n(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),class_predictor:n(512,9,1,"prediction_layer/box_predictor_0/class_predictor")},box_predictor_1:{box_encoding_predictor:n(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),class_predictor:n(1024,18,1,"prediction_layer/box_predictor_1/class_predictor")},box_predictor_2:{box_encoding_predictor:n(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),class_predictor:n(512,18,1,"prediction_layer/box_predictor_2/class_predictor")},box_predictor_3:{box_encoding_predictor:n(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),class_predictor:n(256,18,1,"prediction_layer/box_predictor_3/class_predictor")},box_predictor_4:{box_encoding_predictor:n(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),class_predictor:n(256,18,1,"prediction_layer/box_predictor_4/class_predictor")},box_predictor_5:{box_encoding_predictor:n(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),class_predictor:n(128,18,1,"prediction_layer/box_predictor_5/class_predictor")}}}}}function N0(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=function(e,t){let n=AQ(e,t);function r(e,t,r){return{filters:n(`${e}/Conv2d_${t}_pointwise/weights`,4,`${r}/filters`),batch_norm_offset:n(`${e}/Conv2d_${t}_pointwise/convolution_bn_offset`,1,`${r}/batch_norm_offset`)}}function a(e){let t=`mobilenetv1/conv_${e}`,a=`MobilenetV1/Conv2d_${e}_depthwise`,s=`${t}/depthwise_conv`,i=`${t}/pointwise_conv`;return{depthwise_conv:{filters:n(`${a}/depthwise_weights`,4,`${s}/filters`),batch_norm_scale:n(`${a}/BatchNorm/gamma`,1,`${s}/batch_norm_scale`),batch_norm_offset:n(`${a}/BatchNorm/beta`,1,`${s}/batch_norm_offset`),batch_norm_mean:n(`${a}/BatchNorm/moving_mean`,1,`${s}/batch_norm_mean`),batch_norm_variance:n(`${a}/BatchNorm/moving_variance`,1,`${s}/batch_norm_variance`)},pointwise_conv:r("MobilenetV1",e,i)}}function s(e,t){return{filters:n(`${e}/weights`,4,`${t}/filters`),bias:n(`${e}/biases`,1,`${t}/bias`)}}function i(e){return{box_encoding_predictor:s(`Prediction/BoxPredictor_${e}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${e}/box_encoding_predictor`),class_predictor:s(`Prediction/BoxPredictor_${e}/ClassPredictor`,`prediction_layer/box_predictor_${e}/class_predictor`)}}return{extractMobilenetV1Params:function(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:a(1),conv_2:a(2),conv_3:a(3),conv_4:a(4),conv_5:a(5),conv_6:a(6),conv_7:a(7),conv_8:a(8),conv_9:a(9),conv_10:a(10),conv_11:a(11),conv_12:a(12),conv_13:a(13)}},extractPredictionLayerParams:function(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:i(0),box_predictor_1:i(1),box_predictor_2:i(2),box_predictor_3:i(3),box_predictor_4:i(4),box_predictor_5:i(5)}}}}(e,t),a=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!tJ(a))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${a}`);let s={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:a}};return NQ(e,t),{params:s,paramMappings:t}}function T0(e,t,n){return ri((()=>{let r=Il(e,t.filters,n,"same");return r=xo(r,t.batch_norm_offset),bl(r,0,6)}))}var _0=.0010000000474974513;function C0(e,t){return ri((()=>{let n,r=T0(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach(((e,t)=>{let a=t+1,s=function(e){return[2,4,6,12].some((t=>t===e))?[2,2]:[1,1]}(a);r=function(e,t,n){return ri((()=>{let r=Ol(e,t.filters,n,"same");return r=ll(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,_0),bl(r,0,6)}))}(r,e.depthwise_conv,s),r=T0(r,e.pointwise_conv,[1,1]),11===a&&(n=r)})),null===n)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}}))}function E0(e,t,n){let r=e.arraySync(),a=Math.min(r[t][0],r[t][2]),s=Math.min(r[t][1],r[t][3]),i=Math.max(r[t][0],r[t][2]),o=Math.max(r[t][1],r[t][3]),l=Math.min(r[n][0],r[n][2]),u=Math.min(r[n][1],r[n][3]),p=Math.max(r[n][0],r[n][2]),d=Math.max(r[n][1],r[n][3]),h=(i-a)*(o-s),c=(p-l)*(d-u);if(h<=0||c<=0)return 0;let f=Math.max(a,l),m=Math.max(s,u),g=Math.min(i,p),y=Math.min(o,d),b=Math.max(g-f,0)*Math.max(y-m,0);return b/(h+c-b)}function $0(e,t){let{sizes:n,centers:r}=function(e){let t=Jd(ah(e,[1,0])),n=[ju(t[2],t[0]),ju(t[3],t[1])];return{sizes:n,centers:[xo(t[0],vo(n[0],2)),xo(t[1],vo(n[1],2))]}}(e),a=Jd(ah(t,[1,0])),s=vo(ko(gu(vo(a[2],5)),n[0]),2),i=xo(ko(vo(a[0],10),n[0]),r[0]),o=vo(ko(gu(vo(a[3],5)),n[1]),2),l=xo(ko(vo(a[1],10),n[1]),r[1]);return ah(Rd([ju(i,s),ju(l,o),xo(i,s),xo(l,o)]),[1,0])}function A0(e,t){return ri((()=>{let n=e.shape[0];return{boxPredictionEncoding:Zo(SQ(e,t.box_encoding_predictor),[n,-1,1,4]),classPrediction:Zo(SQ(e,t.class_predictor),[n,-1,3])}}))}var F0=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,"number"!=typeof this._minConfidence||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if("number"!=typeof this._maxResults)throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},R0=class extends wQ{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return ri((()=>{let n=go(e.toBatchTensor(512,!1),"float32"),r=C0(ju(vo(n,127.5),1),t.mobilenetv1),{boxPredictions:a,classPredictions:s}=function(e,t,n){return ri((()=>{let r=T0(e,n.conv_0,[1,1]),a=T0(r,n.conv_1,[2,2]),s=T0(a,n.conv_2,[1,1]),i=T0(s,n.conv_3,[2,2]),o=T0(i,n.conv_4,[1,1]),l=T0(o,n.conv_5,[2,2]),u=T0(l,n.conv_6,[1,1]),p=T0(u,n.conv_7,[2,2]),d=A0(t,n.box_predictor_0),h=A0(e,n.box_predictor_1),c=A0(a,n.box_predictor_2),f=A0(i,n.box_predictor_3),m=A0(l,n.box_predictor_4),g=A0(p,n.box_predictor_5);return{boxPredictions:el([d.boxPredictionEncoding,h.boxPredictionEncoding,c.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),classPredictions:el([d.classPrediction,h.classPrediction,c.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1)}}))}(r.out,r.conv11,t.prediction_layer);return function(e,t,n){return ri((()=>{let r=e.shape[0],a=$0(Zo(xu(n.extra_dim,[r,1,1]),[-1,4]),Zo(e,[-1,4]));a=Zo(a,[r,a.shape[0]/r,4]);let s=nl(rl(t,[0,0,1],[-1,-1,-1])),i=rl(s,[0,0,0],[-1,-1,1]);return i=Zo(i,[r,i.shape[1]]),{boxes:Jd(a),scores:Jd(i)}}))}(a,s,t.output_layer)}))}async forward(e){return this.forwardInput(await uQ(e))}async locateFaces(e,t={}){let{maxResults:n,minConfidence:r}=new F0(t),a=await uQ(e),{boxes:s,scores:i}=this.forwardInput(a),o=s[0],l=i[0];for(let e=1;e<s.length;e++)s[e].dispose(),i[e].dispose();let u=Array.from(l.dataSync()),p=function(e,t,n,r,a){let s=e.shape[0],i=Math.min(n,s),o=t.map(((e,t)=>({score:e,boxIndex:t}))).filter((e=>e.score>a)).sort(((e,t)=>t.score-e.score)),l=e=>e<=r?1:0,u=[];return o.forEach((t=>{if(u.length>=i)return;let n=t.score;for(let n=u.length-1;n>=0;--n){let r=E0(e,t.boxIndex,u[n]);if(0!==r&&(t.score*=l(r),t.score<=a))break}n===t.score&&u.push(t.boxIndex)})),u}(o,u,n,.5,r),d=a.getReshapedInputDimensions(0),h=a.inputSize,c=h/d.width,f=h/d.height,m=o.arraySync(),g=p.map((e=>{let[t,n]=[Math.max(0,m[e][0]),Math.min(1,m[e][2])].map((e=>e*f)),[r,s]=[Math.max(0,m[e][1]),Math.min(1,m[e][3])].map((e=>e*c));return new gJ(u[e],new TJ(r,t,s-r,n-t),{height:a.getInputHeight(0),width:a.getInputWidth(0)})}));return o.dispose(),l.dispose(),g}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return N0(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=FQ(e),{extractMobilenetV1Params:a,extractPredictionLayerParams:s}=S0(n,t),i=a(),o=s(),l={extra_dim:Pd(n(20472),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:l},paramMappings:t}}(e)}};function D0(e){let t=new R0;return t.extractWeights(e),t}function M0(e){return D0(e)}var O0=class extends R0{},L0=[new hJ(.738768,.874946),new hJ(2.42204,2.65704),new hJ(4.30971,7.04493),new hJ(10.246,4.59428),new hJ(12.6868,11.8741)],z0=[new hJ(1.603231,2.094468),new hJ(6.041143,7.080126),new hJ(2.882459,3.518061),new hJ(4.266906,5.178857),new hJ(9.041765,10.66308)],P0=[117.001,114.697,97.404],B0=e=>"number"==typeof e;function W0(e){if(!e)throw new Error(`invalid config: ${e}`);if("boolean"!=typeof e.withSeparableConvs)throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!B0(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every((e=>"string"==typeof e)))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map((e=>e||{})).every((e=>B0(e.x)&&B0(e.y))))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||3!==e.meanRgb.length||!e.meanRgb.every(B0)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function V0(e){return ri((()=>{let t=ko(e,uu(.10000000149011612));return xo(id(ju(e,t)),t)}))}function U0(e,t){return ri((()=>{let n=wp(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Il(n,t.conv.filters,[1,1],"valid"),n=ju(n,t.bn.sub),n=ko(n,t.bn.truediv),n=xo(n,t.conv.bias),V0(n)}))}function G0(e,t){return ri((()=>{let n=wp(e,[[0,0],[1,1],[1,1],[0,0]]);return n=gd(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=xo(n,t.bias),V0(n)}))}function H0(e,t){let n=TQ(e,t);let r=EQ(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:function(r,a,s){let i=n(r,a,3,`${s}/conv`),o=function(n,r){let a=Ld(e(n)),s=Ld(e(n));return t.push({paramPath:`${r}/sub`},{paramPath:`${r}/truediv`}),{sub:a,truediv:s}}(a,`${s}/bn`);return{conv:i,bn:o}},extractSeparableConvParams:r}}function j0(e,t){let n=AQ(e,t);function r(e){return{filters:n(`${e}/filters`,4),bias:n(`${e}/bias`,1)}}return{extractConvParams:r,extractConvWithBatchNormParams:function(e){let t=r(`${e}/conv`),a=function(e){return{sub:n(`${e}/sub`,1),truediv:n(`${e}/truediv`,1)}}(`${e}/bn`);return{conv:t,bn:a}},extractSeparableConvParams:$Q(n)}}var q0=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,"number"!=typeof this._inputSize||this._inputSize%32!=0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if("number"!=typeof this._scoreThreshold||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},K0=class e extends wQ{constructor(e){super("TinyYolov2"),W0(e),this._config=e}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(e,t){let n=U0(e,t.conv0);return n=np(n,[2,2],[2,2],"same"),n=U0(n,t.conv1),n=np(n,[2,2],[2,2],"same"),n=U0(n,t.conv2),n=np(n,[2,2],[2,2],"same"),n=U0(n,t.conv3),n=np(n,[2,2],[2,2],"same"),n=U0(n,t.conv4),n=np(n,[2,2],[2,2],"same"),n=U0(n,t.conv5),n=np(n,[2,2],[1,1],"same"),n=U0(n,t.conv6),n=U0(n,t.conv7),SQ(n,t.conv8,"valid",!1)}runMobilenet(e,t){let n=this.config.isFirstLayerConv2d?V0(SQ(e,t.conv0,"valid",!1)):G0(e,t.conv0);return n=np(n,[2,2],[2,2],"same"),n=G0(n,t.conv1),n=np(n,[2,2],[2,2],"same"),n=G0(n,t.conv2),n=np(n,[2,2],[2,2],"same"),n=G0(n,t.conv3),n=np(n,[2,2],[2,2],"same"),n=G0(n,t.conv4),n=np(n,[2,2],[2,2],"same"),n=G0(n,t.conv5),n=np(n,[2,2],[1,1],"same"),n=t.conv6?G0(n,t.conv6):n,n=t.conv7?G0(n,t.conv7):n,SQ(n,t.conv8,"valid",!1)}forwardInput(e,t){let{params:n}=this;if(!n)throw new Error("TinyYolov2 - load model before inference");return ri((()=>{let r=go(e.toBatchTensor(t,!1),"float32");return r=this.config.meanRgb?wJ(r,this.config.meanRgb):r,r=r.div(255),this.config.withSeparableConvs?this.runMobilenet(r,n):this.runTinyYolov2(r,n)}))}async forward(e,t){return this.forwardInput(await uQ(e),t)}async detect(e,t={}){let{inputSize:n,scoreThreshold:r}=new q0(t),a=await uQ(e),s=await this.forwardInput(a,n),i=ri((()=>Jd(s)[0].expandDims())),o={width:a.getInputWidth(0),height:a.getInputHeight(0)},l=await this.extractBoxes(i,a.getReshapedInputDimensions(0),r);s.dispose(),i.dispose();let u=l.map((e=>e.box)),p=l.map((e=>e.score)),d=l.map((e=>e.classScore)),h=l.map((e=>this.config.classes[e.label]));return xJ(u.map((e=>e.rescale(n))),p,this.config.iouThreshold,!0).map((e=>new mJ(p[e],d[e],h[e],u[e],o)))}getDefaultModelName(){return""}extractParamsFromWeightMap(e){return function(e,t){let n,r=[],{extractConvParams:a,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}=j0(e,r);if(t.withSeparableConvs){let e=t.filterSizes&&t.filterSizes.length||9;n={conv0:t.isFirstLayerConv2d?a("conv0"):i("conv0"),conv1:i("conv1"),conv2:i("conv2"),conv3:i("conv3"),conv4:i("conv4"),conv5:i("conv5"),conv6:e>7?i("conv6"):void 0,conv7:e>8?i("conv7"):void 0,conv8:a("conv8")}}else n={conv0:s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:s("conv6"),conv7:s("conv7"),conv8:a("conv8")};return NQ(e,r),{params:n,paramMappings:r}}(e,this.config)}extractParams(t){let n=this.config.filterSizes||e.DEFAULT_FILTER_SIZES,r=n?n.length:void 0;if(7!==r&&8!==r&&9!==r)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${r} filterSizes in config`);return function(e,t,n,r){let a,{extractWeights:s,getRemainingWeights:i}=FQ(e),o=[],{extractConvParams:l,extractConvWithBatchNormParams:u,extractSeparableConvParams:p}=H0(s,o);if(t.withSeparableConvs){let[e,s,i,o,u,d,h,c,f]=r;a={conv0:t.isFirstLayerConv2d?l(e,s,3,"conv0"):p(e,s,"conv0"),conv1:p(s,i,"conv1"),conv2:p(i,o,"conv2"),conv3:p(o,u,"conv3"),conv4:p(u,d,"conv4"),conv5:p(d,h,"conv5"),conv6:c?p(h,c,"conv6"):void 0,conv7:f?p(c,f,"conv7"):void 0,conv8:l(f||c||h,5*n,1,"conv8")}}else{let[e,t,s,i,o,p,d,h,c]=r;a={conv0:u(e,t,"conv0"),conv1:u(t,s,"conv1"),conv2:u(s,i,"conv2"),conv3:u(i,o,"conv3"),conv4:u(o,p,"conv4"),conv5:u(p,d,"conv5"),conv6:u(d,h,"conv6"),conv7:u(h,c,"conv7"),conv8:l(c,5*n,1,"conv8")}}if(0!==i().length)throw new Error(`weights remaing after extract: ${i().length}`);return{params:a,paramMappings:o}}(t,this.config,this.boxEncodingSize,n)}async extractBoxes(e,t,n){let{width:r,height:a}=t,s=Math.max(r,a),i=s/r,o=s/a,l=e.shape[1],u=this.config.anchors.length,[p,d,h]=ri((()=>{let t=e.reshape([l,l,u,this.boxEncodingSize]);return[t.slice([0,0,0,0],[l,l,u,4]),t.slice([0,0,0,4],[l,l,u,1]),this.withClassScores?Nd(t.slice([0,0,0,5],[l,l,u,this.config.classes.length]),3):uu(0)]})),c=[],f=await d.array(),m=await p.array();for(let e=0;e<l;e++)for(let t=0;t<l;t++)for(let r=0;r<u;r++){let a=IJ(f[e][t][r][0]);if(!n||a>n){let n=(t+IJ(m[e][t][r][0]))/l*i,s=(e+IJ(m[e][t][r][1]))/l*o,u=Math.exp(m[e][t][r][2])*this.config.anchors[r].x/l*i,p=Math.exp(m[e][t][r][3])*this.config.anchors[r].y/l*o,d=n-u/2,f=s-p/2,g={row:e,col:t,anchor:r},{classScore:y,label:b}=this.withClassScores?await this.extractPredictedClass(h,g):{classScore:1,label:0};c.push({box:new fJ(d,f,d+u,f+p),score:a,classScore:a*y,label:b,...g})}}return p.dispose(),d.dispose(),h.dispose(),c}async extractPredictedClass(e,t){let{row:n,col:r,anchor:a}=t,s=await e.array();return Array(this.config.classes.length).fill(0).map(((e,t)=>s[n][r][a][t])).map(((e,t)=>({classScore:e,label:t}))).reduce(((e,t)=>e.classScore>t.classScore?e:t))}};K0.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var X0=K0,Y0=class extends X0{constructor(e=!0){super({withSeparableConvs:e,iouThreshold:.4,classes:["face"],...e?{anchors:z0,meanRgb:P0}:{anchors:L0,withClassScores:!0}})}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map((e=>new gJ(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight})))}getDefaultModelName(){return this.withSeparableConvs?"tiny_yolov2_separable_conv_model":"tiny_yolov2_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}};function Z0(e,t=!0){let n=new Y0(t);return n.extractWeights(e),n}var J0=class extends q0{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},Q0=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function e1(e,t,n,r,a=(({alignedRect:e})=>e)){let s=e.map((e=>jQ(e)?a(e):e.detection)),i=r||(t instanceof is?await dQ(t,s):await pQ(t,s)),o=await n(i);return i.forEach((e=>e instanceof is&&e.dispose())),o}async function t1(e,t,n,r,a){return e1([e],t,(async e=>n(e[0])),r,a)}var n1=[new hJ(1.603231,2.094468),new hJ(6.041143,7.080126),new hJ(2.882459,3.518061),new hJ(4.266906,5.178857),new hJ(9.041765,10.66308)],r1=[117.001,114.697,97.404],a1=class extends X0{constructor(){super({withSeparableConvs:!0,iouThreshold:.4,classes:["face"],anchors:n1,meanRgb:r1,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]})}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map((e=>new gJ(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight})))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},s1={ssdMobilenetv1:new R0,tinyFaceDetector:new a1,tinyYolov2:new Y0,faceLandmark68Net:new i0,faceLandmark68TinyNet:new l0,faceRecognitionNet:new y0,faceExpressionNet:new VQ,ageGenderNet:new a0},i1=(e,t)=>s1.ssdMobilenetv1.locateFaces(e,t),o1=(e,t)=>s1.tinyFaceDetector.locateFaces(e,t),l1=(e,t)=>s1.tinyYolov2.locateFaces(e,t),u1=e=>s1.faceLandmark68Net.detectLandmarks(e),p1=e=>s1.faceLandmark68TinyNet.detectLandmarks(e),d1=e=>s1.faceRecognitionNet.computeFaceDescriptor(e),h1=e=>s1.faceExpressionNet.predictExpressions(e),c1=e=>s1.ageGenderNet.predictAgeAndGender(e),f1=e=>s1.ssdMobilenetv1.load(e),m1=e=>s1.tinyFaceDetector.load(e),g1=e=>s1.tinyYolov2.load(e),y1=e=>s1.faceLandmark68Net.load(e),b1=e=>s1.faceLandmark68TinyNet.load(e),x1=e=>s1.faceRecognitionNet.load(e),w1=e=>s1.faceExpressionNet.load(e),v1=e=>s1.ageGenderNet.load(e),k1=f1,I1=i1,S1=u1,N1=class extends Q0{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},T1=class extends N1{async run(){let e=await this.parentTask,t=await e1(e,this.input,(async e=>Promise.all(e.map((e=>s1.faceExpressionNet.predictExpressions(e))))),this.extractedFaces);return e.map(((e,n)=>GQ(e,t[n])))}withAgeAndGender(){return new A1(this,this.input)}},_1=class extends N1{async run(){let e=await this.parentTask;if(e)return GQ(e,await t1(e,this.input,(e=>s1.faceExpressionNet.predictExpressions(e)),this.extractedFaces))}withAgeAndGender(){return new F1(this,this.input)}},C1=class extends T1{withAgeAndGender(){return new R1(this,this.input)}withFaceDescriptors(){return new O1(this,this.input)}},E1=class extends _1{withAgeAndGender(){return new D1(this,this.input)}withFaceDescriptor(){return new L1(this,this.input)}},$1=class extends Q0{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},A1=class extends $1{async run(){let e=await this.parentTask,t=await e1(e,this.input,(async e=>Promise.all(e.map((e=>s1.ageGenderNet.predictAgeAndGender(e))))),this.extractedFaces);return e.map(((e,n)=>{let{age:r,gender:a,genderProbability:s}=t[n];return v0(I0(e,a,s),r)}))}withFaceExpressions(){return new T1(this,this.input)}},F1=class extends $1{async run(){let e=await this.parentTask;if(!e)return;let{age:t,gender:n,genderProbability:r}=await t1(e,this.input,(e=>s1.ageGenderNet.predictAgeAndGender(e)),this.extractedFaces);return v0(I0(e,n,r),t)}withFaceExpressions(){return new _1(this,this.input)}},R1=class extends A1{withFaceExpressions(){return new C1(this,this.input)}withFaceDescriptors(){return new O1(this,this.input)}},D1=class extends F1{withFaceExpressions(){return new E1(this,this.input)}withFaceDescriptor(){return new L1(this,this.input)}},M1=class extends Q0{constructor(e,t){super(),this.parentTask=e,this.input=t}},O1=class extends M1{async run(){let e=await this.parentTask;return(await e1(e,this.input,(e=>Promise.all(e.map((e=>s1.faceRecognitionNet.computeFaceDescriptor(e))))),null,(e=>e.landmarks.align(null,{useDlibAlignment:!0})))).map(((t,n)=>x0(e[n],t)))}withFaceExpressions(){return new C1(this,this.input)}withAgeAndGender(){return new R1(this,this.input)}},L1=class extends M1{async run(){let e=await this.parentTask;if(e)return x0(e,await t1(e,this.input,(e=>s1.faceRecognitionNet.computeFaceDescriptor(e)),null,(e=>e.landmarks.align(null,{useDlibAlignment:!0}))))}withFaceExpressions(){return new E1(this,this.input)}withAgeAndGender(){return new D1(this,this.input)}},z1=class extends Q0{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?s1.faceLandmark68TinyNet:s1.faceLandmark68Net}},P1=class extends z1{async run(){let e=await this.parentTask,t=e.map((e=>e.detection)),n=this.input instanceof is?await dQ(this.input,t):await pQ(this.input,t),r=await Promise.all(n.map((e=>this.landmarkNet.detectLandmarks(e))));return n.forEach((e=>e instanceof is&&e.dispose())),e.filter(((e,t)=>r[t])).map(((e,t)=>qQ(e,r[t])))}withFaceExpressions(){return new C1(this,this.input)}withAgeAndGender(){return new R1(this,this.input)}withFaceDescriptors(){return new O1(this,this.input)}},B1=class extends z1{async run(){let e=await this.parentTask;if(!e)return;let{detection:t}=e,n=this.input instanceof is?await dQ(this.input,[t]):await pQ(this.input,[t]),r=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach((e=>e instanceof is&&e.dispose())),qQ(e,r)}withFaceExpressions(){return new E1(this,this.input)}withAgeAndGender(){return new D1(this,this.input)}withFaceDescriptor(){return new L1(this,this.input)}},W1=class extends Q0{constructor(e,t=new F0){super(),this.input=e,this.options=t}},V1=class extends W1{async run(){let e,{input:t,options:n}=this;if(n instanceof J0)e=s1.tinyFaceDetector.locateFaces(t,n);else if(n instanceof F0)e=s1.ssdMobilenetv1.locateFaces(t,n);else{if(!(n instanceof q0))throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");e=s1.tinyYolov2.locateFaces(t,n)}return e}runAndExtendWithFaceDetections(){return new Promise(((e,t)=>{this.run().then((t=>e(t.map((e=>MJ({},e)))))).catch((e=>t(e)))}))}withFaceLandmarks(e=!1){return new P1(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new T1(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new A1(this.runAndExtendWithFaceDetections(),this.input)}},U1=class extends W1{async run(){let e=await new V1(this.input,this.options),t=e[0];return e.forEach((e=>{e.score>t.score&&(t=e)})),t}runAndExtendWithFaceDetection(){return new Promise((async e=>{let t=await this.run();e(t?MJ({},t):void 0)}))}withFaceLandmarks(e=!1){return new B1(this.runAndExtendWithFaceDetection(),this.input,e)}withFaceExpressions(){return new _1(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new F1(this.runAndExtendWithFaceDetection(),this.input)}};function G1(e,t=new F0){return new U1(e,t)}function H1(e,t=new F0){return new V1(e,t)}async function j1(e,t){return H1(e,new F0(t?{minConfidence:t}:{})).withFaceLandmarks().withFaceDescriptors()}async function q1(e,t={}){return H1(e,new q0(t)).withFaceLandmarks().withFaceDescriptors()}var K1=j1;function X1(e,t){if(e.length!==t.length)throw new Error("euclideanDistance: arr1.length !== arr2.length");let n=Array.from(e),r=Array.from(t);return Math.sqrt(n.map(((e,t)=>e-r[t])).reduce(((e,t)=>e+t*t),0))}var Y1=class e{constructor(e,t=.6){this._distanceThreshold=t;let n=Array.isArray(e)?e:[e];if(!n.length)throw new Error("FaceRecognizer.constructor - expected atleast one input");let r=1,a=()=>"person "+r++;this._labeledDescriptors=n.map((e=>{if(e instanceof FJ)return e;if(e instanceof Float32Array)return new FJ(a(),[e]);if(e.descriptor&&e.descriptor instanceof Float32Array)return new FJ(a(),[e.descriptor]);throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>")}))}get labeledDescriptors(){return this._labeledDescriptors}get distanceThreshold(){return this._distanceThreshold}computeMeanDistance(e,t){return t.map((t=>X1(t,e))).reduce(((e,t)=>e+t),0)/(t.length||1)}matchDescriptor(e){return this.labeledDescriptors.map((({descriptors:t,label:n})=>new $J(n,this.computeMeanDistance(e,t)))).reduce(((e,t)=>e.distance<t.distance?e:t))}findBestMatch(e){let t=this.matchDescriptor(e);return t.distance<this._distanceThreshold?t:new $J("unknown",t.distance)}toJSON(){return{distanceThreshold:this._distanceThreshold,labeledDescriptors:this._labeledDescriptors.map((e=>e.toJSON()))}}static fromJSON(t){let n=t.labeledDescriptors.map((e=>FJ.fromJSON(e)));return new e(n,t.distanceThreshold)}};function Z1(e){let t=new a1;return t.extractWeights(e),t}function J1(e,t){let{width:n,height:r}=new ZZ(t.width,t.height);if(n<=0||r<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:n,height:r})}`);if(Array.isArray(e))return e.map((e=>J1(e,{width:n,height:r})));if(jQ(e)){let t=e.detection.forSize(n,r),a=e.unshiftedLandmarks.forSize(t.box.width,t.box.height);return qQ(MJ(e,t),a)}return DJ(e)?MJ(e,e.detection.forSize(n,r)):e instanceof _J||e instanceof gJ?e.forSize(n,r):e}var Q1="1.7.15";return(e=>((e,s,i,o)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let l of r(s))!a.call(e,l)&&l!==i&&t(e,l,{get:()=>s[l],enumerable:!(o=n(s,l))||o.enumerable});return e})(t({},"__esModule",{value:!0}),e))(o)})();